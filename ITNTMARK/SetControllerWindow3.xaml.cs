using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Shapes;
using System.Windows.Threading;
using ITNTCOMMON;
using ITNTUTIL;
using System.Data;
using Microsoft.Win32;
using System.Windows.Interop;
using System.Numerics;
using System.Collections.ObjectModel;

#pragma warning disable 1998
#pragma warning disable 0219
#pragma warning disable 4014

namespace ITNTMARK
{
    /// <summary>
    /// SetControllerWindow3.xaml에 대한 상호 작용 논리
    /// </summary>
    /// 

    public partial class SetControllerWindow3 : Window
    {
        //public static bool Wait_IO;
        double orginalWidth, originalHeight;
        ScaleTransform scale = new ScaleTransform();

        byte m_currCMD = 0;
        PatternValueEx orgPattern = new PatternValueEx();

        bool bReadFontValue = false;

        public static MarkVINInformEx currMarkInfo = new MarkVINInformEx();
        Line charline = new Line();
        Ellipse Dotline = new Ellipse();
        bool bshowAlready = false;

        static bool LenzCalibFlag = false;
        List<double> LenzCalib = new List<double>();
        DispatcherTimer statusTimer = new DispatcherTimer();
        double PeakPower = 0;
        int iLaserPeakPower = 0;

        public byte byLaserStartFlag = 0;
        public List<int> iLaserPowerList = new List<int>();


        public ObservableCollection<LogEntry> SetControllerLogEntries { get; set; } = new ObservableCollection<LogEntry>();

        public SetControllerWindow3()
        {
            InitializeComponent();
            this.Owner = Application.Current.MainWindow;

            WindowState = WindowState.Maximized; // 모니터의 해상도 크기로 변경
            ResizeMode = ResizeMode.NoResize; // Window의 크기를 변경 불가
            this.Loaded += new RoutedEventHandler(Window_Loaded);

            ////DisplayValue();
            string value = "";
            Util.GetPrivateProfileValue("FONTLIST", "NAME", "7X12|11X16|5X7|OCR|HMC5", ref value, Constants.FONT_INI_FILE);
            string[] vals = value.Split('|');
            for (int i = 0; i < vals.Length; i++)
            {
                if (vals[i].Length > 0)
                    cbxFontName.Items.Add(vals[i]);
            }

            List<string> names = new List<string>();
            string patternfile = AppDomain.CurrentDomain.BaseDirectory + Constants.PATTERN_PATH;
            names = DirFileSearch(patternfile, "*.ini").Result;
            for (int i = 0; i < names.Count; i++)
                cbxPatternList.Items.Add(names[i]);
            if (names.Count > 0)
            {
                //DisplayValue(names[0]);
                cbxPatternList.SelectedIndex = 0;
            }

            Util.GetPrivateProfileValue("OPTION", "XYDIRECTION", "0", ref value, Constants.PARAMS_INI_FILE);
            if (value == "0")
            {
                jogDirection0.Visibility = Visibility.Visible;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Collapsed;
            }
            else if (value == "1")
            {
                jogDirection0.Visibility = Visibility.Collapsed;
                jogDirection1.Visibility = Visibility.Visible;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Collapsed;
            }
            else if (value == "2")
            {
                jogDirection0.Visibility = Visibility.Collapsed;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Visible;
                jogDirection3.Visibility = Visibility.Collapsed;
            }
            else if (value == "3")
            {
                jogDirection0.Visibility = Visibility.Collapsed;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Visible;
            }
            else
            {
                jogDirection0.Visibility = Visibility.Visible;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Collapsed;
            }

            Util.GetPrivateProfileValue("OPTION", "CARIMAGEDIRECTION", "0", ref value, Constants.PARAMS_INI_FILE);
            if (value != "0")
            {
                imgBody0.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
                imgBody1.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
                imgBody2.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
                imgBody3.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
            }
            else
            {
                imgBody0.Source = Util.GetImageSource("./Images/Body.jpg");
                imgBody1.Source = Util.GetImageSource("./Images/Body.jpg");
                imgBody2.Source = Util.GetImageSource("./Images/Body.jpg");
                imgBody3.Source = Util.GetImageSource("./Images/Body.jpg");
            }

            cbxPlateMode.Items.Add("0");
            cbxPlateMode.Items.Add("1");
            cbxPlateMode.Items.Add("3");
            cbxPlateMode.Items.Add("5");
            cbxPlateMode.Items.Add("7");

            ShowColorMapSample();
            ((MainWindow)System.Windows.Application.Current.MainWindow).currentWindow = 2;

            statusTimer.Tick += statusTimerHandler;
            statusTimer.Interval = TimeSpan.FromMilliseconds(1000);
            statusTimer.Start();
            //mesRunningTimer.Interval = TimeSpan.FromSeconds(10);
            //statusTimer.IsEnabled = false;
            //cycleTimer.Stop();

			ckbStopMark.Visibility = Visibility.Collapsed;
            ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.LaserControllerStatusEventFunc += OnLaserControllerStatusChangedEventReceivedFunc;
            ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.markCommLaser.MarkControllerDataArrivedEventFunc += OnMarkControllerEventFunc;
            ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.LPMControllerDataReceivedEventFunc += OnLPMControllerEventFunc;
            //((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.markComm.MarkControllerDataArrivedEventFunc += OnMarkControllerEventFunc;

            lsbResult.ItemsSource = SetControllerLogEntries;
        }

        public SetControllerWindow3(string pattern, string vin)
        {
            string value = "";
            InitializeComponent();

            this.Owner = Application.Current.MainWindow;

            WindowState = WindowState.Maximized; // 모니터의 해상도 크기로 변경
            ResizeMode = ResizeMode.NoResize; // Window의 크기를 변경 불가
            this.Loaded += new RoutedEventHandler(Window_Loaded);

            //DisplayValue();
            Util.GetPrivateProfileValue("FONTLIST", "NAME", "7X12|11X16|5X7|OCR|HMC5", ref value, Constants.FONT_INI_FILE);
            string[] vals = value.Split('|');
            for (int i = 0; i < vals.Length; i++)
            {
                if (vals[i].Length > 0)
                    cbxFontName.Items.Add(vals[i]);
            }

            List<string> patternnames = new List<string>();
            string patternfile = AppDomain.CurrentDomain.BaseDirectory + Constants.PATTERN_PATH;
            patternnames = DirFileSearch(patternfile, "*.ini").Result;
            for (int i = 0; i < patternnames.Count; i++)
                cbxPatternList.Items.Add(patternnames[i]);
            if (patternnames.Count > 0)
            {
                //DisplayValue(names[0]);
                if (patternnames.Contains(pattern))
                    cbxPatternList.SelectedItem = pattern;
                else
                    cbxPatternList.SelectedIndex = 0;
            }

            txtVIN.Text = vin;

            Util.GetPrivateProfileValue("OPTION", "XYDIRECTION", "0", ref value, Constants.PARAMS_INI_FILE);
            if (value == "0")
            {
                jogDirection0.Visibility = Visibility.Visible;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Collapsed;
            }
            else if (value == "1")
            {
                jogDirection0.Visibility = Visibility.Collapsed;
                jogDirection1.Visibility = Visibility.Visible;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Collapsed;
            }
            else if (value == "2")
            {
                jogDirection0.Visibility = Visibility.Collapsed;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Visible;
                jogDirection3.Visibility = Visibility.Collapsed;
            }
            else if (value == "3")
            {
                jogDirection0.Visibility = Visibility.Collapsed;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Visible;
            }
            else
            {
                jogDirection0.Visibility = Visibility.Visible;
                jogDirection1.Visibility = Visibility.Collapsed;
                jogDirection2.Visibility = Visibility.Collapsed;
                jogDirection3.Visibility = Visibility.Collapsed;
            }

            Util.GetPrivateProfileValue("OPTION", "CARIMAGEDIRECTION", "0", ref value, Constants.PARAMS_INI_FILE);
            if (value != "0")
            {
                imgBody0.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
                imgBody1.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
                imgBody2.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
                imgBody3.Source = Util.GetImageSource("./Images/BodyReverse.jpg");
            }
            else
            {
                imgBody0.Source = Util.GetImageSource("./Images/Body.jpg");
                imgBody1.Source = Util.GetImageSource("./Images/Body.jpg");
                imgBody2.Source = Util.GetImageSource("./Images/Body.jpg");
                imgBody3.Source = Util.GetImageSource("./Images/Body.jpg");
            }

            Util.GetPrivateProfileValue("CONFIG", "USELINK", "0", ref value, Constants.SCANNER_INI_FILE);
            if (value == "0")
            {
                btnGetLinkStatus.Visibility = Visibility.Collapsed;
                btnVisionLinkPoint.Visibility = Visibility.Collapsed;
                btnSetLinkOn.Visibility = Visibility.Collapsed;
                btnSetLinkOff.Visibility = Visibility.Collapsed;
                btnVisionStartPoint.Visibility = Visibility.Collapsed;
                btnVisionReady.Visibility = Visibility.Collapsed;
                btnVisionStartScan2.Visibility = Visibility.Collapsed;
                btnVisionFinish.Visibility = Visibility.Collapsed;
                btnVisionStartScan.Visibility = Visibility.Collapsed;
                ckbReverseScan.Visibility = Visibility.Collapsed;
                stpVisionSetting.Visibility = Visibility.Collapsed;
                stpVisionSpeed.Visibility = Visibility.Collapsed;
            }

            cbxPlateMode.Items.Add("0");
            cbxPlateMode.Items.Add("1");
            cbxPlateMode.Items.Add("3");
            cbxPlateMode.Items.Add("5");
            cbxPlateMode.Items.Add("7");

            byte byLPMUse = 0;
            Util.GetPrivateProfileValue("OPTION", "USELPM", "0", ref value, Constants.LENZ_INI_FILE);
            byte.TryParse(value, out byLPMUse);
            if(byLPMUse != 0)
            {
                lblreadlPowerTitle.Visibility = Visibility.Visible;
                lblreadlPowerValue.Visibility = Visibility.Visible;
                lblreadlPowerWatt.Visibility = Visibility.Visible;
            }
            else
            {
                lblreadlPowerTitle.Visibility = Visibility.Hidden;
                lblreadlPowerValue.Visibility = Visibility.Hidden;
                lblreadlPowerWatt.Visibility = Visibility.Hidden;
            }
            //lblfwVersion.Content = ((MainWindow)System.Windows.Application.Current.MainWindow).fwVersion;
            ShowColorMapSample();
            ((MainWindow)System.Windows.Application.Current.MainWindow).currentWindow = 2;

            statusTimer.Tick += statusTimerHandler;
            statusTimer.Interval = TimeSpan.FromMilliseconds(1000);
            statusTimer.Start();
			ckbStopMark.Visibility = Visibility.Collapsed;
            ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.LaserControllerStatusEventFunc += OnLaserControllerStatusChangedEventReceivedFunc;
            ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.markCommLaser.MarkControllerDataArrivedEventFunc += OnMarkControllerEventFunc;
            if(byLPMUse != 0)
                ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.LPMControllerDataReceivedEventFunc += OnLPMControllerEventFunc;
            lsbResult.ItemsSource = SetControllerLogEntries;
        }


        private async void statusTimerHandler(object sender, EventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "statusTimerHandler";
            //TimeSpan ts = TimeSpan.FromMilliseconds(10);
            distanceSensorData sensorData = new distanceSensorData();

            try
            {
                sensorData = await ((MainWindow)System.Windows.Application.Current.MainWindow).ReadDisplacementSensor(1, 1);
                if (sensorData.execResult != 0)
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "ReadDisplacementSensor : ERROR = " + sensorData.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                //string timer = string.Format("{0:mm\\:ss\\:f}", cycleWatch.Elapsed); ;// cycleWatch.ElapsedMilliseconds.ToString("");
                //ShowLabelData(timer, lblcycleTime);

                ShowLabelData(lblDisplacementVal1, sensorData.rawdistance.ToString("F4"));
                ShowLabelData(lblDisplacementVal2, sensorData.sensoroffset.ToString("F4"));
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowColorMapSample()
        {
            byte[] data = new byte[1024];
            //TemperatureLabel.Content = "(\u00b0C) Temperature";

            // TM SHIN
            const int Pallete_WIDTH = 35;
            const int Pallete_HEIGHT = 110;

            byte[,,] pixelArrayP = new byte[Pallete_HEIGHT, Pallete_WIDTH, 4];
            for (int y = 0; y < Pallete_HEIGHT; y++)
            {
                for (int x = 0; x < Pallete_WIDTH; x++)
                {
                    if ((y == 0) || (y == (Pallete_HEIGHT - 1)))
                    {
                        pixelArrayP[y, x, 0] = pixelArrayP[y, x, 1] = pixelArrayP[y, x, 2] = pixelArrayP[y, x, 3] = 255;
                    }
                    else
                    {
                        if ((x == 0) || (x == (Pallete_WIDTH - 1)))
                        {
                            pixelArrayP[y, x, 0] = pixelArrayP[y, x, 1] = pixelArrayP[y, x, 2] = pixelArrayP[y, x, 3] = 255;
                        }
                        else
                        {
                            var rgb = GetColorMap((byte)((255.0 * (double)(Pallete_HEIGHT - y) / (double)Pallete_HEIGHT)), false);
                            if ((y == 10 || y == 53 || y == 97) && (x < Pallete_WIDTH / 2))
                            {
                                pixelArrayP[y, x, 0] = (byte)((byte)255 - rgb.Item3);
                                pixelArrayP[y, x, 1] = (byte)((byte)255 - rgb.Item2);
                                pixelArrayP[y, x, 2] = (byte)((byte)255 - rgb.Item1);
                                pixelArrayP[y, x, 3] = 255;
                            }
                            else
                            {
                                pixelArrayP[y, x, 0] = rgb.Item3;
                                pixelArrayP[y, x, 1] = rgb.Item2;
                                pixelArrayP[y, x, 2] = rgb.Item1;
                                pixelArrayP[y, x, 3] = 255;
                            }
                        }
                    }
                }
            }

            byte[] byteArrayP = new byte[Pallete_HEIGHT * Pallete_WIDTH * 4];
            int index = 0;
            for (int row = 0; row < Pallete_HEIGHT; row++)
            {
                for (int col = 0; col < Pallete_WIDTH; col++)
                {
                    for (int i = 0; i < 4; i++)
                    {
                        byteArrayP[index++] = pixelArrayP[row, col, i];
                    }
                }
            }

            WriteableBitmap PallteBitmap = new WriteableBitmap
            (
                Pallete_WIDTH,
                Pallete_HEIGHT,
                96,
                96,
                PixelFormats.Bgra32,
                null
            );

            Int32Rect rectangleP = new Int32Rect(0, 0, Pallete_WIDTH, Pallete_HEIGHT);
            int strideP = 4 * Pallete_WIDTH;
            PallteBitmap.WritePixels(rectangleP, byteArrayP, strideP, 0);

            Image imageP = new Image();
            imageP.Stretch = Stretch.None;
            imageP.Margin = new Thickness(0);

            GridPallete.Children.Add(imageP);
            imageP.Source = PallteBitmap;
        }

        private void ChangeSize(double width, double height)
        {
            try
            {
                scale.ScaleX = width / orginalWidth;
                scale.ScaleY = height / originalHeight;
                FrameworkElement rootElement = this.Content as FrameworkElement;
                rootElement.LayoutTransform = scale;
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
            }
        }

        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            //string value = "";
            //byte bHeadType = 0;
            byte byLPMUse = 0;
            string value = "";

            try
            {
                statusTimer.Stop();

                //Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                //byte.TryParse(value, out bHeadType);

                ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.LaserControllerStatusEventFunc -= OnLaserControllerStatusChangedEventReceivedFunc;
                ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.markCommLaser.MarkControllerDataArrivedEventFunc -= OnMarkControllerEventFunc;
                Util.GetPrivateProfileValue("OPTION", "USELPM", "0", ref value, Constants.LENZ_INI_FILE);
                byte.TryParse(value, out byLPMUse);
                if (byLPMUse != 0)
                    ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.LPMControllerDataReceivedEventFunc -= OnLPMControllerEventFunc;

            }
            catch (Exception ex)
            {

            }
        }

        private void Window_Closed(object sender, EventArgs e)
        {

        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            if (this.WindowState == WindowState.Maximized)
            {
                ChangeSize(this.ActualWidth, this.ActualHeight);
            }
            this.SizeChanged += new SizeChangedEventHandler(Window_SizeChanged);
        }

        private void btnExit_Click(object sender, RoutedEventArgs e)
        {
            //DialogResult = true;
            if(AgingStop.IsChecked == false)
            {
                AgingStop.IsChecked = true;
                Thread.Sleep(100);
            }
            Close();
        }

        private void Window_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            orginalWidth = this.Width;
            originalHeight = this.Height;
            ChangeSize(e.NewSize.Width, e.NewSize.Height);
        }

        private async void OnLPMControllerEventFunc(object sender, LPMControllerRecievedEvnetArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "OnLPMControllerEventFunc";
            string value = "";
            ITNTResponseArgs recvarg = new ITNTResponseArgs();
            //double power = 0;
            double slope = 0;
            double intercept = 0;
            //string s_peakPower = "";
            //double d_peakPower = 0;

            ITNTTraceLog.Instance.Trace(1, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

            try
            {
                if (e.execmd == 'M')
                {
                    //power = ((double)e.value / 100.0);

                    Util.GetPrivateProfileValue("LENZ", "SLOPE", "0.1", ref value, Constants.LENZ_INI_FILE);
                    double.TryParse(value, out slope);

                    Util.GetPrivateProfileValue("LENZ", "INTER", "0.0", ref value, Constants.LENZ_INI_FILE);
                    double.TryParse(value, out intercept);

                    //double x = (double)(slope * power) + (double)intercept;     // ADC => %
                    //double w = 68.24 * x - 181.1;                               // %   => watt
                    //s_peakPower = GetTextBoxData(PeakPowerTxt);
                    //double.TryParse(s_peakPower, out d_peakPower);
                    //if (d_peakPower > 0)
                    //{
                    //    var x = slope * (double)e.value + intercept + d_peakPower * 0.98;     // ADC => %
                    //    ShowLabelData(x.ToString("F0"), lblreadlPowerValue);
                    //}

                    var x1 = slope * (double)e.value + intercept + iLaserPeakPower * 0.98;     // ADC => %
                    var x2 = slope * (double)e.value + intercept + iLaserPeakPower * 0.99;     // ADC => %
                    var x3 = iLaserPeakPower * 0.99;
                    //if (d_peakPower > 0)
                    if ((x1 > iLaserPeakPower * 0.98) && (x1 < iLaserPeakPower))
                        ShowLabelData(x1.ToString("F0"), lblreadlPowerValue);
                    else if ((x2 > iLaserPeakPower * 0.98) && (x2 < iLaserPeakPower))
                        ShowLabelData(x2.ToString("F0"), lblreadlPowerValue);
                    else
                        ShowLabelData(x3.ToString("F0"), lblreadlPowerValue);

                    //ShowLabelData(w.ToString("F2"), lblreadlPowerValue);
                }
                else if (e.execmd == 'Z')
                {
                    ShowLabelData("Ready", lblreadlPowerValue);
                }

                ITNTTraceLog.Instance.Trace(1, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        //private async void OnLaserMarkControllerEventFunc(object sender, MarkControllerRecievedEvnetArgs e)
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "OnLaserMarkControllerEventFunc";
        //    string param1 = "";
        //    string param2 = "";
        //    string param3 = "";
        //    string param4 = "";
        //    int iparam1 = 0, iparam2 = 0, iparam3 = 0, iparam4 = 0;
        //    int i = 0;
        //    int chindex = 0;
        //    int ptindex = 0;
        //    //byte[] sensor = new byte[8];
        //    int retval = 0;
        //    DataRowView row = null;
        //    string value = "";
        //    ITNTResponseArgs recvarg = new ITNTResponseArgs();
        //    byte currCMD = 0;
        //    string log = "";

        //    try
        //    {
        //        ITNTTraceLog.Instance.Trace(1, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

        //        i = 6;
        //        if (e.receiveSize >= i + 4)
        //        {
        //            param1 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
        //            iparam1 = Convert.ToInt32(param1, 16);
        //        }
        //        if (e.receiveSize >= i + 4)
        //        {
        //            param2 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
        //            iparam2 = Convert.ToInt32(param2, 16);
        //        }
        //        if (e.receiveSize >= i + 4)
        //        {
        //            param3 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
        //            iparam3 = Convert.ToInt32(param3, 16);
        //            //param3Flag = true;
        //        }
        //        if (e.receiveSize >= i + 4)
        //        {
        //            param4 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
        //            iparam4 = Convert.ToInt32(param4, 16);
        //            //param4Flag = true;
        //        }

        //        currCMD = e.execmd;

        //        switch (e.stscmd)
        //        {
        //            case 0x30:      //stand by
        //                ITNTTraceLog.Instance.TraceHex(1, className + "::" + funcName + "()  RECV MARK :  ", e.receiveSize, e.receiveBuffer);
        //                chindex = (iparam4 >> 8);
        //                ptindex = iparam4 & 0xff;

        //                if (chindex == (byte)'J')
        //                {
        //                    chindex = 0;
        //                }

        //                //if ((currCMD == 'R') || (currCMD == '@'))
        //                if (((currCMD == 'R') && (m_currCMD == 'R')) || ((currCMD == '@') && (m_currCMD == '@')))
        //                {
        //                    //if (!m_bDoingMarkingFlag)
        //                    //    m_bDoingMarkingFlag = true;

        //                    if (this.CheckAccess())
        //                        ShowMarkingOneLine(chindex, ptindex);//, Density232);
        //                    //ShowLaserMarkingOneLine(chindex, ptindex);
        //                    else
        //                    {
        //                        this.Dispatcher.Invoke(new Action(delegate
        //                        {
        //                            ShowMarkingOneLine(chindex, ptindex);//, Density232);
        //                            //ShowLaserMarkingOneLine(chindex, ptindex);
        //                        }));
        //                    }
        //                }
        //                //Task.Delay(100);
        //                break;

        //            case 0x31:      //running
        //                if (((m_currCMD == (byte)'@') && (currCMD == (byte)'@')) ||
        //                    ((m_currCMD == (byte)'H') && (currCMD == (byte)'H')) ||
        //                    ((m_currCMD == (byte)'J') && (currCMD == (byte)'J')) ||
        //                    ((m_currCMD == (byte)'M') && (currCMD == (byte)'M')) ||
        //                    ((m_currCMD == (byte)'K') && (currCMD == (byte)'K')))
        //                {

        //                    //tmpstring = string.Format("{0:0.00}", (double)iparam1 / 100.0);
        //                    //ShowTextBoxData(txtCurrentPosX, tmpstring);
        //                    //tmpstring = string.Format("{0:0.00}", (double)iparam2 / 100.0);
        //                    //ShowTextBoxData(txtCurrentPosY, tmpstring);
        //                    //tmpstring = string.Format("{0:0.00}", (double)iparam3 / 100.0);
        //                    //ShowTextBoxData(txtCurrentPosZ, tmpstring);

        //                    //ShowLabelData(lblInputPort, iparam4.ToString("X4"));

        //                    //ControlWindow.Dispatcher.Invoke(new Action(delegate
        //                    //{
        //                    //    ControlWindow.TXT_CURRENT_X.Text = string.Format("{0:0.00}", (double)xpos / 100.0);
        //                    //    ControlWindow.TXT_CURRENT_Y.Text = string.Format("{0:0.00}", (double)ypos / 100.0);
        //                    //    ControlWindow.TXT_CURRENT_Z.Text = string.Format("{0:0.00}", (double)zpos / 100.0);

        //                    //    ControlWindow.XY_AXIS_HOME.Background = (((short)xpos == Mode_File.OFFSET_X) && ((short)ypos == Mode_File.OFFSET_Y)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
        //                    //    ControlWindow.Z_AXIS_HOME.Background = ((short)zpos == Mode_File.OFFSET_Z) ? Brushes.LightGreen : Brushes.AntiqueWhite;
        //                    //    ControlWindow.X_AXIS_ALARM.Background = ((port & 0x01) == 0) ? Brushes.AntiqueWhite : Brushes.Red;
        //                    //    ControlWindow.Y_AXIS_ALARM.Background = ((port & 0x02) == 0) ? Brushes.AntiqueWhite : Brushes.Red;
        //                    //    ControlWindow.Z_AXIS_ALARM.Background = ((port & 0x04) == 0) ? Brushes.AntiqueWhite : Brushes.Red;
        //                    //    ControlWindow.InputTxt.Text = port.ToString("X4");


        //                    //}));


        //                    //tmpstring = string.Format("{0:0.00}", (double)iparam1 / 100.0);
        //                    //ShowTextBoxData(txtCurrentPosX, tmpstring);
        //                    //tmpstring = string.Format("{0:0.00}", (double)iparam2 / 100.0);
        //                    //ShowTextBoxData(txtCurrentPosY, tmpstring);
        //                    //tmpstring = string.Format("{0:0.00}", (double)iparam3 / 100.0);
        //                    //ShowTextBoxData(txtCurrentPosZ, tmpstring);

        //                    //ShowLabelData(lblInputPort, iparam4.ToString("X4"));
        //                }
        //                break;

        //            case 0x32:      //run ok
        //                break;

        //            //case 0x33:      //home ok
        //            //    break;
        //            //case 0x34:      //jog ok
        //            //    break;
        //            //case 0x35:      //test ok
        //            //    break;
        //            //case 0x36:      //go ok
        //            //    break;
        //            case 0x37:      //cold boot
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "COLD BOOT", Thread.CurrentThread.ManagedThreadId);

        //                //Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref headType, Constants.PARAMS_INI_FILE);
        //                //bControllerInitFlag = 0;

        //                //if (bHeadType == 0)
        //                //    retval = InitializeController().Result.execResult;
        //                //else
        //                //    retval = InitializeControllerLaser().Result.execResult;

        //                ////retval = InitializeController().Result.execResult;
        //                //if (retval == 0)
        //                //{
        //                //    doingCommand = true;
        //                //    Stopwatch sw = new Stopwatch();
        //                //    sw.Start();
        //                //    while (sw.Elapsed < TimeSpan.FromSeconds(6))
        //                //    {
        //                //        if (!doingCommand)
        //                //            break;

        //                //        await Task.Delay(50);
        //                //    }
        //                //    bControllerInitFlag = 1;
        //                //}
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "COLD BOOT END", Thread.CurrentThread.ManagedThreadId);
        //                break;

        //            case 0x38:
        //                //count = 0;
        //                double dvalue = 0.0d;
        //                double.TryParse(param1, out dvalue);
        //                //currentPoint.X = dvalue;
        //                double.TryParse(param1, out dvalue);
        //                //currentPoint.Y = dvalue;

        //                //doingCommand = false;
        //                if ((currCMD == 'U') && (m_currCMD == 'U'))
        //                {
        //                    //ITNTJobLog.Instance.Trace(0, "[4] : RECEIVE SCAN COMPLETE");
        //                    Util.GetPrivateProfileValue("OPTION", "VISIONQUICKEND", "0", ref value, Constants.PARAMS_INI_FILE);
        //                    if (value != "0")
        //                        recvarg = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendScanComplete(1);
        //                }
        //                break;

        //            case (byte)ASCII.ACK:
        //                if ((currCMD == '@') && (m_currCMD == '@'))
        //                {
        //                    string m_font = "";

        //                    //if (currMarkInfo.senddata.SendDataIndex < currMarkInfo.senddata.SendDataCount)
        //                    //{
        //                    //    m_font = (currMarkInfo.senddata.CleanFireFlag == false) ? currMarkInfo.senddata.sendDataFire.ElementAt(currMarkInfo.senddata.SendDataIndex++) :  currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);

        //                    //    Dispatcher.Invoke(new Action(async delegate
        //                    //    {
        //                    //        recvarg = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(m_font);
        //                    //    }));

        //                    //    if (recvarg.execResult != 0)
        //                    //    {
        //                    //        return;
        //                    //    }
        //                    //}
        //                    //else
        //                    //{
        //                    //    //S_TIME = DateTime.Now;
        //                    //    //ControlWindow.Dispatcher.Invoke(new Action(delegate
        //                    //    //{
        //                    //    //    if (BatchJobStop) { ControlWindow.Batch_Start.IsEnabled = true; }
        //                    //    //    ControlWindow.lB_Marking_count.Text = "Marking Count: " + Mark_Counter;
        //                    //    //    ControlWindow.txt_log.AppendText(DateAndTime.Now + " Mark Sequence Complete (" + Mark_Counter + ")" + Environment.NewLine);
        //                    //    //    ControlWindow.txt_log.ScrollToEnd();
        //                    //    //    ControlWindow.cycle_time.Content = " CYCLE TIME:  " + (S_TIME - W_TIME).Minutes + "분: " + (S_TIME - W_TIME).Seconds + "초: " + (S_TIME - W_TIME).Milliseconds;
        //                    //    //}));

        //                    //    //Mode_File.EndOfSend = true;
        //                    //}
        //                }
        //                break;
        //            case 0x39:      //emergency
        //                break;

        //            default:
        //                break;
        //        }

        //        ITNTTraceLog.Instance.Trace(1, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
        //    }
        //    catch (Exception ex)
        //    {
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //    }
        //}

        private async void OnMarkControllerEventFunc(object sender, MarkControllerRecievedEvnetArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "OnMarkControllerEventFunc";
            string param1 = "";
            string param2 = "";
            string param3 = "";
            string param4 = "";
            int i = 0;
            int chindex = 0;
            int ptindex = 0;
            byte currCMD = 0;
            int iparam1 = 0, iparam2 = 0, iparam3 = 0, iparam4 = 0;
            string tmpstring = "";
            ITNTResponseArgs retval = new ITNTResponseArgs();
            Brush backbrushXY = null;
            Brush backbrushZ = null;
            //int pos1 = 0;
            //int pos2 = 0;
            //int pos3 = 0;
            PatternValueEx pattern = new PatternValueEx();

            try
            {
                Task task = Task.Run(() => OnMarkControllerEventTask(sender, e));
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void OnMarkControllerEventTask(object sender, MarkControllerRecievedEvnetArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "OnMarkControllerEventFunc";
            string param1 = "";
            string param2 = "";
            string param3 = "";
            string param4 = "";
            int i = 0;
            int chindex = 0;
            int ptindex = 0;
            byte currCMD = 0;
            int iparam1 = 0, iparam2 = 0, iparam3 = 0, iparam4 = 0;
            string tmpstring = "";
            ITNTResponseArgs retval = new ITNTResponseArgs();
            Brush backbrushXY = null;
            Brush backbrushZ = null;
            //int pos1 = 0;
            //int pos2 = 0;
            //int pos3 = 0;
            PatternValueEx pattern = new PatternValueEx();
            int basesize = 0;

            try
            {
                //if (((MainWindow)System.Windows.Application.Current.MainWindow).currentWindow != 2)
                //    return;
                i = 6;
                basesize = 10;
                if (e.receiveSize >= basesize)
                {
                    param1 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
                    try
                    {
                        iparam1 = Convert.ToInt32(param1, 16);
                    }
                    catch (Exception ex)
                    {
                        int.TryParse(param1, System.Globalization.NumberStyles.HexNumber, null, out iparam1);
                    }
                }
                if (e.receiveSize >= basesize + 4)
                {
                    param2 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
                    try
                    {
                        iparam2 = Convert.ToInt32(param2, 16);
                    }
                    catch (Exception ex)
                    {
                        int.TryParse(param2, System.Globalization.NumberStyles.HexNumber, null, out iparam2);
                    }
                }
                if (e.receiveSize >= basesize + 8)
                {
                    param3 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
                    try
                    {
                        iparam3 = Convert.ToInt32(param3, 16);
                    }
                    catch (Exception ex)
                    {
                        int.TryParse(param3, System.Globalization.NumberStyles.HexNumber, null, out iparam3);
                    }
                    //param3Flag = true;
                }
                if (e.receiveSize >= basesize + 12)
                {
                    param4 = Encoding.UTF8.GetString(e.receiveBuffer, i, 4); i += 4;
                    try
                    {
                        iparam4 = Convert.ToInt32(param4, 16);
                    }
                    catch (Exception ex)
                    {
                        int.TryParse(param4, System.Globalization.NumberStyles.HexNumber, null, out iparam4);
                    }
                    //param4Flag = true;
                }
                currCMD = e.execmd;


                switch (currCMD)
                {
                    case (byte)'R':
                    case (byte)'r':
                    case (byte)'H':
                    case (byte)'J':
                    case (byte)'C':
                    case (byte)'M':
                    case (byte)'K':         // 
                    case (byte)'h':         // Return
                    case (byte)'k':         // Return Job End : 08
                    case (byte)'@':         // Return without Job end   // TM SHIN 3/16
                        switch (e.stscmd)
                        {
                            case (byte)'0': // DONE POINT 
                                chindex = (iparam4 >> 8);
                                ptindex = iparam4 & 0xff;

                                if (chindex == (byte)'J')
                                {
                                    chindex = 0;
                                }

                                if (this.CheckAccess())
                                {
                                    if (m_currCMD == (byte)'@')
                                    {
                                        if (currMarkInfo.senddata.CleanFireFlag == true && currMarkInfo.checkdata.TwoLineDisplay == true)
                                            ShowMarkingOneLine(chindex, ptindex - 1);//, Mode_File.Density232);
                                        ShowMarkingOneLine(chindex, ptindex);//, Density232);
                                    }
                                }
                                else
                                {
                                    this.Dispatcher.Invoke(new Action(delegate
                                    {
                                        if (m_currCMD == (byte)'@')
                                        {

                                            if (currMarkInfo.senddata.CleanFireFlag == true && currMarkInfo.checkdata.TwoLineDisplay == true)
                                                ShowMarkingOneLine(chindex, ptindex - 1);//, Mode_File.Density232);

                                            ShowMarkingOneLine(chindex, ptindex);//, Density232);
                                        }
                                    }));
                                }

                                tmpstring = string.Format("{0:0.00}", (double)iparam1 / 100.0);
                                ShowTextBoxData(txtCurrentPosX, tmpstring);
                                tmpstring = string.Format("{0:0.00}", (double)iparam2 / 100.0);
                                ShowTextBoxData(txtCurrentPosY, tmpstring);
                                tmpstring = string.Format("{0:0.00}", (double)iparam3 / 100.0);
                                ShowTextBoxData(txtCurrentPosZ, tmpstring);

                                backbrushXY = (((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == (int)(iparam1 / 100)) && ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == (int)(iparam2 / 100))) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                ShowLabelColor(lblMotorHomeXY, null, backbrushXY);

                                backbrushZ = ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == (int)(iparam3 / 100)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                ShowLabelColor(lblMotorHomeZ, null, backbrushZ);

                                //Brush backAlaramX0 = ((iparam4 & 0x01) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramX, null, backAlaramX0);
                                //Brush backAlaramY0 = ((iparam4 & 0x02) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramY0);
                                //Brush backAlaramZ0 = ((iparam4 & 0x04) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZ0);

                                break;

                            case (byte)'1': // RUNNING
                                if (((m_currCMD == (byte)'@') && (currCMD == (byte)'@')) ||
                                    ((m_currCMD == (byte)'H') && (currCMD == (byte)'H')) ||
                                    ((m_currCMD == (byte)'J') && (currCMD == (byte)'J')) ||
                                    ((m_currCMD == (byte)'M') && (currCMD == (byte)'M')) ||
                                    ((m_currCMD == (byte)'K') && (currCMD == (byte)'K')))
                                {
                                    tmpstring = string.Format("{0:0.00}", (double)iparam1 / 100.0);
                                    ShowTextBoxData(txtCurrentPosX, tmpstring);
                                    tmpstring = string.Format("{0:0.00}", (double)iparam2 / 100.0);
                                    ShowTextBoxData(txtCurrentPosY, tmpstring);
                                    tmpstring = string.Format("{0:0.00}", (double)iparam3 / 100.0);
                                    ShowTextBoxData(txtCurrentPosZ, tmpstring);

                                    ShowLabelData(lblInputPort, iparam4.ToString("X4"));

                                    //Brush backbrushXY1 = ((currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == iparam1) && (currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == iparam2)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                    Brush backbrushXY1 = (((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == (int)(iparam1 / 100)) && ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == (int)(iparam2 / 100))) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                    ShowLabelColor(lblMotorHomeXY, null, backbrushXY1);

                                    //Brush backbrushZ1 = (currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == iparam3) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                    Brush backbrushZ1 = ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == (int)(iparam3 / 100)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                    ShowLabelColor(lblMotorHomeZ, null, backbrushZ1);

                                    Brush backAlaramX1;
                                    Brush backAlaramY1;
                                    Brush backAlaramZ1;
                                    Brush backJogLeft0;
                                    Brush backJogRight0;
                                    Brush backJogDown0;
                                    Brush backJogUp0;

                                    Brush backJogLeft1;
                                    Brush backJogRight1;
                                    Brush backJogDown1;
                                    Brush backJogUp1;

                                    Brush backJogLeft2;
                                    Brush backJogRight2;
                                    Brush backJogDown2;
                                    Brush backJogUp2;

                                    Brush backJogLeft3;
                                    Brush backJogRight3;
                                    Brush backJogDown3;
                                    Brush backJogUp3;
                                    Brush backJogDwonZ1;
                                    Brush backJogUpZ1;

                                    if ((iparam4 & 0x01) == 0)
                                        backAlaramX1 = Brushes.AntiqueWhite;
                                    else
                                    {
                                        backAlaramX1 = Brushes.Red;
                                    }
                                    ShowLabelColor(lblMotorAlramX, null, backAlaramX1);

                                    if ((iparam4 & 0x02) == 0)
                                        backAlaramY1 = Brushes.AntiqueWhite;
                                    else
                                        backAlaramY1 = Brushes.Red;
                                    ShowLabelColor(lblMotorAlramY, null, backAlaramY1);

                                    if ((iparam4 & 0x04) == 0)
                                        backAlaramZ1 = Brushes.AntiqueWhite;
                                    else backAlaramZ1 = Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZ1);


                                    if ((iparam4 & 0x08) != 0)
                                    {
                                        backJogLeft0 = Brushes.AntiqueWhite;
                                        backJogLeft1 = Brushes.AntiqueWhite;
                                        backJogLeft2 = Brushes.AntiqueWhite;
                                        backJogLeft3 = Brushes.AntiqueWhite;
                                    }
                                    else
                                    {
                                        backJogLeft0 = Brushes.Red;
                                        backJogLeft1 = Brushes.Red;
                                        backJogLeft2 = Brushes.Red;
                                        backJogLeft3 = Brushes.Red;
                                    }

                                    ShowButtonColor(btnMoveXMinus0, null, backJogLeft0);
                                    ShowButtonColor(btnMoveXMinus1, null, backJogLeft1);
                                    ShowButtonColor(btnMoveXMinus2, null, backJogLeft2);
                                    ShowButtonColor(btnMoveXMinus3, null, backJogLeft3);

                                    if ((iparam4 & 0x10) != 0)
                                    {
                                        backJogRight0 = Brushes.AntiqueWhite;
                                        backJogRight1 = Brushes.AntiqueWhite;
                                        backJogRight2 = Brushes.AntiqueWhite;
                                        backJogRight3 = Brushes.AntiqueWhite;
                                    }
                                    else
                                    {
                                        backJogRight0 = Brushes.Red;
                                        backJogRight1 = Brushes.Red;
                                        backJogRight2 = Brushes.Red;
                                        backJogRight3 = Brushes.Red;
                                    }

                                    ShowButtonColor(btnMoveXPlus0, null, backJogRight0);
                                    ShowButtonColor(btnMoveXPlus1, null, backJogRight1);
                                    ShowButtonColor(btnMoveXPlus2, null, backJogRight2);
                                    ShowButtonColor(btnMoveXPlus3, null, backJogRight3);

                                    if ((iparam4 & 0x20) != 0)
                                    {
                                        backJogDown0 = Brushes.AntiqueWhite;
                                        backJogDown1 = Brushes.AntiqueWhite;
                                        backJogDown2 = Brushes.AntiqueWhite;
                                        backJogDown3 = Brushes.AntiqueWhite;
                                    }
                                    else
                                    {
                                        backJogDown0 = Brushes.Red;
                                        backJogDown1 = Brushes.Red;
                                        backJogDown2 = Brushes.Red;
                                        backJogDown3 = Brushes.Red;
                                    }
                                    
                                    ShowButtonColor(btnMoveYMinus0, null, backJogDown0);
                                    ShowButtonColor(btnMoveYMinus1, null, backJogDown1);
                                    ShowButtonColor(btnMoveYMinus2, null, backJogDown2);
                                    ShowButtonColor(btnMoveYMinus3, null, backJogDown3);

                                    if ((iparam4 & 0x40) != 0)
                                    {
                                        backJogUp0 = Brushes.AntiqueWhite;
                                        backJogUp1 = Brushes.AntiqueWhite;
                                        backJogUp2 = Brushes.AntiqueWhite;
                                        backJogUp3 = Brushes.AntiqueWhite;
                                    }
                                    else
                                    {
                                        backJogUp0 = Brushes.Red;
                                        backJogUp1 = Brushes.Red;
                                        backJogUp2 = Brushes.Red;
                                        backJogUp3 = Brushes.Red;
                                    }
                                    ShowButtonColor(btnMoveYPlus0, null, backJogUp0);
                                    ShowButtonColor(btnMoveYPlus1, null, backJogUp1);
                                    ShowButtonColor(btnMoveYPlus2, null, backJogUp2);
                                    ShowButtonColor(btnMoveYPlus3, null, backJogUp3);


                                    if ((iparam4 & 0x80) != 0)
                                        backJogDwonZ1 = Brushes.AntiqueWhite;
                                    else
                                        backJogDwonZ1 = Brushes.Red;
                                    ShowButtonColor(btnMoveZMinus, null, backJogDwonZ1);
                                    
                                    if ((iparam4 & 0x100) != 0)
                                        backJogUpZ1 = Brushes.AntiqueWhite;
                                    else
                                        backJogUpZ1 = Brushes.Red;
                                     ShowButtonColor(btnMoveZPlus, null, backJogUpZ1);


                                    //Brush backAlaramX1 = ((iparam4 & 0x01) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramX, null, backAlaramX1);
                                    //Brush backAlaramY1 = ((iparam4 & 0x02) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramY1);
                                    //Brush backAlaramZ1 = ((iparam4 & 0x04) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZ1);

                                    //Brush backJogLeft0 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus0, null, backJogLeft0);
                                    //Brush backJogRight0 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus0, null, backJogRight0);
                                    //Brush backJogDown0 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus0, null, backJogDown0);
                                    //Brush backJogUp0 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus0, null, backJogUp0);

                                    //Brush backJogLeft1 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus1, null, backJogLeft1);
                                    //Brush backJogRight1 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus1, null, backJogRight1);
                                    //Brush backJogDown1 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus1, null, backJogDown1);
                                    //Brush backJogUp1 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus1, null, backJogUp1);

                                    //Brush backJogLeft2 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus2, null, backJogLeft2);
                                    //Brush backJogRight2 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus2, null, backJogRight2);
                                    //Brush backJogDown2 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus2, null, backJogDown2);
                                    //Brush backJogUp2 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus2, null, backJogUp2);

                                    //Brush backJogLeft3 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus3, null, backJogLeft3);
                                    //Brush backJogRight3 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus3, null, backJogRight3);
                                    //Brush backJogDown3 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus3, null, backJogDown3);
                                    //Brush backJogUp3 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus3, null, backJogUp3);

                                    //Brush backJogDwonZ1 = ((iparam4 & 0x80) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZMinus, null, backJogDwonZ1);
                                    //Brush backJogUpZ1 = ((iparam4 & 0x100) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZPlus, null, backJogUpZ1);


                                    if ((iparam4 & 0x8000) != 0)
                                    {
                                        ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "LASER ERROR!!!!");
                                        ShowButtonColor(btnLaserReset, null, Brushes.Red);
                                    }
                                    else
                                    {
                                        ShowButtonColor(btnLaserReset, null, Brushes.LightGray);
                                    }

                                    if ((iparam4 & 0x07) != 0)
                                    {
                                        ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "MOTOR ERROR!!!!");
                                    }
                                }
                                break;

                            case (byte)'8': // Action OK
                                tmpstring = string.Format("{0:0.00}", (double)iparam1 / 100.0);
                                ShowTextBoxData(txtCurrentPosX, tmpstring);
                                tmpstring = string.Format("{0:0.00}", (double)iparam2 / 100.0);
                                ShowTextBoxData(txtCurrentPosY, tmpstring);
                                tmpstring = string.Format("{0:0.00}", (double)iparam3 / 100.0);
                                ShowTextBoxData(txtCurrentPosZ, tmpstring);

                                ShowLabelData(lblInputPort, iparam4.ToString("X4"));

                                //Brush backbrushXY8 = ((currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == iparam1) && (currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == iparam2)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                Brush backbrushXY8 = (((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == (int)(iparam1 / 100)) && ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == (int)(iparam2 / 100))) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                ShowLabelColor(lblMotorHomeXY, null, backbrushXY8);

                                //Brush backbrushZ8 = (currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == iparam3) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                Brush backbrushZ8 = ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == (int)(iparam3 / 100)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                                ShowLabelColor(lblMotorHomeZ, null, backbrushZ8);

                                Brush backAlaramX8;
                                Brush backAlaramZ8;
                                Brush backAlaramY8;
                                Brush backJogLeft80;
                                Brush backJogRight80;
                                Brush backJogDown80;
                                Brush backJogUp80;

                                Brush backJogLeft81;
                                Brush backJogRight81;
                                Brush backJogDown81;
                                Brush backJogUp81;

                                Brush backJogLeft82;
                                Brush backJogRight82;
                                Brush backJogDown82;
                                Brush backJogUp82;

                                Brush backJogLeft83;
                                Brush backJogRight83;
                                Brush backJogDown83;
                                Brush backJogUp83;
                                Brush backJogDwonZ8;
                                Brush backJogUpZ8;


                                if ((iparam4 & 0x01) == 0)
                                    backAlaramX8 = Brushes.AntiqueWhite;
                                else
                                {
                                    backAlaramX8 = Brushes.Red;
                                }
                                ShowLabelColor(lblMotorAlramX, null, backAlaramX8);

                                if ((iparam4 & 0x02) == 0)
                                    backAlaramY8 = Brushes.AntiqueWhite;
                                else
                                    backAlaramY8 = Brushes.Red;
                                ShowLabelColor(lblMotorAlramY, null, backAlaramY8);

                                if ((iparam4 & 0x04) == 0)
                                    backAlaramZ8 = Brushes.AntiqueWhite;
                                else backAlaramZ8 = Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZ8);


                                if ((iparam4 & 0x08) != 0)
                                {
                                    backJogLeft80 = Brushes.AntiqueWhite;
                                    backJogLeft81 = Brushes.AntiqueWhite;
                                    backJogLeft82 = Brushes.AntiqueWhite;
                                    backJogLeft83 = Brushes.AntiqueWhite;
                                }
                                else
                                {
                                    backJogLeft80 = Brushes.Red;
                                    backJogLeft81 = Brushes.Red;
                                    backJogLeft82 = Brushes.Red;
                                    backJogLeft83 = Brushes.Red;
                                }

                                ShowButtonColor(btnMoveXMinus0, null, backJogLeft80);
                                ShowButtonColor(btnMoveXMinus1, null, backJogLeft81);
                                ShowButtonColor(btnMoveXMinus2, null, backJogLeft82);
                                ShowButtonColor(btnMoveXMinus3, null, backJogLeft83);

                                if ((iparam4 & 0x10) != 0)
                                {
                                    backJogRight80 = Brushes.AntiqueWhite;
                                    backJogRight81 = Brushes.AntiqueWhite;
                                    backJogRight82 = Brushes.AntiqueWhite;
                                    backJogRight83 = Brushes.AntiqueWhite;
                                }
                                else
                                {
                                    backJogRight80 = Brushes.Red;
                                    backJogRight81 = Brushes.Red;
                                    backJogRight82 = Brushes.Red;
                                    backJogRight83 = Brushes.Red;
                                }

                                ShowButtonColor(btnMoveXPlus0, null, backJogRight80);
                                ShowButtonColor(btnMoveXPlus1, null, backJogRight81);
                                ShowButtonColor(btnMoveXPlus2, null, backJogRight82);
                                ShowButtonColor(btnMoveXPlus3, null, backJogRight83);

                                if ((iparam4 & 0x20) != 0)
                                {
                                    backJogDown80 = Brushes.AntiqueWhite;
                                    backJogDown81 = Brushes.AntiqueWhite;
                                    backJogDown82 = Brushes.AntiqueWhite;
                                    backJogDown83 = Brushes.AntiqueWhite;
                                }
                                else
                                {
                                    backJogDown80 = Brushes.Red;
                                    backJogDown81 = Brushes.Red;
                                    backJogDown82 = Brushes.Red;
                                    backJogDown83 = Brushes.Red;
                                }

                                ShowButtonColor(btnMoveYMinus0, null, backJogDown80);
                                ShowButtonColor(btnMoveYMinus1, null, backJogDown81);
                                ShowButtonColor(btnMoveYMinus2, null, backJogDown82);
                                ShowButtonColor(btnMoveYMinus3, null, backJogDown83);

                                if ((iparam4 & 0x40) != 0)
                                {
                                    backJogUp80 = Brushes.AntiqueWhite;
                                    backJogUp81 = Brushes.AntiqueWhite;
                                    backJogUp82 = Brushes.AntiqueWhite;
                                    backJogUp83 = Brushes.AntiqueWhite;
                                }
                                else
                                {
                                    backJogUp80 = Brushes.Red;
                                    backJogUp81 = Brushes.Red;
                                    backJogUp82 = Brushes.Red;
                                    backJogUp83 = Brushes.Red;
                                }
                                ShowButtonColor(btnMoveYPlus0, null, backJogUp80);
                                ShowButtonColor(btnMoveYPlus1, null, backJogUp81);
                                ShowButtonColor(btnMoveYPlus2, null, backJogUp82);
                                ShowButtonColor(btnMoveYPlus3, null, backJogUp83);


                                if ((iparam4 & 0x80) != 0)
                                    backJogDwonZ8 = Brushes.AntiqueWhite;
                                else
                                    backJogDwonZ8 = Brushes.Red;
                                ShowButtonColor(btnMoveZMinus, null, backJogDwonZ8);

                                if ((iparam4 & 0x100) != 0)
                                    backJogUpZ8 = Brushes.AntiqueWhite;
                                else
                                    backJogUpZ8 = Brushes.Red;
                                ShowButtonColor(btnMoveZPlus, null, backJogUpZ8);

                                //if ((iparam4 & 0x01) == 0) backAlaramX8 = Brushes.AntiqueWhite;
                                //else
                                //{
                                //    backAlaramX8 = Brushes.Red;
                                //}
                                //ShowLabelColor(lblMotorAlramX, null, backAlaramX8);
                                //if ((iparam4 & 0x02) == 0) backAlaramY8 = Brushes.AntiqueWhite; else backAlaramY8 = Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramY8);
                                //if ((iparam4 & 0x04) == 0) backAlaramZ8 = Brushes.AntiqueWhite; else backAlaramZ8 = Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZ8);


                                //if ((iparam4 & 0x08) != 0) backJogLeft80 = Brushes.AntiqueWhite; else backJogLeft80 = Brushes.Red; ShowButtonColor(btnMoveXMinus0, null, backJogLeft80);
                                //if ((iparam4 & 0x10) != 0) backJogRight80 = Brushes.AntiqueWhite; else backJogRight80 = Brushes.Red; ShowButtonColor(btnMoveXPlus0, null, backJogRight80);
                                //if ((iparam4 & 0x20) != 0) backJogDown80 = Brushes.AntiqueWhite; else backJogDown80 = Brushes.Red; ShowButtonColor(btnMoveYMinus0, null, backJogDown80);
                                //if ((iparam4 & 0x40) != 0) backJogUp80 = Brushes.AntiqueWhite; else backJogUp80 = Brushes.Red; ShowButtonColor(btnMoveYPlus0, null, backJogUp80);


                                //if ((iparam4 & 0x08) != 0) backJogLeft81 = Brushes.AntiqueWhite; else backJogLeft81 = Brushes.Red; ShowButtonColor(btnMoveXMinus1, null, backJogLeft81);
                                //if ((iparam4 & 0x10) != 0) backJogRight81 = Brushes.AntiqueWhite; else backJogRight81 = Brushes.Red; ShowButtonColor(btnMoveXPlus1, null, backJogRight81);
                                //if ((iparam4 & 0x20) != 0) backJogDown81 = Brushes.AntiqueWhite; else backJogDown81 = Brushes.Red; ShowButtonColor(btnMoveYMinus1, null, backJogDown81);
                                //if ((iparam4 & 0x40) != 0)
                                //    backJogUp81 = Brushes.AntiqueWhite;
                                //else backJogUp81 = Brushes.Red; ShowButtonColor(btnMoveYPlus1, null, backJogUp81);

                                //if ((iparam4 & 0x08) != 0)
                                //    backJogLeft82 = Brushes.AntiqueWhite;
                                //else backJogLeft82 = Brushes.Red; ShowButtonColor(btnMoveXMinus2, null, backJogLeft82);
                                //if ((iparam4 & 0x10) != 0)
                                //    backJogRight82 = Brushes.AntiqueWhite;
                                //else backJogRight82 = Brushes.Red; ShowButtonColor(btnMoveXPlus2, null, backJogRight82);
                                //if ((iparam4 & 0x20) != 0)
                                //    backJogDown82 = Brushes.AntiqueWhite;
                                //else backJogDown82 = Brushes.Red; ShowButtonColor(btnMoveYMinus2, null, backJogDown82);
                                //if ((iparam4 & 0x40) != 0)
                                //    backJogUp82 = Brushes.AntiqueWhite;
                                //else backJogUp82 = Brushes.Red; ShowButtonColor(btnMoveYPlus2, null, backJogUp82);


                                //if ((iparam4 & 0x08) != 0)
                                //    backJogLeft83 = Brushes.AntiqueWhite;
                                //else backJogLeft83 = Brushes.Red; ShowButtonColor(btnMoveXMinus3, null, backJogLeft83);
                                //if ((iparam4 & 0x10) != 0)
                                //    backJogRight83 = Brushes.AntiqueWhite;
                                //else backJogRight83 = Brushes.Red; ShowButtonColor(btnMoveXPlus3, null, backJogRight83);
                                //if ((iparam4 & 0x20) != 0)
                                //    backJogDown83 = Brushes.AntiqueWhite;
                                //else backJogDown83 = Brushes.Red; ShowButtonColor(btnMoveYMinus3, null, backJogDown83);
                                //if ((iparam4 & 0x40) != 0)
                                //    backJogUp83 = Brushes.AntiqueWhite;
                                //else backJogUp83 = Brushes.Red; ShowButtonColor(btnMoveYPlus3, null, backJogUp83);

                                //if ((iparam4 & 0x80) != 0) backJogDwonZ8 = Brushes.AntiqueWhite; else backJogDwonZ8 = Brushes.Red; ShowButtonColor(btnMoveZMinus, null, backJogDwonZ8);
                                //if ((iparam4 & 0x100) != 0) backJogUpZ8 = Brushes.AntiqueWhite; else backJogUpZ8 = Brushes.Red; ShowButtonColor(btnMoveZPlus, null, backJogUpZ8);



                                //Brush backAlaramX8 = ((iparam4 & 0x01) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramX, null, backAlaramX8);
                                //Brush backAlaramY8 = ((iparam4 & 0x02) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramY8);
                                //Brush backAlaramZ8 = ((iparam4 & 0x04) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZ8);

                                ////Brush backJogLeft8 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus, null, backJogLeft8);
                                ////Brush backJogRight8 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus, null, backJogRight8);
                                ////Brush backJogDown8 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus, null, backJogDown8);
                                ////Brush backJogUp8 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus, null, backJogUp8);

                                //Brush backJogLeft80 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus0, null, backJogLeft80);
                                //Brush backJogRight80 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus0, null, backJogRight80);
                                //Brush backJogDown80 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus0, null, backJogDown80);
                                //Brush backJogUp80 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus0, null, backJogUp80);

                                //Brush backJogLeft81 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus1, null, backJogLeft81);
                                //Brush backJogRight81 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus1, null, backJogRight81);
                                //Brush backJogDown81 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus1, null, backJogDown81);
                                //Brush backJogUp81 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus1, null, backJogUp81);

                                //Brush backJogLeft82 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus2, null, backJogLeft82);
                                //Brush backJogRight82 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus2, null, backJogRight82);
                                //Brush backJogDown82 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus2, null, backJogDown82);
                                //Brush backJogUp82 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus2, null, backJogUp82);

                                //Brush backJogLeft83 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus3, null, backJogLeft83);
                                //Brush backJogRight83 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus3, null, backJogRight83);
                                //Brush backJogDown83 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus3, null, backJogDown83);
                                //Brush backJogUp83 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus3, null, backJogUp83);

                                //Brush backJogDwonZ8 = ((iparam4 & 0x80) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZMinus, null, backJogDwonZ8);
                                //Brush backJogUpZ8 = ((iparam4 & 0x100) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZPlus, null, backJogUpZ8);

                                if ((iparam4 & 0x8000) != 0)
                                {
                                    ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "LASER ERROR!!!!");
                                    ShowButtonColor(btnLaserReset, null, Brushes.Red);
                                }
                                else
                                {
                                    ShowButtonColor(btnLaserReset, null, Brushes.LightGray);
                                }

                                if ((iparam4 & 0x07) != 0)
                                {
                                    ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "MOTOR ERROR!!!!");
                                }

                                if ((currCMD == (byte)'R') || (currCMD == (byte)'@'))
                                {
                                    //#if MANUAL_MARK
                                    //                                    //ShowCurrentStateLabel(5);
                                    //                                    ShowCurrentStateLabelManual(4);
                                    //                                    DIOControl.DIOWriteOutportBit(DIO_OUT_LAMPYELLOW, 0);
                                    //                                    DIOControl.DIOWriteOutportBit(DIO_OUT_LAMPGREEN, 1);
                                    //#else
                                    //#endif
                                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "[4] : MARKING COMPLETE", Thread.CurrentThread.ManagedThreadId);
                                    ShowLog((byte)LOGTYPE.LOG_SUCCESS, "MARKING", "MARKING COMPLETE!!!!");
                                    m_currCMD = 0;
                                }
                                m_currCMD = 0;
                                break;

                            case (byte)ASCII.ACK:
                                if (e.receiveSize < 10)
                                    break;
                                //if ((m_currCMD == '@') && (currCMD == '@') && (currMarkInfo.currMarkData.pattern.laserValue.density == 1))
                                //{
                                //    Brush backAlaramXA;
                                //    Brush backAlaramZA;
                                //    Brush backAlaramYA;
                                //    Brush backJogLeftA0;
                                //    Brush backJogRightA0;
                                //    Brush backJogDownA0;
                                //    Brush backJogUpA0;

                                //    Brush backJogLeftA1;
                                //    Brush backJogRightA1;
                                //    Brush backJogDownA1;
                                //    Brush backJogUpA1;

                                //    Brush backJogLeftA2;
                                //    Brush backJogRightA2;
                                //    Brush backJogDownA2;
                                //    Brush backJogUpA2;

                                //    Brush backJogLeftA3;
                                //    Brush backJogRightA3;
                                //    Brush backJogDownA3;
                                //    Brush backJogUpA3;
                                //    Brush backJogDwonZA;
                                //    Brush backJogUpZA;

                                //    if ((iparam4 & 0x01) == 0)
                                //        backAlaramXA = Brushes.AntiqueWhite;
                                //    else
                                //    {
                                //        backAlaramXA = Brushes.Red;
                                //    }
                                //    ShowLabelColor(lblMotorAlramX, null, backAlaramXA);

                                //    if ((iparam4 & 0x02) == 0)
                                //        backAlaramYA = Brushes.AntiqueWhite;
                                //    else
                                //        backAlaramYA = Brushes.Red;
                                //    ShowLabelColor(lblMotorAlramY, null, backAlaramYA);

                                //    if ((iparam4 & 0x04) == 0)
                                //        backAlaramZA = Brushes.AntiqueWhite;
                                //    else backAlaramZA = Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZA);


                                //    if ((iparam4 & 0x08) != 0)
                                //    {
                                //        backJogLeftA0 = Brushes.AntiqueWhite;
                                //        backJogLeftA1 = Brushes.AntiqueWhite;
                                //        backJogLeftA2 = Brushes.AntiqueWhite;
                                //        backJogLeftA3 = Brushes.AntiqueWhite;
                                //    }
                                //    else
                                //    {
                                //        backJogLeftA0 = Brushes.Red;
                                //        backJogLeftA1 = Brushes.Red;
                                //        backJogLeftA2 = Brushes.Red;
                                //        backJogLeftA3 = Brushes.Red;
                                //    }

                                //    ShowButtonColor(btnMoveXMinus0, null, backJogLeftA0);
                                //    ShowButtonColor(btnMoveXMinus1, null, backJogLeftA1);
                                //    ShowButtonColor(btnMoveXMinus2, null, backJogLeftA2);
                                //    ShowButtonColor(btnMoveXMinus3, null, backJogLeftA3);

                                //    if ((iparam4 & 0x10) != 0)
                                //    {
                                //        backJogRightA0 = Brushes.AntiqueWhite;
                                //        backJogRightA1 = Brushes.AntiqueWhite;
                                //        backJogRightA2 = Brushes.AntiqueWhite;
                                //        backJogRightA3 = Brushes.AntiqueWhite;
                                //    }
                                //    else
                                //    {
                                //        backJogRightA0 = Brushes.Red;
                                //        backJogRightA1 = Brushes.Red;
                                //        backJogRightA2 = Brushes.Red;
                                //        backJogRightA3 = Brushes.Red;
                                //    }

                                //    ShowButtonColor(btnMoveXPlus0, null, backJogRightA0);
                                //    ShowButtonColor(btnMoveXPlus1, null, backJogRightA1);
                                //    ShowButtonColor(btnMoveXPlus2, null, backJogRightA2);
                                //    ShowButtonColor(btnMoveXPlus3, null, backJogRightA3);

                                //    if ((iparam4 & 0x20) != 0)
                                //    {
                                //        backJogDownA0 = Brushes.AntiqueWhite;
                                //        backJogDownA1 = Brushes.AntiqueWhite;
                                //        backJogDownA2 = Brushes.AntiqueWhite;
                                //        backJogDownA3 = Brushes.AntiqueWhite;
                                //    }
                                //    else
                                //    {
                                //        backJogDownA0 = Brushes.Red;
                                //        backJogDownA1 = Brushes.Red;
                                //        backJogDownA2 = Brushes.Red;
                                //        backJogDownA3 = Brushes.Red;
                                //    }

                                //    ShowButtonColor(btnMoveYMinus0, null, backJogDownA0);
                                //    ShowButtonColor(btnMoveYMinus1, null, backJogDownA1);
                                //    ShowButtonColor(btnMoveYMinus2, null, backJogDownA2);
                                //    ShowButtonColor(btnMoveYMinus3, null, backJogDownA3);

                                //    if ((iparam4 & 0x40) != 0)
                                //    {
                                //        backJogUpA0 = Brushes.AntiqueWhite;
                                //        backJogUpA1 = Brushes.AntiqueWhite;
                                //        backJogUpA2 = Brushes.AntiqueWhite;
                                //        backJogUpA3 = Brushes.AntiqueWhite;
                                //    }
                                //    else
                                //    {
                                //        backJogUpA0 = Brushes.Red;
                                //        backJogUpA1 = Brushes.Red;
                                //        backJogUpA2 = Brushes.Red;
                                //        backJogUpA3 = Brushes.Red;
                                //    }
                                //    ShowButtonColor(btnMoveYPlus0, null, backJogUpA0);
                                //    ShowButtonColor(btnMoveYPlus1, null, backJogUpA1);
                                //    ShowButtonColor(btnMoveYPlus2, null, backJogUpA2);
                                //    ShowButtonColor(btnMoveYPlus3, null, backJogUpA3);


                                //    if ((iparam4 & 0x80) != 0)
                                //        backJogDwonZA = Brushes.AntiqueWhite;
                                //    else
                                //        backJogDwonZA = Brushes.Red;
                                //    ShowButtonColor(btnMoveZMinus, null, backJogDwonZA);

                                //    if ((iparam4 & 0x100) != 0)
                                //        backJogUpZA = Brushes.AntiqueWhite;
                                //    else
                                //        backJogUpZA = Brushes.Red;
                                //    ShowButtonColor(btnMoveZPlus, null, backJogUpZA);

                                //    //if ((iparam4 & 0x01) == 0) backAlaramXA = Brushes.AntiqueWhite; else backAlaramXA = Brushes.Red; ShowLabelColor(lblMotorAlramX, null, backAlaramXA);
                                //    //if ((iparam4 & 0x02) == 0) backAlaramYA = Brushes.AntiqueWhite; else backAlaramYA = Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramYA);
                                //    //if ((iparam4 & 0x04) == 0) backAlaramZA = Brushes.AntiqueWhite; else backAlaramZA = Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZA);


                                //    //if ((iparam4 & 0x08) != 0) backJogLeftA0 = Brushes.AntiqueWhite; else backJogLeftA0 = Brushes.Red; ShowButtonColor(btnMoveXMinus0, null, backJogLeftA0);
                                //    //if ((iparam4 & 0x10) != 0) backJogRightA0 = Brushes.AntiqueWhite; else backJogRightA0 = Brushes.Red; ShowButtonColor(btnMoveXPlus0, null, backJogRightA0);
                                //    //if ((iparam4 & 0x20) != 0) backJogDownA0 = Brushes.AntiqueWhite; else backJogDownA0 = Brushes.Red; ShowButtonColor(btnMoveYMinus0, null, backJogDownA0);
                                //    //if ((iparam4 & 0x40) != 0) backJogUpA0 = Brushes.AntiqueWhite; else backJogUpA0 = Brushes.Red; ShowButtonColor(btnMoveYPlus0, null, backJogUpA0);


                                //    //if ((iparam4 & 0x08) != 0) backJogLeftA1 = Brushes.AntiqueWhite; else backJogLeftA1 = Brushes.Red; ShowButtonColor(btnMoveXMinus1, null, backJogLeftA1);
                                //    //if ((iparam4 & 0x10) != 0) backJogRightA1 = Brushes.AntiqueWhite; else backJogRightA1 = Brushes.Red; ShowButtonColor(btnMoveXPlus1, null, backJogRightA1);
                                //    //if ((iparam4 & 0x20) != 0) backJogDownA1 = Brushes.AntiqueWhite; else backJogDownA1 = Brushes.Red; ShowButtonColor(btnMoveYMinus1, null, backJogDownA1);
                                //    //if ((iparam4 & 0x40) != 0)
                                //    //    backJogUpA1 = Brushes.AntiqueWhite;
                                //    //else backJogUpA1 = Brushes.Red; ShowButtonColor(btnMoveYPlus1, null, backJogUpA1);

                                //    //if ((iparam4 & 0x08) != 0)
                                //    //    backJogLeftA2 = Brushes.AntiqueWhite;
                                //    //else backJogLeftA2 = Brushes.Red; ShowButtonColor(btnMoveXMinus2, null, backJogLeftA2);
                                //    //if ((iparam4 & 0x10) != 0)
                                //    //    backJogRightA2 = Brushes.AntiqueWhite;
                                //    //else backJogRightA2 = Brushes.Red; ShowButtonColor(btnMoveXPlus2, null, backJogRightA2);
                                //    //if ((iparam4 & 0x20) != 0)
                                //    //    backJogDownA2 = Brushes.AntiqueWhite;
                                //    //else backJogDownA2 = Brushes.Red; ShowButtonColor(btnMoveYMinus2, null, backJogDownA2);
                                //    //if ((iparam4 & 0x40) != 0)
                                //    //    backJogUpA2 = Brushes.AntiqueWhite;
                                //    //else backJogUpA2 = Brushes.Red; ShowButtonColor(btnMoveYPlus2, null, backJogUpA2);


                                //    //if ((iparam4 & 0x08) != 0)
                                //    //    backJogLeftA3 = Brushes.AntiqueWhite;
                                //    //else backJogLeftA3 = Brushes.Red; ShowButtonColor(btnMoveXMinus3, null, backJogLeftA3);
                                //    //if ((iparam4 & 0x10) != 0)
                                //    //    backJogRightA3 = Brushes.AntiqueWhite;
                                //    //else backJogRightA3 = Brushes.Red; ShowButtonColor(btnMoveXPlus3, null, backJogRightA3);
                                //    //if ((iparam4 & 0x20) != 0)
                                //    //    backJogDownA3 = Brushes.AntiqueWhite;
                                //    //else backJogDownA3 = Brushes.Red; ShowButtonColor(btnMoveYMinus3, null, backJogDownA3);
                                //    //if ((iparam4 & 0x40) != 0)
                                //    //    backJogUpA3 = Brushes.AntiqueWhite;
                                //    //else backJogUpA3 = Brushes.Red; ShowButtonColor(btnMoveYPlus3, null, backJogUpA3);

                                //    //if ((iparam4 & 0x80) != 0) backJogDwonZA = Brushes.AntiqueWhite;
                                //    //else backJogDwonZA = Brushes.Red;
                                //    //ShowButtonColor(btnMoveZMinus, null, backJogDwonZA);
                                //    //if ((iparam4 & 0x100) != 0) backJogUpZA = Brushes.AntiqueWhite;
                                //    //else backJogUpZA = Brushes.Red;
                                //    //ShowButtonColor(btnMoveZPlus, null, backJogUpZA);



                                //    //Brush backAlaramXA = ((iparam1 & 0x01) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramX, null, backAlaramXA);
                                //    //Brush backAlaramYA = ((iparam1 & 0x02) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramYA);
                                //    //Brush backAlaramZA = ((iparam1 & 0x04) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZA);

                                //    ////Brush backJogLeftA = ((iparam1 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus, null, backJogLeftA);
                                //    ////Brush backJogRightA = ((iparam1 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus, null, backJogRightA);
                                //    ////Brush backJogDownA = ((iparam1 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus, null, backJogDownA);
                                //    ////Brush backJogUpA = ((iparam1 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus, null, backJogUpA);

                                //    //Brush backJogLeftA0 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus0, null, backJogLeftA0);
                                //    //Brush backJogRightA0 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus0, null, backJogRightA0);
                                //    //Brush backJogDownA0 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus0, null, backJogDownA0);
                                //    //Brush backJogUpA0 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus0, null, backJogUpA0);

                                //    //Brush backJogLeftA1 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus1, null, backJogLeftA1);
                                //    //Brush backJogRightA1 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus1, null, backJogRightA1);
                                //    //Brush backJogDownA1 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus1, null, backJogDownA1);
                                //    //Brush backJogUpA1 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus1, null, backJogUpA1);

                                //    //Brush backJogLeftA2 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus2, null, backJogLeftA2);
                                //    //Brush backJogRightA2 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus2, null, backJogRightA2);
                                //    //Brush backJogDownA2 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus2, null, backJogDownA2);
                                //    //Brush backJogUpA2 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus2, null, backJogUpA2);

                                //    //Brush backJogLeftA3 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus3, null, backJogLeftA3);
                                //    //Brush backJogRightA3 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus3, null, backJogRightA3);
                                //    //Brush backJogDownA3 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus3, null, backJogDownA3);
                                //    //Brush backJogUpA3 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus3, null, backJogUpA3);

                                //    //Brush backJogDwonZA = ((iparam1 & 0x80) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZMinus, null, backJogDwonZA);
                                //    //Brush backJogUpZA = ((iparam1 & 0x100) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZPlus, null, backJogUpZA);


                                //    if ((iparam1 & 0x8000) != 0)
                                //    {
                                //        ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "LASER ERROR!!!!");
                                //        ShowButtonColor(btnLaserReset, null, Brushes.Red);
                                //    }
                                //    else
                                //    {
                                //        ShowButtonColor(btnLaserReset, null, Brushes.LightGray);
                                //    }

                                //    if ((iparam1 & 0x07) != 0)
                                //    {
                                //        ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "MOTOR ERROR!!!!");
                                //    }

                                //    ShowLabelData(lblInputPort, iparam1.ToString("X4"));
                                //}
                                break;

                            default:
                                break;
                        }
                        break;
                    case (byte)'V':     // Return value : Version Number
                    case (byte)'I':     // Return value : Input Port
                    case (byte)'o':     // Return value : Output Port
                                        //byte[] retBytes = new byte[4];
                                        //Array.Copy(buffer, 3, retBytes, 0, 4);
                                        //string retstr = Encoding.Default.GetString(retBytes);
                                        //retval = int.Parse(retstr, System.Globalization.NumberStyles.HexNumber);

                        ShowLabelData(lblInputPort, iparam1.ToString("X4"));
                        //exitFlag = true;
                        break;

                    default:
                        if ((e.stscmd == (byte)ASCII.ACK) && (e.receiveSize >= 10))
                        {
                            ////Brush backbrushXYD = ((currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == iparam1) && (currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == iparam2)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                            //Brush backbrushXYD = (((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.X == (int)(iparam1 / 100)) && ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Y == (int)(iparam2 / 100))) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                            //ShowLabelColor(lblMotorHomeXY, null, backbrushXYD);

                            ////Brush backbrushZD = (currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == iparam3) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                            //Brush backbrushZD = ((int)currMarkInfo.currMarkData.pattern.headValue.home3DPos.Z == (int)(iparam1 / 100)) ? Brushes.LightGreen : Brushes.AntiqueWhite;
                            //ShowLabelColor(lblMotorHomeZ, null, backbrushZD);


                            Brush backAlaramXD;
                            Brush backAlaramZD;
                            Brush backAlaramYD;
                            Brush backJogLeftD0;
                            Brush backJogRightD0;
                            Brush backJogDownD0;
                            Brush backJogUpD0;

                            Brush backJogLeftD1;
                            Brush backJogRightD1;
                            Brush backJogDownD1;
                            Brush backJogUpD1;

                            Brush backJogLeftD2;
                            Brush backJogRightD2;
                            Brush backJogDownD2;
                            Brush backJogUpD2;

                            Brush backJogLeftD3;
                            Brush backJogRightD3;
                            Brush backJogDownD3;
                            Brush backJogUpD3;
                            Brush backJogDwonZD;
                            Brush backJogUpZD;

                            if ((iparam4 & 0x01) == 0)
                                backAlaramXD = Brushes.AntiqueWhite;
                            else
                            {
                                backAlaramXD = Brushes.Red;
                            }
                            ShowLabelColor(lblMotorAlramX, null, backAlaramXD);

                            if ((iparam4 & 0x02) == 0)
                                backAlaramYD = Brushes.AntiqueWhite;
                            else
                                backAlaramYD = Brushes.Red;
                            ShowLabelColor(lblMotorAlramY, null, backAlaramYD);

                            if ((iparam4 & 0x04) == 0)
                                backAlaramZD = Brushes.AntiqueWhite;
                            else backAlaramZD = Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZD);


                            if ((iparam4 & 0x08) != 0)
                            {
                                backJogLeftD0 = Brushes.AntiqueWhite;
                                backJogLeftD1 = Brushes.AntiqueWhite;
                                backJogLeftD2 = Brushes.AntiqueWhite;
                                backJogLeftD3 = Brushes.AntiqueWhite;
                            }
                            else
                            {
                                backJogLeftD0 = Brushes.Red;
                                backJogLeftD1 = Brushes.Red;
                                backJogLeftD2 = Brushes.Red;
                                backJogLeftD3 = Brushes.Red;
                            }

                            ShowButtonColor(btnMoveXMinus0, null, backJogLeftD0);
                            ShowButtonColor(btnMoveXMinus1, null, backJogLeftD1);
                            ShowButtonColor(btnMoveXMinus2, null, backJogLeftD2);
                            ShowButtonColor(btnMoveXMinus3, null, backJogLeftD3);

                            if ((iparam4 & 0x10) != 0)
                            {
                                backJogRightD0 = Brushes.AntiqueWhite;
                                backJogRightD1 = Brushes.AntiqueWhite;
                                backJogRightD2 = Brushes.AntiqueWhite;
                                backJogRightD3 = Brushes.AntiqueWhite;
                            }
                            else
                            {
                                backJogRightD0 = Brushes.Red;
                                backJogRightD1 = Brushes.Red;
                                backJogRightD2 = Brushes.Red;
                                backJogRightD3 = Brushes.Red;
                            }

                            ShowButtonColor(btnMoveXPlus0, null, backJogRightD0);
                            ShowButtonColor(btnMoveXPlus1, null, backJogRightD1);
                            ShowButtonColor(btnMoveXPlus2, null, backJogRightD2);
                            ShowButtonColor(btnMoveXPlus3, null, backJogRightD3);

                            if ((iparam4 & 0x20) != 0)
                            {
                                backJogDownD0 = Brushes.AntiqueWhite;
                                backJogDownD1 = Brushes.AntiqueWhite;
                                backJogDownD2 = Brushes.AntiqueWhite;
                                backJogDownD3 = Brushes.AntiqueWhite;
                            }
                            else
                            {
                                backJogDownD0 = Brushes.Red;
                                backJogDownD1 = Brushes.Red;
                                backJogDownD2 = Brushes.Red;
                                backJogDownD3 = Brushes.Red;
                            }

                            ShowButtonColor(btnMoveYMinus0, null, backJogDownD0);
                            ShowButtonColor(btnMoveYMinus1, null, backJogDownD1);
                            ShowButtonColor(btnMoveYMinus2, null, backJogDownD2);
                            ShowButtonColor(btnMoveYMinus3, null, backJogDownD3);

                            if ((iparam4 & 0x40) != 0)
                            {
                                backJogUpD0 = Brushes.AntiqueWhite;
                                backJogUpD1 = Brushes.AntiqueWhite;
                                backJogUpD2 = Brushes.AntiqueWhite;
                                backJogUpD3 = Brushes.AntiqueWhite;
                            }
                            else
                            {
                                backJogUpD0 = Brushes.Red;
                                backJogUpD1 = Brushes.Red;
                                backJogUpD2 = Brushes.Red;
                                backJogUpD3 = Brushes.Red;
                            }
                            ShowButtonColor(btnMoveYPlus0, null, backJogUpD0);
                            ShowButtonColor(btnMoveYPlus1, null, backJogUpD1);
                            ShowButtonColor(btnMoveYPlus2, null, backJogUpD2);
                            ShowButtonColor(btnMoveYPlus3, null, backJogUpD3);


                            if ((iparam4 & 0x80) != 0)
                                backJogDwonZD= Brushes.AntiqueWhite;
                            else
                                backJogDwonZD = Brushes.Red;
                            ShowButtonColor(btnMoveZMinus, null, backJogDwonZD);

                            if ((iparam4 & 0x100) != 0)
                                backJogUpZD = Brushes.AntiqueWhite;
                            else
                                backJogUpZD = Brushes.Red;
                            ShowButtonColor(btnMoveZPlus, null, backJogUpZD);


                            //Brush backAlaramXD = ((iparam1 & 0x01) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramX, null, backAlaramXD);
                            //Brush backAlaramYD = ((iparam1 & 0x02) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramY, null, backAlaramYD);
                            //Brush backAlaramZD = ((iparam1 & 0x04) == 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowLabelColor(lblMotorAlramZ, null, backAlaramZD);

                            ////Brush backJogLeftD = ((iparam1 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus, null, backJogLeftD);
                            ////Brush backJogRightD = ((iparam1 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus, null, backJogRightD);
                            ////Brush backJogDownD = ((iparam1 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus, null, backJogDownD);
                            ////Brush backJogUpD = ((iparam1 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus, null, backJogUpD);

                            //Brush backJogLeftD0 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus0, null, backJogLeftD0);
                            //Brush backJogRightD0 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus0, null, backJogRightD0);
                            //Brush backJogDownD0 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus0, null, backJogDownD0);
                            //Brush backJogUpD0 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus0, null, backJogUpD0);

                            //Brush backJogLeftD1 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus1, null, backJogLeftD1);
                            //Brush backJogRightD1 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus1, null, backJogRightD1);
                            //Brush backJogDownD1 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus1, null, backJogDownD1);
                            //Brush backJogUpD1 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus1, null, backJogUpD1);

                            //Brush backJogLeftD2 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus2, null, backJogLeftD2);
                            //Brush backJogRightD2 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus2, null, backJogRightD2);
                            //Brush backJogDownD2 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus2, null, backJogDownD2);
                            //Brush backJogUpD2 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus2, null, backJogUpD2);

                            //Brush backJogLeftD3 = ((iparam4 & 0x08) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXMinus3, null, backJogLeftD3);
                            //Brush backJogRightD3 = ((iparam4 & 0x10) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveXPlus3, null, backJogRightD3);
                            //Brush backJogDownD3 = ((iparam4 & 0x20) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYMinus3, null, backJogDownD3);
                            //Brush backJogUpD3 = ((iparam4 & 0x40) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveYPlus3, null, backJogUpD3);

                            //Brush backJogDwonZD = ((iparam1 & 0x80) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZMinus, null, backJogDwonZD);
                            //Brush backJogUpZD = ((iparam1 & 0x100) != 0) ? Brushes.AntiqueWhite : Brushes.Red; ShowButtonColor(btnMoveZPlus, null, backJogUpZD);

                            //ShowLog((byte)LOGTYPE.LOG_NORMAL, "D", param1 + "/" + param2 + "/" + param3 + "/" + iparam4, "");

                            if ((iparam1 & 0x8000) != 0)
                            {
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "", "LASER ERROR!!!!");
                                ShowButtonColor(btnLaserReset, null, Brushes.Red);
                            }
                            else
                            {
                                ShowButtonColor(btnLaserReset, null, Brushes.LightGray);
                            }

                            if ((iparam1 & 0x07) != 0)
                            {
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, "MARKING", "", "MOTOR ERROR!!!!");
                            }

                            ShowLabelData(lblInputPort, iparam1.ToString("X4"));
                        }
                        break;
                } // switch
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async Task<List<string>> DirFileSearch(string selpath, string file)
        {
            List<string> names = new List<string>();
            string fileFullName = "";
            VinNoInfo vin = new VinNoInfo();

            try
            {
                string[] dirs = Directory.GetDirectories(selpath);
                string[] files = Directory.GetFiles(selpath, $"*{file}");
                foreach (string fileName in files)
                {
                    fileFullName = fileName.Replace(".ini", "");
                    fileFullName = fileFullName.Replace(selpath, "");
                    fileFullName = fileFullName.Replace("\\", "");
                    //fileFullName = fileFullName.Replace("Pattern_", "");
                    names.Add(fileFullName);
                }
                if (dirs.Length > 0)
                {
                    foreach (string dir in dirs)
                    {
                        await DirFileSearch(dir, file);
                    }
                }
                return names;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
                return names;
            }
        }

        private void ShowLog(byte flag, string cmd, string logmsg = "", string error = "", LogLevel level = LogLevel.Info)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowLog";
            string trace = "";
            DateTime dt = DateTime.Now;

            try
            {
                if (flag == (byte)LOGTYPE.LOG_FAILURE)
                    level = LogLevel.Error;

                trace = dt.ToString("yyyy-MM-dd HH:mm:ss  ");
                if (cmd.Length > 0)
                    trace += "[" + cmd + "] ";
                switch (flag)
                {
                    case (byte)LOGTYPE.LOG_START:                 // START
                        trace += "START";
                        break;
                    case (byte)LOGTYPE.LOG_SUCCESS:                 // SUCCESS
                        trace += "SUCCESS";
                        break;
                    case (byte)LOGTYPE.LOG_FAILURE:                 // ERROR
                        trace += "ERROR";
                        if (error.Length > 0)
                            trace += " = " + error;
                        break;
                    case (byte)LOGTYPE.LOG_NORMAL:
                        if (logmsg.Length > 0)
                            trace += logmsg;
                        break;
                    case (byte)LOGTYPE.LOG_END:
                        trace += "END";
                        break;
                    //case 3:
                    //    break;
                    //case 4:
                    //    break;
                    default:
                        //trace += logmsg;
                        break;
                }

                if (lsbResult.CheckAccess())
                {
                    if (lsbResult.Items.Count > 1000)
                        lsbResult.Items.RemoveAt(0);

                    //lsbResult.Items.Add(trace);
                    var entry = new LogEntry { Message = trace, Level = level };
                    SetControllerLogEntries.Add(entry);
                    if (lsbResult.Items.Count > 0)
                    {
                        lsbResult.SelectedIndex = lsbResult.Items.Count-1;
                        lsbResult.ScrollIntoView(lsbResult.SelectedItem);
                    }
                    BlinkIfError(entry);
                }
                else
                {
                    lsbResult.Dispatcher.Invoke(new Action(delegate
                    {
                        if (lsbResult.Items.Count > 1000)
                            lsbResult.Items.RemoveAt(0);

                        //lsbResult.Items.Add(trace);
                        var entry = new LogEntry { Message = trace, Level = level };
                        SetControllerLogEntries.Add(entry);
                        if (lsbResult.Items.Count > 0)
                        {
                            lsbResult.SelectedIndex = lsbResult.Items.Count-1;
                            lsbResult.ScrollIntoView(lsbResult.SelectedItem);
                        }
                        BlinkIfError(entry);
                    }));
                }
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, trace, Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void cbxPatternList_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            //string name = cbxPatternList.SelectedItem.ToString();
            //string patternname = Constants.PATTERN_PATH + name + ".ini";
            string className = "SetControllerWindow3";
            string funcName = "cbxPatternList_SelectionChanged";
            PatternValueEx newpattern = new PatternValueEx();
            PatternValueEx curpattern = new PatternValueEx();
            string patname = "";
            string value = "";
            byte bHeadType = 0;
            bool bret = false;
            string AreaPosition = "";
            bool bfont = false;
            bool bpos = false;
            bool bhead = false;
            bool bspeed = false;
            bool blaser = false;

            //int tmpDelayTime1 = 0;
            //int tmpDelayTime2 = 0;

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);

                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }
                //cbxPatternList.SelectedIndex = 0;

                patname = cbxPatternList.SelectedItem.ToString();
                if (patname.Length <= 0)
                    patname = "Pattern_DEFAULT";

                ImageProcessManager.GetPatternValue(patname, bHeadType, ref newpattern);
                Util.GetPrivateProfileValue("PLATE", "AREAPOSITION", "25.00", ref AreaPosition, Constants.PARAMS_INI_FILE);

                currMarkInfo.currMarkData.pattern = (PatternValueEx)newpattern.Clone();

                if (bshowAlready == false)
                {
                    bshowAlready = true;
                }
                else
                {
                    ReadPatternValue(ref curpattern);
                    //int.TryParse(txtMarkDelayTime1.Text, out tmpDelayTime1);
                    //int.TryParse(txtMarkDelayTime2.Text, out tmpDelayTime2);

                    //if ((curpattern.fontValue != orgPattern.fontValue) || (curpattern.positionValue != orgPattern.positionValue) ||
                    //    (curpattern.headValue != orgPattern.headValue) || (curpattern.speedValue != orgPattern.speedValue) ||
                    //    (curpattern.laserValue != orgPattern.laserValue))// || (tmpDelayTime1 != markDelayTime1) || (tmpDelayTime2 != markDelayTime2))
                    //{
                    //    bret = CheckSavePatternData(orgPattern.name);
                    //    if (bret == true)
                    //    {
                    //        ImageProcessManager.SetPatternValue(orgPattern.name, bHeadType, orgPattern, 0);
                    //    }
                    //}

                    if (curpattern.fontValue != orgPattern.fontValue) 
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "fontValue is not same", Thread.CurrentThread.ManagedThreadId);
                        bfont = true;
                    }

                    if (curpattern.positionValue != orgPattern.positionValue)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "positionValue is not same", Thread.CurrentThread.ManagedThreadId);
                        bpos = true;
                    }

                    if (curpattern.headValue != orgPattern.headValue)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "headValue is not same", Thread.CurrentThread.ManagedThreadId);
                        bhead = true;
                    }

                    if (curpattern.speedValue != orgPattern.speedValue)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "speedValue is not same", Thread.CurrentThread.ManagedThreadId);
                        bspeed = true;
                    }

                    if (curpattern.laserValue != orgPattern.laserValue)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "laserValue is not same", Thread.CurrentThread.ManagedThreadId);
                        blaser = true;
                    }


                    if (bfont || bpos || bhead || bspeed || blaser)
                    {
                        bret = CheckSavePatternData(orgPattern.name);
                        if (bret == true)
                        {
                            ImageProcessManager.SetPatternValue(orgPattern.name, bHeadType, orgPattern, 0);
                        }
                    }
                }

                DisplayPatternValue(bHeadType, newpattern);
                txtAreaPosition.Text = AreaPosition;
                orgPattern = (PatternValueEx)newpattern.Clone();
                orgPattern.name = patname;
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private bool CheckSavePatternData(string patternName)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "CheckSavePatternData";// MethodBase.GetCurrentMethod().Name;

            bool ret = false;
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();

            try
            {
                msg2.Message = "DO YOU WANT TO SAVE PATTERN (" + patternName  + ")?";
                msg2.Fontsize = 20;
                msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg2.VerticalContentAlignment = VerticalAlignment.Center;
                msg2.Foreground = Brushes.Red;
                msg2.Background = Brushes.White;

                if (CheckAccess())
                {
                    WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                    warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    ret = warning.ShowDialog().Value;
                }
                else
                {
                    Dispatcher.Invoke(new Action(delegate
                    {
                        WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                        warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                        ret = warning.ShowDialog().Value;
                    }));
                }
            }
            catch (Exception ex)
            {
                ret = false;
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }

            return ret;
        }

        private async void btnServoOnOff_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnServoOnOff_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            double dHomeX = 0;
            double dHomeY = 0;
            double dHomeZ = 0;
            short sHomeX = 0;
            short sHomeY = 0;
            short sHomeZ = 0;

            double dParkX = 0;
            double dParkY = 0;
            double dParkZ = 0;
            short sParkX = 0;
            short sParkY = 0;
            short sParkZ = 0;

            short stepLength = 0;
            bool onoff = false;
            string cmd = "SERVO ON";

            try
            {
                //stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);
                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                if (btnServoOnOff.Content.ToString() == "SERVO ON")
                    onoff = true;
                else
                    onoff = false;

                cmd = btnServoOnOff.Content.ToString();

                if (onoff)
                {
                    ShowLog((byte)LOGTYPE.LOG_START, cmd, "", "");

                    short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                    if (stepLength <= 0)
                        stepLength = 100;

                    if (txtHome_X.Text.Length <= 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER OFFSET X value");
                        return;
                    }

                    if (txtHome_Y.Text.Length <= 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER OFFSET Y value");
                        return;
                    }

                    if (txtHome_Z.Text.Length <= 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER OFFSET Z value");
                        return;
                    }

                    if (txtPark_X.Text.Length <= 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER Park X value");
                        return;
                    }

                    if (txtPark_Y.Text.Length <= 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER Park Y value");
                        return;
                    }

                    if (txtPark_Z.Text.Length <= 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER Park Z value");
                        return;
                    }

                    double.TryParse(txtHome_X.Text, out dHomeX);
                    dHomeX *= stepLength;
                    sHomeX = (short)(dHomeX + 0.5);

                    double.TryParse(txtHome_Y.Text, out dHomeY);
                    dHomeY *= stepLength;
                    sHomeY = (short)(dHomeY + 0.5);

                    double.TryParse(txtHome_Z.Text, out dHomeZ);
                    dHomeZ *= stepLength;
                    sHomeZ = (short)(dHomeZ + 0.5);

                    double.TryParse(txtPark_X.Text, out dParkX);
                    dParkX *= stepLength;
                    sParkX = (short)(dParkX + 0.5);

                    double.TryParse(txtPark_Y.Text, out dParkY);
                    dParkY *= stepLength;
                    sParkY = (short)(dParkY + 0.5);

                    double.TryParse(txtPark_Z.Text, out dParkZ);
                    dParkZ *= stepLength;
                    sParkZ = (short)(dParkZ + 0.5);

                    m_currCMD = (byte)'O';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(12, true);
                    if (retval.execResult != 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                        return;
                    }
                    Thread.Sleep(500);

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.HomeMoving);
                    if (retval.execResult != 0)
                    {
                        return;
                    }

                    m_currCMD = (byte)'H';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoHome(sHomeX, sHomeY, sHomeZ);
                    if (retval.execResult != 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                        return;
                    }

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        return;
                    }

                    m_currCMD = (byte)'K';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(sParkX, sParkY, sParkZ);
                    if (retval.execResult != 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                        return;
                    }
                    btnServoOnOff.Content = "SERVO OFF";
                    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_START, cmd, "");
                    m_currCMD = (byte)'O';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(12, false);
                    if (retval.execResult != 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                        return;
                    }
                    btnServoOnOff.Content = "SERVO ON";
                    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                }
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("SERVO ON/OFF EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnGoPark_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnGoPark_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;
            short sParkX = 0;
            short sParkY = 0;
            short sParkZ = 0;
            PositionValue posvalue = new PositionValue();
            HeadValue headvalue = new HeadValue();
            string cmd = "GO TO PARK POSITION";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                ReadPatternPositionValue(ref posvalue);
                ReadPatternHeadValue(ref headvalue);

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                sParkX = (short)(headvalue.park3DPos.X * stepLength + 0.5);
                sParkY = (short)(headvalue.park3DPos.Y * stepLength + 0.5);
                sParkZ = (short)(headvalue.park3DPos.Z * stepLength + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }
                m_currCMD = (byte)'K';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(sParkX, sParkY, sParkZ);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnGoHome_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnGoHome_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            //double doffsetX = 0;
            //double doffsetY = 0;
            //double doffsetZ = 0;
            short sHomeX = 0;
            short sHomeY = 0;
            short sHomeZ = 0;
            short stepLength = 0;
            PositionValue posvalue = new PositionValue();
            HeadValue headvalue = new HeadValue();
            //short initspeed, targetspeed, accel, decel;
            string cmd = "GO HOME POSITION";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");
                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                ReadPatternPositionValue(ref posvalue);
                ReadPatternHeadValue(ref headvalue);

                //sHomeX = (short)((posvalue.home3DPos.X + 0.5) * stepLength);
                //sHomeY = (short)((posvalue.home3DPos.Y + 0.5) * stepLength);
                //sHomeZ = (short)((posvalue.home3DPos.Z + 0.5) * stepLength);

                m_currCMD = (byte)'W';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetWorkArea(headvalue.max_X * headvalue.stepLength, headvalue.max_Y * headvalue.stepLength, headvalue.max_Z * headvalue.stepLength);
                if (retval.execResult != 0)
                {
                    m_currCMD = 0;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("SetWorkArea ERROR : {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                sHomeX = (short)(headvalue.home3DPos.X * stepLength);
                sHomeY = (short)(headvalue.home3DPos.Y * stepLength);
                sHomeZ = (short)(headvalue.home3DPos.Z * stepLength);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.HomeMoving);
                if (retval.execResult != 0)
                {
                    //ShowLog("GO HOME ERROR - MOTOR SPEED ERROR");
                    return;
                }

                m_currCMD = (byte)'H';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoHome(sHomeX, sHomeY, sHomeZ);
                if (retval.execResult != 0)
                {
                    //ShowLog("GO HOME ERROR (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnCenterPoint_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnCenterPoint_Click";// MethodBase.GetCurrentMethod().Name;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;

            double dstartX = 0;
            double dstartY = 0;
            double dstartZ = 0;
            short sstartX = 0;
            short sstartY = 0;
            short sstartZ = 0;
            string cmd = "GO TO CENTER POINT";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                if (txtCenter_X.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [CENTER POSITION X] VALUE");
                    return;
                }

                if (txtCenter_Y.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [CENTER POSITION Y] VALUE");
                    return;
                }

                if (txtCenter_Z.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [CENTER POSITION Z] VALUE");
                    return;
                }

                double.TryParse(txtCenter_X.Text, out dstartX);
                if (dstartX < 0)
                    dstartX = 70;
                sstartX = (short)(dstartX * stepLength + 0.5);

                double.TryParse(txtCenter_Y.Text, out dstartY);
                if (dstartY < 0)
                    dstartY = 20;
                sstartY = (short)(dstartY * stepLength + 0.5);

                double.TryParse(txtCenter_Z.Text, out dstartZ);
                if (dstartZ <= 0)
                    dstartZ = 26;
                sstartZ = (short)(dstartZ * stepLength + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoStartPoint2(sstartX, sstartY, sstartZ);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    //ShowLog("GO CENTER POINT - ERROR (" + retval.execResult + ")");
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                //ShowLog("GO CENTER POINT - SUCCESS");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("GO CENTER POINT - EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnDryRun_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnDryRun_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;
            string cmd = "DRY MARKING";
            string value = "";

            LASERSTATUS Status = 0;
            string log = "";
            PositionValue posValue = new PositionValue();
            HeadValue headValue = new HeadValue();
            int repeatCount = 0;
            int stop = 0;
            string patName = "";
            bool ret = false;
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();

            Stopwatch swMark = new Stopwatch();
            Stopwatch swLaser = new Stopwatch();
            Stopwatch swClean = new Stopwatch();

            PatternValueEx pattern = new PatternValueEx();
            int markcount = 0;

            try
            {
                if (EmissionAuto.IsChecked == true)
                {
                    msg2.Message = "THIS IS TESTING WITHOUT LASER EMISSION.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }
                //else
                //{
                //    msg2.Message = "LASER EMISSION WILL NOT BE EMISSIS TURNED OFF.";
                //    msg2.Fontsize = 20;
                //    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                //    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                //    msg2.Foreground = Brushes.Red;
                //    msg2.Background = Brushes.White;
                //}

                msg3.Message = "DO YOU WANT TO START MARKING?";
                msg3.Fontsize = 20;
                msg3.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg3.VerticalContentAlignment = VerticalAlignment.Center;
                msg3.Foreground = Brushes.Red;
                msg3.Background = Brushes.White;

                WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                ret = warning.ShowDialog().Value;

                if (ret == false)
                {
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                Util.GetPrivateProfileValue("OPTION", "ISDUALHEAD", "0", ref value, Constants.MARKING_INI_FILE);
                if ((value != "0") && (value != ""))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadUseLaserNum();
                    if (retval.execResult != 0)
                    {
                        log = "ReadUseLaserNum ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    if (retval.recvString.Length < 8)
                    {
                        log = "PLC DATA LENGTH INVALID (ReadUseLaserNum) : " + retval.recvString.Length + " - " + retval.recvString;
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        return;
                    }

                    byte byLaserNumber = 0;
                    byte byReadNumber = 0;
                    string tmpNumber = retval.recvString.Substring(4, 4);
                    byte.TryParse(tmpNumber, out byLaserNumber);

                    Util.GetPrivateProfileValue("MARK", "USEHEADNO", "1", ref value, Constants.PARAMS_INI_FILE);
                    byte.TryParse(value, out byReadNumber);

                    if ((byReadNumber != byLaserNumber) || (byLaserNumber == 0))
                    {
                        log = "MARKING ERROR - MARK HEADER NUMBER IS INVALID. (SETTING = " + byReadNumber.ToString() + ", REAL = " + byLaserNumber.ToString() + ")";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        return;
                    }
                }

                int.TryParse(tbxRunRepeatCount.Text, out repeatCount);
                if (repeatCount <= 0)
                    repeatCount = 1;

                if (AirOnOff.IsChecked == true)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                    if (retval.execResult != 0)
                    {
                        log = "SendAirAsync ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                }

                ckbStopMark.IsChecked = false;
                if (repeatCount > 1)
                    ckbStopMark.Visibility = Visibility.Visible;
                else
                    ckbStopMark.Visibility = Visibility.Collapsed;

                while (repeatCount > 0)
                {
                    int.TryParse(tbxRunRepeatCount.Text, out stop);
                    if (stop <= 0)
                    {
                        break;
                    }

                    if (ckbStopMark.IsChecked == true)
                        break;

                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "START MARKING");
                    swMark.Start();

                    if (cbxPatternList.SelectedIndex < 0)
                    {
                        log = "Pattern is not selected";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    else
                        patName = cbxPatternList.Text;

                    if (bReadFontValue == false)
                    {
                        ReadPatternValue(ref pattern);
                        retval.execResult = ReadFontData(cmd, patName);
                        if (retval.execResult != 0)
                        {
                            log = "READ FONT ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
                        GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);
                        bReadFontValue = true;
                    }

#if LASER_OFF
#else
                    //1. Aiming Beam OFF
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
                        //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        //return;
                    }
                    ShowRectangle(AimingLamp, Brushes.Black);

                    //2.read laser status
                    //ShowLog("MARKING - READ LASER STATUS");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "READ LASER STATUS. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] st = retval.recvString.Split(':');
                    if (st.Length < 2)
                    {
                        log = "READ LASER STATUS. (STATUS STRING)";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    //2-1. Check emission status
                    Status = (LASERSTATUS)UInt32.Parse(st[1]);
                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                    {
                        //ShowLog("MARKING - STOP EMISSION");
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        }
                        if (retval.execResult != 0)
                        {
                            log = "STOP EMISSION. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        ShowRectangle(EmissionLamp, Brushes.Black);
                        //EmissionLamp.Fill = Brushes.Black;
                    }
#endif
                    //3. load waveform profile number
                    // ShowLog("MARKING - SELECT PROFILE");
#if LASER_OFF
#else
#if LASER_YLR_PULSEMODE
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString());
                    if (retval.execResult != 0)
                    {
                        log = "SELECT PROFILE. (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] prsel = retval.recvString.Split('[', ']');
                    if (prsel.Length < 2)
                    {
                        log = "SELECT PROFILE. (PROFILE STRING)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    if (prsel[0] != "PRSEL: ")
                    {
                        log = "SELECT PROFILE. (PROFILE SETTING RESPONSE ERROR)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] sel = prsel[1].Split(':');
                    if (currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString() != sel[0])
                    {
                        log = "SELECT PROFILE. (PROFILE SETTING ERROR)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //4. get waveform mode
                    //ShowLog("MARKING - CONFIG WAVEFORM MODE");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
                    if (retval.execResult != 0)
                    {
                        log = "CONFIG WAVEFORM MODE. (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] pcfg = retval.recvString.Split('[', ']');
                    if (pcfg.Length < 2)
                    {
                        log = "CONFIG WAVEFORM MODE. (PROFILE STRING)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
#else
                    //if ((bool)EmissionAuto.IsChecked)
                    //{
                    //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    //    EmissionLamp.Fill = Brushes.Red;

                    //    Mode_File.CheckPowerFlag = true;
                    //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent("30");
                    //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth("0.5");

                    //    var Jobtask1 = Task.Run(() => mark.TestSolFet("O", 5, true));   //  Firmware Version 3.01 :  5 -> one shot
                    //    await Jobtask1;
                    //    await Task.Delay(50);
                    //    var chkStr = (Mode_File.CheckPowerValue / 30.0).ToString("F4");
                    //    if (Mode_File.CheckPowerValue > 32 && Mode_File.CheckPowerValue < 28)
                    //    {
                    //        Debug.WriteLine("Power Error! EndPower/SupplyPower Ratio : " + chkStr); // Error
                    //        MessageBox.Show("L A S E R   P O W E R  E R R O R  : Push OK Tab to continue.....");
                    //    }
                    //    ControlWindow.txt_log.AppendText("EndPower/SupplyPower Ratio : " + chkStr + Environment.NewLine);
                    //}

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SELECT MARK POWER. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }

                    //ShowLabelData(currMarkInfo.currMarkData.pattern.laserValue.markPower, lblLaserPower);

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SELECT MARK WIDTH. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }
#endif
#endif
                    //5. Clear Dispaly
                    //ClearMarkVINDisplay();

                    //CheckAreaData chkData = new CheckAreaData();
                    //chkData.NormalDir.X = 0;
                    //chkData.NormalDir.Y = 0;
                    //chkData.NormalDir.Z = 0;

                    //double.TryParse(txtTeachingZPos.Text, out chkData.PlaneCenterZ);

                    //if (chkData.PlaneCenterZ <= 0)
                    //{
                    //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "PLAN CENTER Z = 0", "");
                    //    return;
                    //}
                    //chkData.bReady = true;
                    //currMarkInfo.checkdata = (CheckAreaData)chkData.Clone();
                    //currMarkInfo.checkdata.bReady = true;

                    //currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck = 1;

                    ////6. Start Text
                    retval = await Start_TEXT2(cmd, currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern);
                    if (retval.execResult != 0)
                    {
                        log = "Start_TEXT3. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //posValue = (PositionValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
                    //headValue = (headValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
                    ReadPatternPositionValue(ref posValue);
                    ReadPatternHeadValue(ref headValue);

                    //5. Set Font Data Buffer Flush
                    //ShowLog("MARKING - FLUSH START");
                    m_currCMD = (byte)'B';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.FontFlush();
                    if (retval.execResult != 0)
                    {
                        log = "FONT FLUSH. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    //ShowLog("MARKING - FONT FLUSH SUCCESS");

                    //if(pattern.laserValue.density == 1)
                    {
                        //ShowLog("MARKING - SET PHASE COMPENSATION");
                        Single pc = Convert.ToSingle(txtPhaseComp.Text);
                        //pc = pattern.laserValue.phaseComp;
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CALL PHASECOMP", Thread.CurrentThread.ManagedThreadId);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(currMarkInfo.currMarkData.pattern.laserValue.phaseComp);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(pc);
                        if (retval.execResult != 0)
                        {
                            log = "SET PHASE COMPENSATION. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                    }

                    m_currCMD = (byte)'d';
                    short dwelltime = 0;
                    if (rbtMarkingPos2.IsChecked == true)
                        short.TryParse(txtMarkDelayTime2.Text, out dwelltime);
                    else
                        short.TryParse(txtMarkDelayTime1.Text, out dwelltime);

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(dwelltime);
                    if (retval.execResult != 0)
                    {
                        log = "DWEL TIME SET ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //currMarkInfo.senddata.SendDataIndex = 0;
                    //markdata.EndOfSend = false;
                    currMarkInfo.senddata.CleanFireFlag = false;    // Fire sending
                    //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataFire.Count;
                    string StPoint = currMarkInfo.senddata.sendDataFire.ElementAt(0);

                    short posX = 0;
                    short posY = 0;
                    short posZ = 0;
                    value = StPoint.Substring(4, 4);
                    short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posX);

                    value = StPoint.Substring(8, 4);
                    short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posY);

                    value = StPoint.Substring(12, 4);
                    short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posZ);
                    posZ += 500;

                    //7. Go to parking point (Check Point)
                    //ShowLog("MARKING - LOAD SPEED");

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //StPoint.Substring(4, 4 + 4);
                    m_currCMD = (byte)'K';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    if (retval.execResult != 0)
                    {
                        log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }


                    //mark.Density("N", Density.ToString("X4"));
                    //ShowLog("MARKING - SET DENSITY");
                    m_currCMD = (byte)'N';
                    //Density232 = (short)currMarkInfo.currMarkData.pattern.laserValue.density;
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)currMarkInfo.currMarkData.pattern.laserValue.density);
                    if (retval.execResult != 0)
                    {
                        log = "SET DENSITY. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.MarkMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    // Run Marking
                    //Stopwatch sw = Stopwatch.StartNew();

                    //Thread.Sleep(200);

                    swLaser.Start();

                    //Marking Start
                    //ShowLog("MARKING - START MARKING");

                    m_currCMD = (byte)'d';
                    if (rbtMarkingPos1.IsChecked == true)
                        short.TryParse(txtMarkDelayTime1.Text, out dwelltime);
                    else
                        short.TryParse(txtMarkDelayTime2.Text, out dwelltime);

                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(dwelltime);
                    //if (retval.execResult != 0)
                    //{
                    //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("dwellTimeSet ERROR = {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                    //    return;
                    //}

                    m_currCMD = (byte)'@';
                    Util.GetPrivateProfileValue("OPTION", "MARKINGLOGLEVEL", "0", ref value, Constants.PARAMS_INI_FILE);
                    byte logLevel = 0;
                    byte.TryParse(value, out logLevel);

                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, false, logLevel);
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    bReadFontValue = false;
                    currMarkInfo.checkdata.bReady = false;
                    currMarkInfo.senddata.bReady = false;
                    byLaserStartFlag = 0;

                    //////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if LASER_OFF
                    swClean.Start();
                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
                    {
                        m_currCMD = (byte)'L';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                            //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
                            //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
                            //ITNTErrorCode();
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        if ((bool)EmissionAuto.IsChecked)
                        {
                            //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            //{
                            //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //}
                            ////retval = await EmissionON();
                            //if (retval.execResult != 0)
                            //{
                            //    log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            //    return;
                            //}
                            //ShowRectangle(EmissionLamp, Brushes.Red);
                            ////EmissionLamp.Fill = Brushes.Red;
                        }

                        //currMarkInfo.senddata.SendDataIndex = 0;
                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

                        //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);

                        m_currCMD = (byte)'@';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true);
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        swClean.Stop();
                        log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
                        swClean.Reset();
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    }
#else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "ReadDeviceStatus. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    swClean.Start();
                    st = retval.recvString.Split(':');
                    Status = (LASERSTATUS)UInt32.Parse(st[1]);

                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
                    {

#if LASER_YLR_PULSEMODE
                            //Util.GetPrivateProfileValue("VINDATA", "PROFILECLEAN", "0", ref value, "Parameter.ini");                 // load waveform profile number
                            value = currMarkInfo.currMarkData.pattern.laserValue.waveformClean.ToString();
                            ShowTextBoxData(txtCurrProfile, value);
                            //txtCurrProfile.Text = value;
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value);
                            prsel = retval.recvString.Split('[', ']');
                            if (prsel[0] != "PRSEL: ")
                            {
                                log = "Profile setting Error2!. (PRSEL[0] = " + prsel[0] + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
                            sel = prsel[1].Split(':');
                            if (value != sel[0])
                            {
                                log = "Profile setting Error!. (SEL[0] = " + sel[0] + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
#else
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SELECT CLEAN POWER. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SELECT CLEAN WIDTH. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }
#endif
                        m_currCMD = (byte)'L';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                            //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
                            //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
                            //ITNTErrorCode();
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        //currMarkInfo.senddata.SendDataIndex = 0;
                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

                        //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);
                        Util.GetPrivateProfileValue("OPTION", "MARKINGLOGLEVEL", "0", ref value, Constants.PARAMS_INI_FILE);
                        logLevel = 0;
                        byte.TryParse(value, out logLevel);

                        m_currCMD = (byte)'@';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true, logLevel);
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        swClean.Stop();
                        log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
                        swClean.Reset();
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    }
#endif
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    short stepLeng = currMarkInfo.currMarkData.pattern.headValue.stepLength;
                    if (stepLeng <= 0)
                        stepLeng = 100;

                    posX = (short)(headValue.park3DPos.X * stepLeng); if (posX <= 0) posX = (short)(70 * stepLeng);
                    posY = (short)(headValue.park3DPos.Y * stepLeng); if (posY <= 0) posY = (short)(20 * stepLeng);
                    posZ = (short)(headValue.park3DPos.Z * stepLeng); if (posZ <= 0) posZ = (short)(110 * stepLeng);
                    m_currCMD = (byte)'K';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    if (retval.execResult != 0)
                    {
                        log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //Debug.WriteLine("Running Time : " + sw.Elapsed);
                    //sw.Stop();
                    //log = "TOTAL MARKING TIME : " + sw.ElapsedMilliseconds.ToString();
                    //ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);

                    swMark.Stop();
                    swLaser.Stop();
                    log = "MARKING TIME : " + swMark.ElapsedMilliseconds.ToString();
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    log = "LASER TIME : " + swLaser.ElapsedMilliseconds.ToString();
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    swMark.Reset();
                    swLaser.Reset();

                    markcount++;
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "COUNT : " + markcount.ToString());

                    repeatCount--;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
            }
        }

        private async void btnAreaCheck_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnAreaCheck_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string log = "";
            Stopwatch sw = new Stopwatch();
            //int repeatCount = 0;
            CheckAreaData chkdata = new CheckAreaData();
            string patName = "";
            string cmd = "AREA CHECK";
            byte errHeight = 0;
            byte errCline = 0;
            //FontValue fontvalue =  new FontValue();
            PatternValueEx pattern = new PatternValueEx();

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

                if (cbxPatternList.SelectedIndex < 0)
                    patName = "Pattern_DEFAULT";
                else
                    patName = cbxPatternList.Text;

                currMarkInfo.checkdata.Clear();
                //ReadPatternFontValue(ref fontvalue);

                if (ckbErrHeight.IsChecked == false)    errHeight = 0;
                else                                    errHeight = 1;

                if (ckbErrCline.IsChecked == false)     errCline = 0;
                else                                    errCline = 1;

                ReadPatternValue(ref pattern);

                sw.Start();
                while (true)
                {
                    chkdata = await Range_Test("PLATE CHECK", txtVIN.Text, pattern, errHeight, errCline);
                    if (chkdata.execResult != 0)
                    {
                        log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    currMarkInfo.checkdata = (CheckAreaData)chkdata.Clone();

                    if (ckbRepeatCheck.IsChecked == false)
                        break;
                    //repeatCount--;
                    await Task.Delay(500);
                }

                log = "MEASURE TIME : " + sw.ElapsedMilliseconds.ToString();
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);

                currMarkInfo.checkdata.bReady = true;
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CHECK PLATE - SUCCESS", Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }


        private async void btnMarkRun_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMarkRun_Click";// MethodBase.GetCurrentMethod().Name;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            LASERSTATUS Status = 0;
            string value = "";
            string log = "";
            PositionValue posValue = new PositionValue();
            HeadValue headValue = new HeadValue();
            int repeatCount = 0;
            int stop = 0;
            string patName = "";
            string cmd = "MARKING";
            bool ret = false;
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();

            Stopwatch swMark = new Stopwatch();
            Stopwatch swLaser = new Stopwatch();
            Stopwatch swClean = new Stopwatch();

            PatternValueEx pattern = new PatternValueEx();
            int markcount = 0;

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                if (EmissionAuto.IsChecked == true)
                {
                    msg2.Message = "LASER EMISSION IS TURNED ON.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }
                else
                {
                    msg2.Message = "LASER EMISSION IS TURNED OFF.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }

                msg3.Message = "DO YOU WANT TO START MARKING?";
                msg3.Fontsize = 20;
                msg3.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg3.VerticalContentAlignment = VerticalAlignment.Center;
                msg3.Foreground = Brushes.Red;
                msg3.Background = Brushes.White;

                WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                ret = warning.ShowDialog().Value;

                if (ret == false)
                {
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                Util.GetPrivateProfileValue("OPTION", "ISDUALHEAD", "0", ref value, Constants.MARKING_INI_FILE);
                if ((value != "0") && (value != ""))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadUseLaserNum();
                    if (retval.execResult != 0)
                    {
                        log = "ReadUseLaserNum ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    if (retval.recvString.Length < 8)
                    {
                        log = "PLC DATA LENGTH INVALID (ReadUseLaserNum) : " + retval.recvString.Length + " - " + retval.recvString;
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        return;
                    }

                    byte byLaserNumber = 0;
                    byte byReadNumber = 0;
                    string tmpNumber = retval.recvString.Substring(4, 4);
                    byte.TryParse(tmpNumber, out byLaserNumber);

                    Util.GetPrivateProfileValue("MARK", "USEHEADNO", "1", ref value, Constants.PARAMS_INI_FILE);
                    byte.TryParse(value, out byReadNumber);

                    if ((byReadNumber != byLaserNumber) || (byLaserNumber == 0))
                    {
                        log = "MARKING ERROR - MARK HEADER NUMBER IS INVALID. (SETTING = " + byReadNumber.ToString() + ", REAL = " + byLaserNumber.ToString() + ")";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        return;
                    }
                }

                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadUseLaserNum();
                //if (retval.execResult != 0)
                //{
                //    log = "ReadUseLaserNum ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //    return;
                //}

                //Util.GetPrivateProfileValue("MARK", "USEHEADNO", "1", ref value, Constants.PARAMS_INI_FILE);
                //if (value.Length < 4)
                //{
                //    value = "00FF" + value.PadLeft(4, '0');
                //}

                //if (value != retval.recvString)
                //{
                //    log = "MARK HEADER NUMBER IS INVALID. (SETTING = " + value + ", REAL = " + retval.recvString;
                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //    return;
                //}

                int.TryParse(tbxRunRepeatCount.Text, out repeatCount);
                if (repeatCount <= 0)
                    repeatCount = 1;

                if (AirOnOff.IsChecked == true)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                    if (retval.execResult != 0)
                    {
                        log = "SendAirAsync ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                }

                //ckbStopMark.IsChecked = false;
                if (repeatCount > 1)
                    ckbStopMark.Visibility = Visibility.Visible;
                else
                    ckbStopMark.Visibility = Visibility.Collapsed;

                while (repeatCount > 0)
                {
                    int.TryParse(tbxRunRepeatCount.Text, out stop);
                    if (stop <= 0)
                    {
                        break;
                    }

                    if (ckbStopMark.IsChecked == true)
                        break;

                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "START MARKING");
                    swMark.Start();

                    if (cbxPatternList.SelectedIndex < 0)
                        patName = "Pattern_DEFAULT";
                    else
                        patName = cbxPatternList.Text;

                    if (bReadFontValue == false)
                    {
                        ReadPatternValue(ref pattern);
                        retval.execResult = ReadFontData(cmd, patName);
                        if (retval.execResult != 0)
                        {
                            log = "READ FONT ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
                        GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);
                        bReadFontValue = true;
                    }

#if LASER_OFF
#else
                    //1. Aiming Beam OFF
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
                        //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        //return;
                    }
                    ShowRectangle(AimingLamp, Brushes.Black);

                    //2.read laser status
                    //ShowLog("MARKING - READ LASER STATUS");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "READ LASER STATUS. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] st = retval.recvString.Split(':');
                    if (st.Length < 2)
                    {
                        log = "READ LASER STATUS. (STATUS STRING)";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    //2-1. Check emission status
                    Status = (LASERSTATUS)UInt32.Parse(st[1]);
                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                    {
                        //ShowLog("MARKING - STOP EMISSION");
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        }
                        if (retval.execResult != 0)
                        {
                            log = "STOP EMISSION. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        ShowRectangle(EmissionLamp, Brushes.Black);
                        //EmissionLamp.Fill = Brushes.Black;
                    }
#endif
                    //3. load waveform profile number
                    // ShowLog("MARKING - SELECT PROFILE");
#if LASER_YLR_PULSEMODE
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString());
                    if (retval.execResult != 0)
                    {
                        log = "SELECT PROFILE. (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] prsel = retval.recvString.Split('[', ']');
                    if (prsel.Length < 2)
                    {
                        log = "SELECT PROFILE. (PROFILE STRING)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    if (prsel[0] != "PRSEL: ")
                    {
                        log = "SELECT PROFILE. (PROFILE SETTING RESPONSE ERROR)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] sel = prsel[1].Split(':');
                    if (currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString() != sel[0])
                    {
                        log = "SELECT PROFILE. (PROFILE SETTING ERROR)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //4. get waveform mode
                    //ShowLog("MARKING - CONFIG WAVEFORM MODE");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
                    if (retval.execResult != 0)
                    {
                        log = "CONFIG WAVEFORM MODE. (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] pcfg = retval.recvString.Split('[', ']');
                    if (pcfg.Length < 2)
                    {
                        log = "CONFIG WAVEFORM MODE. (PROFILE STRING)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
#else
                    //if ((bool)EmissionAuto.IsChecked)
                    //{
                    //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    //    EmissionLamp.Fill = Brushes.Red;

                    //    Mode_File.CheckPowerFlag = true;
                    //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent("30");
                    //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth("0.5");

                    //    var Jobtask1 = Task.Run(() => mark.TestSolFet("O", 5, true));   //  Firmware Version 3.01 :  5 -> one shot
                    //    await Jobtask1;
                    //    await Task.Delay(50);
                    //    var chkStr = (Mode_File.CheckPowerValue / 30.0).ToString("F4");
                    //    if (Mode_File.CheckPowerValue > 32 && Mode_File.CheckPowerValue < 28)
                    //    {
                    //        Debug.WriteLine("Power Error! EndPower/SupplyPower Ratio : " + chkStr); // Error
                    //        MessageBox.Show("L A S E R   P O W E R  E R R O R  : Push OK Tab to continue.....");
                    //    }
                    //    ControlWindow.txt_log.AppendText("EndPower/SupplyPower Ratio : " + chkStr + Environment.NewLine);
                    //}
#if LASER_OFF
#else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SELECT MARK POWER. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }

                    //ShowLabelData(currMarkInfo.currMarkData.pattern.laserValue.markPower, lblLaserPower);

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SELECT MARK WIDTH. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }
#endif
#endif
                    //5. Clear Dispaly
                    //ClearMarkVINDisplay();

                    //6. Start Text
                    retval = await Start_TEXT2(cmd, currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern);
                    if (retval.execResult != 0)
                    {
                        log = "Start_TEXT3. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //posValue = (PositionValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
                    //headValue = (headValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
                    ReadPatternPositionValue(ref posValue);
                    ReadPatternHeadValue(ref headValue);

                    //5. Set Font Data Buffer Flush
                    //ShowLog("MARKING - FLUSH START");
                    m_currCMD = (byte)'B';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.FontFlush();
                    if (retval.execResult != 0)
                    {
                        log = "FONT FLUSH. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    //ShowLog("MARKING - FONT FLUSH SUCCESS");

                    //if(pattern.laserValue.density == 1)
                    {
                        //ShowLog("MARKING - SET PHASE COMPENSATION");
                        Single pc = Convert.ToSingle(txtPhaseComp.Text);
                        //pc = pattern.laserValue.phaseComp;
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CALL PHASECOMP", Thread.CurrentThread.ManagedThreadId);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(currMarkInfo.currMarkData.pattern.laserValue.phaseComp);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(pc);
                        if (retval.execResult != 0)
                        {
                            log = "SET PHASE COMPENSATION. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                    }

                    m_currCMD = (byte)'d';
                    short dwelltime = 0;
                    if (rbtMarkingPos2.IsChecked == true)
                        short.TryParse(txtMarkDelayTime2.Text, out dwelltime);
                    else
                        short.TryParse(txtMarkDelayTime1.Text, out dwelltime);

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(dwelltime);
                    if (retval.execResult != 0)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("dwellTimeSet ERROR = {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    //currMarkInfo.senddata.SendDataIndex = 0;
                    //markdata.EndOfSend = false;
                    currMarkInfo.senddata.CleanFireFlag = false;    // Fire sending
                    //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataFire.Count;
                    string StPoint = currMarkInfo.senddata.sendDataFire.ElementAt(0);

                    short posX = 0;
                    short posY = 0;
                    short posZ = 0;
                    value = StPoint.Substring(4, 4);
                    short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posX);

                    value = StPoint.Substring(8, 4);
                    short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posY);

                    value = StPoint.Substring(12, 4);
                    short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posZ);
                    posZ += 500;

                    //7. Go to parking point (Check Point)
                    //ShowLog("MARKING - LOAD SPEED");

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //StPoint.Substring(4, 4 + 4);
                    m_currCMD = (byte)'K';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    if (retval.execResult != 0)
                    {
                        log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }


                    //mark.Density("N", Density.ToString("X4"));
                    //ShowLog("MARKING - SET DENSITY");
                    m_currCMD = (byte)'N';
                    //Density232 = (short)currMarkInfo.currMarkData.pattern.laserValue.density;
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)currMarkInfo.currMarkData.pattern.laserValue.density);
                    if (retval.execResult != 0)
                    {
                        log = "SET DENSITY. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.MarkMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    // Run Marking
                    //Stopwatch sw = Stopwatch.StartNew();

                    //Thread.Sleep(200);

                    swLaser.Start();

                    if ((bool)EmissionAuto.IsChecked)
                    {
#if LASER_OFF
#else
                        iLaserPowerList = null;
                        iLaserPowerList = new List<int>();

                        byLaserStartFlag = 1;
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                        }

                        //retval = await EmissionON();
                        if (retval.execResult != 0)
                        {
                            log = "RUN MARK. EMISSION ON ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        ShowRectangle(EmissionLamp, Brushes.Red);
                        //EmissionLamp.Fill = Brushes.Red;
#endif
                    }

                    //Marking Start
                    //ShowLog("MARKING - START MARKING");

                    m_currCMD = (byte)'d';
                    if (rbtMarkingPos1.IsChecked == true)
                        short.TryParse(txtMarkDelayTime1.Text, out dwelltime);
                    else
                        short.TryParse(txtMarkDelayTime2.Text, out dwelltime);

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(dwelltime);
                    if (retval.execResult != 0)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("dwellTimeSet ERROR = {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    m_currCMD = (byte)'@';
                    Util.GetPrivateProfileValue("OPTION", "MARKINGLOGLEVEL", "0", ref value, Constants.PARAMS_INI_FILE);
                    byte logLevel = 0;
                    byte.TryParse(value, out logLevel);

                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, false, logLevel);
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
#if LASER_OFF
#else
                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        }
                        //retval = await EmissionOFF();
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        ShowRectangle(EmissionLamp, Brushes.Black);
                        //EmissionLamp.Fill = Brushes.Black;
                    }
#endif
                    bReadFontValue = false;
                    currMarkInfo.checkdata.bReady = false;
                    currMarkInfo.senddata.bReady = false;
                    byLaserStartFlag = 0;
                    if (iLaserPowerList.Count > 0)
                    {
                        log = "MIN = " + iLaserPowerList.Min().ToString("") + ", MAX = " + iLaserPowerList.Max().ToString("") + ", MEAN = " + iLaserPowerList.Min().ToString("");
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log, "");
                    }

                    //////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if LASER_OFF
                    swClean.Start();
                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
                    {
                        m_currCMD = (byte)'L';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                            //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
                            //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
                            //ITNTErrorCode();
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        if ((bool)EmissionAuto.IsChecked)
                        {
                            //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            //{
                            //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //}
                            ////retval = await EmissionON();
                            //if (retval.execResult != 0)
                            //{
                            //    log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            //    return;
                            //}
                            //ShowRectangle(EmissionLamp, Brushes.Red);
                            ////EmissionLamp.Fill = Brushes.Red;
                        }

                        //currMarkInfo.senddata.SendDataIndex = 0;
                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

                        //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);

                        m_currCMD = (byte)'@';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true);
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        swClean.Stop();
                        log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
                        swClean.Reset();
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    }
#else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "ReadDeviceStatus. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    swClean.Start();
                    st = retval.recvString.Split(':');
                    Status = (LASERSTATUS)UInt32.Parse(st[1]);

                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
                    {
                        //ShowLog("MARKING - START CLEANING");
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "StopEmission. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        ShowRectangle(EmissionLamp, Brushes.Black);

#if LASER_YLR_PULSEMODE
                            //Util.GetPrivateProfileValue("VINDATA", "PROFILECLEAN", "0", ref value, "Parameter.ini");                 // load waveform profile number
                            value = currMarkInfo.currMarkData.pattern.laserValue.waveformClean.ToString();
                            ShowTextBoxData(txtCurrProfile, value);
                            //txtCurrProfile.Text = value;
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value);
                            prsel = retval.recvString.Split('[', ']');
                            if (prsel[0] != "PRSEL: ")
                            {
                                log = "Profile setting Error2!. (PRSEL[0] = " + prsel[0] + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
                            sel = prsel[1].Split(':');
                            if (value != sel[0])
                            {
                                log = "Profile setting Error!. (SEL[0] = " + sel[0] + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
#else
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            return;
                        }

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SELECT CLEAN POWER. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SELECT CLEAN WIDTH. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }
#endif
                        m_currCMD = (byte)'L';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                            //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
                            //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
                            //ITNTErrorCode();
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        if ((bool)EmissionAuto.IsChecked)
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                                {
                                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                                }
                            }
                            if (retval.execResult != 0)
                            {
                                log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
                            //retval = await EmissionON();
                            ShowRectangle(EmissionLamp, Brushes.Red);
                            //EmissionLamp.Fill = Brushes.Red;
                        }

                        //currMarkInfo.senddata.SendDataIndex = 0;
                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

                        //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);
                        Util.GetPrivateProfileValue("OPTION", "MARKINGLOGLEVEL", "0", ref value, Constants.PARAMS_INI_FILE);
                        logLevel = 0;
                        byte.TryParse(value, out logLevel);

                        m_currCMD = (byte)'@';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true, logLevel);
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        swClean.Stop();
                        log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
                        swClean.Reset();
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    }

                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        //retval = await EmissionOFF();

                        ShowRectangle(EmissionLamp, Brushes.Black);
                        //EmissionLamp.Fill = Brushes.Black;
                    }
#endif
                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    short stepLeng = currMarkInfo.currMarkData.pattern.headValue.stepLength;
                    if (stepLeng <= 0)
                        stepLeng = 100;

                    posX = (short)(headValue.park3DPos.X * stepLeng); if (posX <= 0) posX = (short)(70 * stepLeng);
                    posY = (short)(headValue.park3DPos.Y * stepLeng); if (posY <= 0) posY = (short)(20 * stepLeng);
                    posZ = (short)(headValue.park3DPos.Z * stepLeng); if (posZ <= 0) posZ = (short)(110 * stepLeng);
                    m_currCMD = (byte)'K';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    if (retval.execResult != 0)
                    {
                        log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //Debug.WriteLine("Running Time : " + sw.Elapsed);
                    //sw.Stop();
                    //log = "TOTAL MARKING TIME : " + sw.ElapsedMilliseconds.ToString();
                    //ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);

                    swMark.Stop();
                    swLaser.Stop();
                    log = "MARKING TIME : " + swMark.ElapsedMilliseconds.ToString();
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    log = "LASER TIME : " + swLaser.ElapsedMilliseconds.ToString();
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    swMark.Reset();
                    swLaser.Reset();

                    markcount++;
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "MARK COUNT : " + markcount.ToString());
                    //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "Running Time : " + sw.Elapsed.ToString(), Thread.CurrentThread.ManagedThreadId);

                    repeatCount--;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                if (retval.execResult != 0)
                {
                    log = "SendAirAsync ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("Btn_Start_Click = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
            }
        }


        private async void btnGoPoint_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnGoPoint_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            //short stepLength = 0;
            double dposX = 0.0d;
            double dposY = 0.0d;
            double dposZ = 0.0d;
            short sposX = 0;
            short sposY = 0;
            short sposZ = 0;
            string cmd = "GO TO POINT";
            HeadValue headValue = new HeadValue();

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                ReadPatternHeadValue(ref headValue);

                //short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                //if (stepLength <= 0)
                //    stepLength = 100;


                if (txtGoPoint_X.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [X] VALUE");
                    return;
                }

                if (txtGoPoint_Y.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [Y] VALUE");
                    return;
                }

                if (txtGoPoint_Z.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [Z] VALUE");
                    return;
                }

                double.TryParse(txtGoPoint_X.Text, out dposX);
                sposX = (short)(dposX * headValue.stepLength + 0.5);

                double.TryParse(txtGoPoint_Y.Text, out dposY);
                sposY = (short)(dposY * headValue.stepLength + 0.5);

                double.TryParse(txtGoPoint_Z.Text, out dposZ);
                sposZ = (short)(dposZ * headValue.stepLength + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SEND MOTOR SPEED ERROR : " + retval.execResult.ToString());
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sposX, sposY, sposZ, 0);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR : " + retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("GO POINT EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnSetStartPoint_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnSetStartPoint_Click";// MethodBase.GetCurrentMethod().Name;
            double dposX = 0.0d;
            double dposY = 0.0d;
            double dposZ = 0.0d;
            short sposX = 0;
            short sposY = 0;
            short sposZ = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string patternName = "";
            string patternFileName;
            //short stepLength = 0;
            string cmd = "마킹 시작 좌표 설정";
            HeadValue headValue = new HeadValue();
            string value = "";
            byte bHeadType = 0;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "START");

                //short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                //if (stepLength <= 0)
                //    stepLength = 100;

                ReadPatternHeadValue(ref headValue);

                if (txtGoPoint_X.Text.Length > 0)
                {
                    double.TryParse(txtHome_X.Text, out dposX);
                    //sposX = (short)(dposX + 0.5);
                    //sposX = (short)(dposX + 0.5);
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [X] VALUE");
                    return;
                }

                if (txtGoPoint_Y.Text.Length > 0)
                {
                    double.TryParse(txtHome_Y.Text, out dposY);
                    //sposY = (short)(dposY + 0.5);
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [Y] VALUE");
                    return;
                }

                if (txtGoPoint_Z.Text.Length > 0)
                {
                    double.TryParse(txtHome_Z.Text, out dposZ);
                    //dposZ *= headValue.stepLength;
                    //sposZ = (short)(dposZ + 0.5);
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ENTER [Z] VALUE");
                    return;
                }

                if ((cbxPatternList.Items.Count > 0) && (cbxPatternList.SelectedIndex >= 0))
                {
                    patternName = cbxPatternList.SelectedItem.ToString();
                    patternFileName = Constants.PATTERN_PATH + patternName + ".ini";

                    Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                    byte.TryParse(value, out bHeadType);

                    if (bHeadType == 0)
                    {
                        Util.WritePrivateProfileValue("FONT", "STARTPOSX", dposX.ToString("F2"), patternFileName);
                        Util.WritePrivateProfileValue("FONT", "STARTPOSY", dposY.ToString("F2"), patternFileName);
                        Util.WritePrivateProfileValue("FONT", "STARTPOSZ", dposZ.ToString("F2"), patternFileName);
                    }
                    else
                    {
                        Util.WritePrivateProfileValue("POSITION", "STARTPOSX", dposX.ToString("F2"), patternFileName);
                        Util.WritePrivateProfileValue("POSITION", "STARTPOSY", dposY.ToString("F2"), patternFileName);
                        Util.WritePrivateProfileValue("POSITION", "STARTPOSZ", dposZ.ToString("F2"), patternFileName);
                    }
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "SET START POINT SUCCESS");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnMoveXMinus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMoveXMinus_Click";// MethodBase.GetCurrentMethod().Name;
            short stepLength = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            short distance = 0;
            string cmd = "MOVE X-";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "MOVE X- START");

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);

                distance = (short)(GetDistanceXY() * (-1) * stepLength / 10);
                //                distance *= stepLength;

                m_currCMD = (byte)'J';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.MoveHead(distance, 0, 0);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "MOVE X- SUCCESS");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("MOVE X- EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnMoveXPlus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMoveXPlus_Click";// MethodBase.GetCurrentMethod().Name;

            short stepLength = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            short distance = 0;
            string cmd = "MOVE X+";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "MOVE X+ START");

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                //stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);

                distance = (short)(GetDistanceXY() * stepLength / 10);
                //distance *= stepLength;

                m_currCMD = (byte)'J';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.MoveHead(distance, 0, 0);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "MOVE X+ SUCCESS");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("MOVE X+ EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnMoveZMinus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMoveZMinus_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short distance = 0;
            short stepLength = 0;
            string cmd = "MOVE Z-";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "MOVE Z- START");
                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                //distance = GetDistanceXY();
                distance = (short)(GetDistanceXY() * (-1) * stepLength / 10);
                //distance = (short)(GetDistanceXY() * (-1));
                //distance *= stepLength;

                m_currCMD = (byte)'J';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.MoveHead(0, 0, distance);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "MOVE Z- SUCCESS");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        //private async void btnMoveZHome_Click(object sender, RoutedEventArgs e)
        //{
        //    string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
        //    string funcName = "btnMoveZHome_Click";// MethodBase.GetCurrentMethod().Name;
        //    ITNTResponseArgs retval = new ITNTResponseArgs();
        //    double doffsetZ = 0.0d;
        //    short soffsetZ = 0;
        //    short stepLength = 0;
        //    string cmd = "MOVE SCANNER HOME";

        //    try
        //    {
        //        ShowLog((byte)LOGTYPE.LOG_START, cmd, "GO Z HOME START");
        //        short.TryParse(lblStepLength.Content.ToString(), out stepLength);
        //        if (stepLength <= 0)
        //            stepLength = 100;

        //        stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);
        //        if (txtOffset_Z.Text.Length > 0)
        //        {
        //            double.TryParse(txtOffset_Z.Text, out doffsetZ);
        //            doffsetZ *= stepLength;
        //            soffsetZ = (short)(doffsetZ * stepLength + 0.5);
        //        }
        //        else
        //        {
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "ENTER SCANER OFFSET value");
        //            return;
        //        }

        //        retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.HomeMoving);
        //        if (retval.execResult != 0)
        //        {
        //            return;
        //        }


        //        m_currCMD = (byte)'h';
        //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoHome_Z(soffsetZ);
        //        if (retval.execResult != 0)
        //        {
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
        //            return;
        //        }
        //        ShowLog((byte)LOGTYPE.LOG_END, cmd, "GO Z HOME SUCCESS");
        //    }
        //    catch (Exception ex)
        //    {
        //        //string log = "";
        //        //log = string.Format("GO Z HOME EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
        //        //ShowLog(log);
        //        //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //    }
        //}

        private async void btnMoveZPlus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMoveZPlus_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short distance = 0;
            short stepLength = 0;
            string cmd = "MOVE Z+";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "MOVE Z+ START");
                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                //distance = (short)(GetDistanceZ() * stepLength);
                distance = (short)(GetDistanceXY() * stepLength / 10);
                //distance = (short)(GetDistanceXY());
                //distance *= stepLength;

                m_currCMD = (byte)'J';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.MoveHead(0, 0, distance);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "MOVE Z+ SUCCESS");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowTextBoxData(TextBox tbx, string data)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowTextBoxData";

            try
            {
                if (tbx == null)
                    return;
                if (tbx.CheckAccess())
                {
                    tbx.Text = data;
                }
                else
                {
                    tbx.Dispatcher.Invoke(new Action(delegate
                    {
                        tbx.Text = data;
                    }));
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowButtonColor(Button btn, Brush fore, Brush back)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowButtonColor";

            try
            {
                if (btn == null)
                    return;
                if (btn.CheckAccess())
                {
                    if (fore != null)
                        btn.Foreground = fore;

                    if (back != null)
                        btn.Background = back;
                }
                else
                {
                    btn.Dispatcher.Invoke(new Action(delegate
                    {
                        if (fore != null)
                            btn.Foreground = fore;

                        if (back != null)
                            btn.Background = back;
                    }));
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowLabelData(string Data, Label label, System.Windows.Media.Brush forebrush = null, System.Windows.Media.Brush backbrush = null, System.Windows.Media.Brush boarderbrush = null)//, Brush foreground, Brush background)
        {
            if (label.CheckAccess())
            {
                if (forebrush == null)
                    forebrush = label.Foreground;
                if (backbrush == null)
                    backbrush = label.Background;
                if (boarderbrush == null)
                    boarderbrush = label.BorderBrush;
                //label.Foreground = foreground;
                //label.Background = background;
                label.Content = Data;
                label.Foreground = forebrush;
                label.Background = backbrush;
                label.BorderBrush = boarderbrush;
            }
            else
            {
                label.Dispatcher.Invoke(new Action(delegate
                {
                    if (forebrush == null)
                        forebrush = label.Foreground;
                    if (backbrush == null)
                        backbrush = label.Background;
                    if (boarderbrush == null)
                        boarderbrush = label.BorderBrush;
                    //label.Foreground = foreground;
                    //label.Background = background;
                    label.Content = Data;
                    label.Foreground = forebrush;
                    label.Background = backbrush;
                    label.BorderBrush = boarderbrush;
                }));
            }
        }


        private void ShowLabelData2(Label label, string data, Brush fore, Brush back)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowLabelData2";

            try
            {
                if (label == null)
                    return;
                if (label.CheckAccess())
                {
                    label.Content = data;
                    if (back != null)
                        label.Background = back;
                    if (fore != null)
                        label.Foreground = fore;
                }
                else
                {
                    label.Dispatcher.Invoke(new Action(delegate
                    {
                        label.Content = data;
                        if (back != null)
                            label.Background = back;
                        if (fore != null)
                            label.Foreground = fore;
                    }));
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowLabelData(Label label, string data)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowLabelData";

            try
            {
                if (label == null)
                    return;
                if (label.CheckAccess())
                {
                    label.Content = data;
                }
                else
                {
                    label.Dispatcher.Invoke(new Action(delegate
                    {
                        label.Content = data;
                    }));
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowLabelColor(Label label, Brush fore, Brush back)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowLabelColor";

            try
            {
                if (label == null)
                    return;
                if (label.CheckAccess())
                {
                    if (back != null)
                        label.Background = back;
                    if (fore != null)
                        label.Foreground = fore;
                }
                else
                {
                    label.Dispatcher.Invoke(new Action(delegate
                    {
                        if (back != null)
                            label.Background = back;
                        if (fore != null)
                            label.Foreground = fore;
                    }));
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }


        private short GetDistanceXY()
        {
            short sret = 1;
            if (rbt01mm.IsChecked == true)
                sret = 1;
            else if (rbt10mm.IsChecked == true)
                sret = 10;
            else if (rbt20mm.IsChecked == true)
                sret = 20;
            else if (rbt30mm.IsChecked == true)
                sret = 30;
            else
                sret = 10;
            return sret;
        }

        private short GetDistanceZ()
        {
            short stepLength = 0;
            short sret = 0;
            stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);

            if (rbt0001mmZ.IsChecked == true)
                sret = 1;
            else if (rbt0010mmZ.IsChecked == true)
                sret = 10;
            else if (rbt0100mmZ.IsChecked == true)
                sret = (short)(1 * stepLength);
            //else if (rbt1000mmZ.IsChecked == true)
            //    sret = (short)(10 * stepLength);
            else
                sret = (short)(1 * stepLength);
            return sret;
        }

        private async void btnMoveYPlus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMoveYPlus_Click";// MethodBase.GetCurrentMethod().Name;
            short stepLength = 0;
            short distance = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "MOVE Y+";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                //stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);
                distance = (short)(GetDistanceXY() * stepLength / 10);
                //distance = GetDistanceXY();
                //distance *= stepLength;

                m_currCMD = (byte)'J';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.MoveHead(0, distance, 0);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "MOVE Y+ SUCCESS");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("MOVE Y+ EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnMoveYMinus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnMoveYMinus_Click";// MethodBase.GetCurrentMethod().Name;
            short stepLength = 0;
            short distance = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "MOVE Y-";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                //stepLength = (short)Util.GetPrivateProfileValueUINT("MARK", "STEP_LENGTH", 50, Constants.MARKING_INI_FILE);
                distance = (short)(GetDistanceXY() * (-1) * stepLength / 10);
                //distance = (short)(GetDistanceXY() * (-1));
                //distance *= stepLength;

                m_currCMD = (byte)'J';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.MoveHead(0, distance, 0);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("MOVE Y- EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void txtVIN_TextChanged(object sender, TextChangedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "txtVIN_TextChanged";

            try
            {
                if (lblVINLength != null)
                    lblVINLength.Content = txtVIN.Text.Length.ToString();
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnLaserInfo_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnLaserInfo_Click";// MethodBase.GetCurrentMethod().Name;
            //MotorSpeed load = new MotorSpeed();
            //MotorSpeed noload = new MotorSpeed();
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string value = "";
            string cmd = "GET LASER INFORMATION";
            string log = "";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadSWVersion();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadSWVersion();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadSWVersion();
                }
                if (retval.execResult != 0)
                {
                    //ShowLog("GET LASER STATUS - ReadSWVersion ERROR : " + retval.execResult.ToString());
                    log = "READ SW VERSION ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    <LASER STATUS>");
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    SW VER : " + retval.recvString);

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadSerialNumber();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadSerialNumber();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadSerialNumber();
                }
                if (retval.execResult != 0)
                {
                    //ShowLog("GET LASER STATUS - ReadSerialNumber ERROR : " + retval.execResult.ToString());
                    log = "READ SERIAL NUMBER ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    SERIAL : " + retval.recvString);

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadLaserVersion();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadLaserVersion();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadLaserVersion();
                }
                if (retval.execResult != 0)
                {
                    log = "READ LASER VERSION ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //ShowLog("GET LASER STATUS - ReadLaserVersion ERROR : " + retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    LASER VER : " + retval.recvString);

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadLaserConfiguration();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadLaserConfiguration();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadLaserConfiguration();
                }
                if (retval.execResult != 0)
                {
                    log = "READ LASER CONFIG ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //ShowLog("GET LASER STATUS - ReadLaserConfiguration ERROR : " + retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    CONFIG : " + retval.recvString);

#if LASER_YLR_PULSEMODE
                //Util.GetPrivateProfileValue("VINDATA", "PROFILEFIRE", "0", ref value, Constants.PARAMS_INI_FILE);                 // load waveform profile number
                //ProfileTxt.Text = value;
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value);
                if (retval.execResult != 0)
                {
                    log = "SELECT PROFILE ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //ShowLog("GET LASER STATUS - SelectProfile ERROR : " + retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    SEL ID : " + retval.recvString + Environment.NewLine);

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                if (retval.execResult != 0)
                {
                    log = "READ DEVICE STATUS ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //ShowLog("GET LASER STATUS - ReadDeviceStatus ERROR : " + retval.execResult.ToString());
                    return;
                }
                string[] states = retval.recvString.Split(':');
                LASERSTATUS lsts = (LASERSTATUS)UInt32.Parse(states[1]);
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    STATUS : " + string.Format("STA: 0x{0:X}", lsts));
#endif
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "    ----END------");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("GET LASER STATUS - EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnPINTest_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnPINTest_Click";// MethodBase.GetCurrentMethod().Name;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "PIN TEST";
            string value = "";
            string patternName = "";
            byte bHeadType = 0;
            //PatternValueEx pattern = new PatternValueEx();
            LaserValue laserValue = new LaserValue();
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();
            bool ret = false;
            string log = "";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                if (EmissionAuto.IsChecked == true)
                {
                    msg2.Message = "LASER EMISSION IS TURNED ON.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }
                else
                {
                    msg2.Message = "LASER EMISSION IS TURNED OFF.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }

                msg3.Message = "DO YOU WANT TO START MARKING?";
                msg3.Fontsize = 20;
                msg3.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg3.VerticalContentAlignment = VerticalAlignment.Center;
                msg3.Foreground = Brushes.Red;
                msg3.Background = Brushes.White;

                WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                ret = warning.ShowDialog().Value;

                if (ret == false)
                {
                    log = "USER CANCEL";
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log, log);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                }
                //retval = await EmissionOFF();
                if (retval.execResult != 0)
                {
                    log = "STOP EMISSION ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    return;
                }
                ShowRectangle(EmissionLamp, Brushes.Black);

                if (cbxPatternList.SelectedIndex >= 0)
                    patternName = cbxPatternList.SelectedItem.ToString();
                else
                    patternName = "Pattern_DEFAULT";

                //Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                //byte.TryParse(value, out bHeadType);
                //ImageProcessManager.GetPatternValue(patternName, bHeadType, ref pattern);

                ReadPatternLaserValue(ref laserValue);

#if LASER_YLR_PULSEMODE
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(pattern.laserValue.waveformNum.ToString());
                if (retval.execResult != 0)
                {
                    log = "SELECT PROFILE ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                string[] prsel = retval.recvString.Split('[', ']');
                if (prsel.Length < 2)
                {
                    log = "SELECT PROFILE STRING ERROR (LENGTH = " + prsel.Length.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                if (prsel[0] != "PRSEL: ")
                {
                    log = "SELECT PROFILE SETTING ERROR (PRSEL[0] = " + prsel[0] + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                string[] sel = prsel[1].Split(':');
                if (pattern.laserValue.waveformNum.ToString() != sel[0])
                {
                    log = "SELECT PROFILE NOT MATCH ERROR (SEL[0] = " + sel[0] + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                //4. get waveform mode
                //ShowLog("MARKING - CONFIG WAVEFORM MODE");
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
                if (retval.execResult != 0)
                {
                    log = "CONFIG WAVEFORM ERROR (" + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                string[] pcfg = retval.recvString.Split('[', ']');
                if (pcfg.Length < 2)
                {
                    log = "CONFIG WAVEFORM PROFILE ERROR (LENGTH = " + pcfg.Length.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
#else

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                }
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(laserValue.spotPower);
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(laserValue.spotPower);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(laserValue.spotPower);
                }
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SELECT SPOT POWER. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(laserValue.spotWidth);
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(laserValue.spotWidth);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(laserValue.spotWidth);
                }
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SELECT SPOT WIDTH. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    return;
                }
#endif
                if ((bool)EmissionAuto.IsChecked)
                {
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "LASER EMISSION ON");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    }
                    //retval = await EmissionON();
                    if (retval.execResult != 0)
                    {
                        log = "LASER EMISSION ON ERROR (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                    //ShowLog("LASER EMISSION ON SUCCESS");
                    ShowRectangle(EmissionLamp, Brushes.Red);
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true);    //  Firmware Version 2.55 :  5 -> On-Delay-Off
                if (retval.execResult != 0)
                {
                    log = "TEST SOL FET ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                //ShowLog("LASER DEVICE STATUS READ");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                }
                if (retval.execResult != 0)
                {
                    log = "READ LASER STATUS ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                //ShowLog("LASER DEVICE STATUS SUCCESS");
                string[] st = retval.recvString.Split(':');
                LASERSTATUS Status = (LASERSTATUS)UInt32.Parse(st[1]);
                if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                {
                    //ShowLog("LASER EMISSION OFF START");
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "LASER EMISSION OFF");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    }
                    //retval = await EmissionOFF();
                    if (retval.execResult != 0)
                    {
                        log = "LASER EMISSION OFF ERROR (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                    //ShowLog("LASER EMISSION OFF SUCCESS");
                    ShowRectangle(EmissionLamp, Brushes.Black);
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="speedtype">
        /// 0 : move home
        /// 1 : free speed
        /// 2 : marking speed
        /// 3 : measuring speed
        /// </param>
        /// <returns></returns>
        private async Task<ITNTResponseArgs> SendMotorSpeed(string cmd, byte speedtype)
        {
            string className = "SetControllerWindow3";
            string funcName = "SendMotorSpeed";

            MotorSpeed speed = new MotorSpeed();
            ITNTResponseArgs retval = new ITNTResponseArgs();
            byte sendCommand = (byte)'L';

            try
            {
                switch (speedtype)
                {
                    case (byte)motorSpeedType.HomeMoving:
                        short.TryParse(txbSpeedHomeInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedHomeTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedHomeAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedHomeDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 50;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 80;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 400;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 400;

                        sendCommand = (byte)'F';
                        break;

                    case (byte)motorSpeedType.FastMoving:
                        short.TryParse(txbSpeedFastInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedFastTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedFastAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedFastDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 100;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 1200;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 2000;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 2000;
                        break;

                    case (byte)motorSpeedType.MarkMoving:
                        short.TryParse(txbSpeedMarkInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedMarkTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedMarkAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedMarkDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 70;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 100;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 5000;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 5000;
                        break;

                    case (byte)motorSpeedType.MeasureMoving:
                        short.TryParse(txbSpeedMeasureInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedMeasureTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedMeasureAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedMeasureDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 110;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 1400;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 2000;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 2000;
                        break;

                    case (byte)motorSpeedType.ScanMoving:
                        short.TryParse(txbSpeedScanInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedScanTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedScanAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedScanDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 50;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 80;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 400;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 400;
                        break;

                    case (byte)motorSpeedType.ScanFastMoving:
                        short.TryParse(txbSpeedScanFastInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedScanFastTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedScanFastAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedScanFastDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 50;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 80;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 400;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 400;
                        break;

                    case (byte)motorSpeedType.CleanMoving:
                        short.TryParse(txbSpeedCleanInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedCleanTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedCleanAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedCleanDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 50;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 80;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 400;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 400;
                        break;

                    default:
                        short.TryParse(txbSpeedMarkInitialValue.Text, out speed.initSpeed);
                        short.TryParse(txbSpeedMarkTargetValue.Text, out speed.targetSpeed);
                        short.TryParse(txbSpeedMarkAccelValue.Text, out speed.accelSpeed);
                        short.TryParse(txbSpeedMarkDecelValue.Text, out speed.decelSpeed);

                        if (speed.initSpeed <= 0)
                            speed.initSpeed = 50;
                        if (speed.targetSpeed <= 0)
                            speed.targetSpeed = 80;
                        if (speed.accelSpeed <= 0)
                            speed.accelSpeed = 400;
                        if (speed.decelSpeed < 0)
                            speed.decelSpeed = 400;
                        break;
                }

                string logtmp = "SPEED( " + speedtype.ToString() + ") = " + speed.initSpeed.ToString() + ", " + speed.targetSpeed.ToString() + ", " + speed.accelSpeed.ToString() + ", " + speed.decelSpeed.ToString();
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, logtmp, Thread.CurrentThread.ManagedThreadId);

                //string logtmp = "SPEED = " + speed.initSpeed.ToString() + ", " + speed.targetSpeed.ToString() + ", " + speed.accelSpeed.ToString() + ", " + speed.decelSpeed.ToString();
                //ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, logtmp, logtmp);
                m_currCMD = sendCommand;
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(sendCommand, speed.initSpeed, speed.targetSpeed, speed.accelSpeed, speed.decelSpeed);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "LOAD SPEED ERROR (RESULT = " + retval.execResult.ToString() + ")");
                    return retval;
                }

                return retval;
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SEND MOTOR SPEED EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return retval;
            }
        }

        public void PlateColoring(byte[,] heightColor)
        {
            int BitMap_WIDTH = heightColor.GetUpperBound(1);
            int BitMap_HEIGHT = heightColor.GetUpperBound(0);

            byte[,,] pixelArrayB = new byte[BitMap_HEIGHT, BitMap_WIDTH, 4];

            for (int y = 0; y < BitMap_HEIGHT; y++)
            {
                for (int x = 0; x < BitMap_WIDTH; x++)
                {
                    var rgb = GetColorMap(heightColor[y, x], false);
                    pixelArrayB[y, x, 0] = rgb.Item3;
                    pixelArrayB[y, x, 1] = rgb.Item2;
                    pixelArrayB[y, x, 2] = rgb.Item1;
                    pixelArrayB[y, x, 3] = 255;
                }
            }

            byte[] byteArrayB = new byte[BitMap_HEIGHT * BitMap_WIDTH * 4];
            int index = 0;
            for (int row = 0; row < BitMap_HEIGHT; row++)
            {
                for (int col = 0; col < BitMap_WIDTH; col++)
                {
                    for (int i = 0; i < 4; i++)
                    {
                        byteArrayB[index++] = pixelArrayB[row, col, i];
                    }
                }
            }

            WriteableBitmap writeableBitmap = new WriteableBitmap
            (
                BitMap_WIDTH,
                BitMap_HEIGHT,
                20,//96,
                20,//96,
                PixelFormats.Bgra32,
                null
            );

            Int32Rect rectangleB = new Int32Rect(0, 0, BitMap_WIDTH, BitMap_HEIGHT);
            int strideB = 4 * BitMap_WIDTH;
            writeableBitmap.WritePixels(rectangleB, byteArrayB, strideB, 0);

            Image imageB = new Image();
            imageB.Stretch = Stretch.None;
            imageB.Margin = new Thickness(0);

            PlateColor.Children.Add(imageB);
            imageB.Source = writeableBitmap;
        }


        public (byte r, byte g, byte b) GetColorMap(byte i, bool grayColor)
        {
            double red = 0, green = 0, blue = 0;    // ( 0.0 ~ 1.0 )
            try
            {
                red = green = blue = 0.0;
                if (i < 32)
                {
                    blue = 8.0 * (double)i / 255.0;
                }
                else if (i < 96)
                {
                    green = 1.0 + 4.0 * ((double)i - 95.0) / 255.0;
                    blue = 1.0;
                }
                else if (i < 160)
                {
                    red = 1.0 + 4.0 * ((double)i - 159.0) / 255.0;
                    blue = 4.0 * (159.0 - (double)i) / 255.0;
                    green = 1.0;
                }
                else if (i < 224)
                {
                    green = 4.0 * (223.0 - (double)i) / 255.0;
                    red = 1.0;
                }
                else
                {
                    red = 8.0 * (255.0 - (double)i) / 255.0;
                }

                // New Color [0,255]:
                red = red * 255.0 + 0.5;
                green = green * 255.0 + 0.5;
                blue = blue * 255.0 + 0.5;

                if (grayColor == true)  //gray
                {
                    red = green = blue = i;
                }

                return ((byte)red, (byte)green, (byte)blue);
            }
            catch (Exception ex)
            {
                return ((byte)red, (byte)green, (byte)blue);
            }
        }


        public static int GetVinCharacterFontDot(string vin, List<List<FontDataClass>> fontdata, double fontsizeX, double fontsizeY, double shiftVal, string fontName)
        {
            string className = "SetControllerWindow3";
            string funcName = "GetVinCharacterFontDot";
            ITNTTraceLog.Instance.Trace(2, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
            int a, b, c;
            FontDataClass fd = new FontDataClass();

            try
            {
                currMarkInfo.currMarkData.fontDot = new FontDataClass[vin.Length, (int)fontsizeX, (int)fontsizeY];
                for (int k = 0; k < vin.Length; k++)
                    for (int j = 0; j < fontsizeX; j++)
                        for (int l = 0; l < fontsizeY; l++)
                            currMarkInfo.currMarkData.fontDot[k, j, l] = new FontDataClass();

                for (int vi = 0; vi < vin.Length; vi++)
                {
                    List<FontDataClass> linefont = new List<FontDataClass>();
                    linefont = fontdata[vi].ToList();

                    if (linefont.Count() > 0)
                    {
                        for (int i = 0; i < linefont.Count(); i++)
                        {
                            //FontDataClass fd = new FontDataClass();
                            fd = (FontDataClass)linefont[i].Clone();
                            //point = pointList[i].Split(',');
                            if (fd.Flag >= 0)
                            {
                                a = vi;
                                b = (int)Math.Round(fd.vector3d.X);
                                c = (int)(fontsizeY - 1.0 + shiftVal - Math.Round(fd.vector3d.Y));
                                //c = (int)Math.Round(fd.vector3d.Y);
                                //fd.vector3d.Y = ((double)fontsizeY - 1.0 + (double)shiftVal - fd.vector3d.Y);
                                //fd.vector3d.Z = 0;
                                currMarkInfo.currMarkData.fontDot[a, b, c] = (FontDataClass)fd.Clone();
                                //Debug.WriteLine(String.Format("DOT-({0},{1},{2}):{3}/{4}", a, b, c, fd.vector3d.X, fd.vector3d.Y));
                            }
                        }
                    }
                }
                ITNTTraceLog.Instance.Trace(2, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
                return 0;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return ex.HResult;
            }
        }

        private async void btnReadFont_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnReadFont_Click";
            int retval = 0;
            string cmd = "READ FONT";
            string patternName = "";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");
                if (cbxPatternList.SelectedIndex < 0)
                    patternName = "Pattern_DEFAULT";
                else
                    patternName = cbxPatternList.Text;

                retval = ReadFontData(cmd, patternName);
                if (retval != 0)
                {
                    return;
                }
                await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
                GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);
                bReadFontValue = true;
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                //GetVinCharacterFontDot(vin, fName, pattern.fontValue.fontName);
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async Task<int> ShowOneVinNoCharacter(List<FontDataClass> font, VinNoInfo vin, double Density, double fontSizeX, double fontSizeY, double shiftVal, Canvas showcanvas, Brush brush, Brush background, byte clearFlag, int interval = 0)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowOneVinNoCharacter";

            double canvaswidth = showcanvas.Width;
            double canvasheight = showcanvas.Height;
            double OriginX = 1.5d * Util.PXPERMM;
            double OriginY = 2.5d * Util.PXPERMM;
            double orgWidth = vin.width * Util.PXPERMM + OriginX * 2.0;
            double orgHeight = Util.PXPERMM * vin.height + OriginY * 2.0;
            /***********************************
            1 inch  25.4mm
            1 inch  72 pt
            1 inch  96 px        dpi
            1 mm    2.83465 pt
            1 mm    3.7795 px    dpi/ 25.4
            ***********************************/
            double CharHeight = vin.height * Util.PXPERMM;
            double CharWidth = vin.width * Util.PXPERMM;
            double CharThick = vin.thickness * Util.PXPERMM * canvaswidth / orgWidth;
            double heightthRation = canvasheight / orgHeight;
            double widthRation = canvaswidth / orgWidth;
            int index = 0;
            int Dotsize = 5;
            Line[] line = new Line[font.Count];
            Ellipse[] CurrentDot = new Ellipse[font.Count];
            //int Density = 0;
            try
            {
                //if (clearFlag != 0)
                //    showcanvas.Children.Clear();
                //showcanvas.UpdateLayout();
                //showcanvas.Background = background;

                for (int j = 0; j < font.Count; j++)
                {
                    if ((font[j] == null) || (font[j].Flag < 0))
                        continue;

                    switch (Density)
                    {
                        case 0:     // Dot Marking : Dot
                        case 1:     // Dot Marking : Dot for Line
                            if (font[j].Flag >= 0)
                            {
                                //2022.03.25 Replace by drawing ellipse.
                                CurrentDot[index] = new Ellipse();
                                CurrentDot[index].Stroke = brush;
                                CurrentDot[index].StrokeThickness = CharThick;
                                Canvas.SetZIndex(CurrentDot[index], (int)(CharThick + 0.5));
                                CurrentDot[index].Height = (double)Dotsize;
                                CurrentDot[index].Width = (double)Dotsize;
                                CurrentDot[index].Fill = brush;
                                CurrentDot[index].Margin = new Thickness((OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation - (double)Dotsize / 2.0, (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation - (double)Dotsize / 2.0, 0.0, 0.0);
                                showcanvas.Children.Add(CurrentDot[index]);
                                index++;
                            }
                            break;

                        default:
                            if (font[j].Flag == 1)
                            {
                                line[index] = new Line();
                                line[index].Stroke = brush;
                                line[index].StrokeThickness = CharThick;
                                line[index].StrokeStartLineCap = PenLineCap.Round;
                                line[index].StrokeEndLineCap = PenLineCap.Round;
                                line[index].StrokeLineJoin = PenLineJoin.Round;

                                line[index].X1 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                line[index].Y1 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;
                            }
                            else if (font[j].Flag == 2 || font[j].Flag == 3 || font[j].Flag == 5)
                            {
                                if (line[index] != null)
                                {
                                    line[index].X2 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                    line[index].Y2 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;

                                    showcanvas.Children.Add(line[index]);
                                    if (interval > 0)
                                        await Task.Delay(interval);
                                    index++;
                                }
                                line[index] = new System.Windows.Shapes.Line();
                                line[index].Stroke = brush;
                                line[index].StrokeThickness = CharThick;
                                line[index].StrokeStartLineCap = PenLineCap.Round;
                                line[index].StrokeEndLineCap = PenLineCap.Round;
                                line[index].StrokeLineJoin = PenLineJoin.Round;

                                line[index].X1 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                line[index].Y1 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;
                            }
                            else if (font[j].Flag == 4)
                            {
                                if (line[index] != null)
                                {
                                    line[index].X2 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                    line[index].Y2 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;
                                    showcanvas.Children.Add(line[index]);
                                    if (interval > 0)
                                        await Task.Delay(interval);
                                }
                            }
                            else
                            {
                            }
                            break;
                    }
                }

                return 0;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION1 - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                //Debug.WriteLine("ShowOneVinNoCharacter excption {0} - {1}", ex.HResult, ex.Message);
                return ex.HResult;
            }
        }

        private async Task<int> ShowOneVinNoCharacter(List<FontDataClass> font, VinNoInfo vin, double fontSizeX, double fontSizeY, Canvas showcanvas, Brush brush, Brush background, byte clearFlag, int interval = 0)
        {
            //double canvaswidth = 61.55; //showcanvas.ActualWidth;
            string className = "SetControllerWindow3";
            string funcName = "ShowOneVinNoCharacter";
            double canvaswidth = showcanvas.Width;
            double canvasheight = showcanvas.Height;
            double OriginX = 1.5d * Util.PXPERMM;
            double OriginY = 2.5d * Util.PXPERMM;
            double orgWidth = vin.width * Util.PXPERMM + OriginX * 2.0;
            double orgHeight = Util.PXPERMM * vin.height + OriginY * 2.0;
            /***********************************
            1 inch  25.4mm
            1 inch  72 pt
            1 inch  96 px        dpi
            1 mm    2.83465 pt
            1 mm    3.7795 px    dpi/ 25.4
            ***********************************/
            double CharHeight = vin.height * Util.PXPERMM;
            double CharWidth = vin.width * Util.PXPERMM;
            double CharThick = vin.thickness * Util.PXPERMM * canvaswidth / orgWidth;
            double heightthRation = canvasheight / orgHeight;
            double widthRation = canvaswidth / orgWidth;
            int index = 0;
            int Dotsize = 5;
            Line[] line = new Line[font.Count];
            Ellipse[] CurrentDot = new Ellipse[font.Count];
            int density = 1;

            try
            {
                showcanvas.UpdateLayout();
                showcanvas.Background = background;

                if (clearFlag != 0)
                    showcanvas.Children.Clear();

                for (int j = 0; j < font.Count; j++)
                {
                    //switch (int.Parse(Txt_Density.Text))
                    switch (density)
                    {
                        case 0:
                            if (font[j].Flag == 1 || font[j].Flag == 2 || font[j].Flag == 4 || font[j].Flag == 5)
                            {
                                //2022.03.25 Replace by drawing ellipse.
                                CurrentDot[index] = new Ellipse();
                                CurrentDot[index].Stroke = brush;
                                CurrentDot[index].StrokeThickness = CharThick;
                                Canvas.SetZIndex(CurrentDot[index], (int)(CharThick + 0.5));
                                CurrentDot[index].Height = Dotsize;
                                CurrentDot[index].Width = Dotsize;
                                CurrentDot[index].Fill = brush;
                                CurrentDot[index].Margin = new Thickness((OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation - (double)Dotsize / 2.0, (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation - (double)Dotsize / 2.0, 0.0, 0.0);
                                showcanvas.Children.Add(CurrentDot[index]);
                                index++;
                            }
                            break;
                        case 1:
                            {
                                //2022.03.25 Replace by drawing ellipse.
                                CurrentDot[index] = new Ellipse();
                                CurrentDot[index].Stroke = brush;
                                CurrentDot[index].StrokeThickness = CharThick;
                                Canvas.SetZIndex(CurrentDot[index], (int)(CharThick + 0.5));
                                CurrentDot[index].Height = (double)Dotsize;
                                CurrentDot[index].Width = (double)Dotsize;
                                CurrentDot[index].Fill = brush;
                                CurrentDot[index].Margin = new Thickness((OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation - (double)Dotsize / 2.0, (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation - (double)Dotsize / 2.0, 0.0, 0.0);
                                showcanvas.Children.Add(CurrentDot[index]);
                                index++;
                            }
                            break;

                        default:
                            if (font[j].Flag == 1)
                            {
                                line[index] = new Line();
                                line[index].Stroke = brush;
                                line[index].StrokeThickness = CharThick;
                                line[index].StrokeStartLineCap = PenLineCap.Round;
                                line[index].StrokeEndLineCap = PenLineCap.Round;
                                line[index].StrokeLineJoin = PenLineJoin.Round;

                                line[index].X1 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                line[index].Y1 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;
                            }
                            else if (font[j].Flag == 2 || font[j].Flag == 3 || font[j].Flag == 5)
                            {
                                if (line[index] != null)
                                {
                                    line[index].X2 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                    line[index].Y2 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;

                                    showcanvas.Children.Add(line[index]);
                                    if (interval > 0)
                                        await Task.Delay(interval);
                                    index++;
                                }
                                line[index] = new System.Windows.Shapes.Line();
                                line[index].Stroke = brush;
                                line[index].StrokeThickness = CharThick;
                                line[index].StrokeStartLineCap = PenLineCap.Round;
                                line[index].StrokeEndLineCap = PenLineCap.Round;
                                line[index].StrokeLineJoin = PenLineJoin.Round;

                                line[index].X1 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                line[index].Y1 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;
                            }
                            else if (font[j].Flag == 4)
                            {
                                if (line[index] != null)
                                {
                                    line[index].X2 = (OriginX + (font[j].vector3d.X * CharWidth) / fontSizeX) * widthRation;
                                    line[index].Y2 = (OriginY + (font[j].vector3d.Y * CharHeight) / fontSizeY) * heightthRation;
                                    showcanvas.Children.Add(line[index]);
                                    if (interval > 0)
                                        await Task.Delay(interval);
                                }
                            }
                            else
                            {
                            }
                            break;
                    }
                }

                return 0;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION1 - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                //Debug.WriteLine("ShowOneVinNoCharacter excption {0} - {1}", ex.HResult, ex.Message);
                return ex.HResult;
            }
        }

        public void ClearMarkVINDisplay()
        {
            if (CheckAccess())
            {
                cvsshowChar00.Children.Clear();
                cvsshowChar01.Children.Clear();
                cvsshowChar02.Children.Clear();
                cvsshowChar03.Children.Clear();
                cvsshowChar04.Children.Clear();
                cvsshowChar05.Children.Clear();
                cvsshowChar06.Children.Clear();
                cvsshowChar07.Children.Clear();
                cvsshowChar08.Children.Clear();
                cvsshowChar09.Children.Clear();
                cvsshowChar10.Children.Clear();
                cvsshowChar11.Children.Clear();
                cvsshowChar12.Children.Clear();
                cvsshowChar13.Children.Clear();
                cvsshowChar14.Children.Clear();
                cvsshowChar15.Children.Clear();
                cvsshowChar16.Children.Clear();
                cvsshowChar17.Children.Clear();
                cvsshowChar18.Children.Clear();
            }
            else
            {
                Dispatcher.Invoke(new Action(delegate
                {
                    cvsshowChar00.Children.Clear();
                    cvsshowChar01.Children.Clear();
                    cvsshowChar02.Children.Clear();
                    cvsshowChar03.Children.Clear();
                    cvsshowChar04.Children.Clear();
                    cvsshowChar05.Children.Clear();
                    cvsshowChar06.Children.Clear();
                    cvsshowChar07.Children.Clear();
                    cvsshowChar08.Children.Clear();
                    cvsshowChar09.Children.Clear();
                    cvsshowChar10.Children.Clear();
                    cvsshowChar11.Children.Clear();
                    cvsshowChar12.Children.Clear();
                    cvsshowChar13.Children.Clear();
                    cvsshowChar14.Children.Clear();
                    cvsshowChar15.Children.Clear();
                    cvsshowChar16.Children.Clear();
                    cvsshowChar17.Children.Clear();
                    cvsshowChar18.Children.Clear();
                }));
            }
        }

        public int ReadFontData(string cmd, string patternName)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadFontData";

            //int retval = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs(128);
            string value = "";
            byte bHeadType = 0;
            //string patName = "";
            VinNoInfo vininfo = new VinNoInfo();
            string log = "";
            string errorCode = "";
            //byte fontdirection = 0;

            try
            {
                if (txtVIN.Text.Length <= 0)
                {
                    //log = "READ FONT DATA FAIL - ENTER VIN ";
                    //ShowLog(log);
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "VIN IS BLANK. ENTER VIN");
                    retval.execResult = -1;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "VIN IS BLANK. ENTER VIN", Thread.CurrentThread.ManagedThreadId);
                    return retval.execResult;
                }

                //currMarkInfo.curvin = txtVIN.Text;
                ClearMarkVINDisplay();
                currMarkInfo.Initialize();

                currMarkInfo.currMarkData.mesData.markvin = txtVIN.Text;
                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);

                //if (cbxPatternList.SelectedIndex < 0)
                //    patternName = "Pattern_DEFAULT";
                //else
                //    patternName = cbxPatternList.Text;

                currMarkInfo.currMarkData.pattern.fontValue.fontName = cbxFontName.Text;
                double.TryParse(txtWidth.Text, out currMarkInfo.currMarkData.pattern.fontValue.width);
                double.TryParse(txtHeight.Text, out currMarkInfo.currMarkData.pattern.fontValue.height);
                double.TryParse(txtPitch.Text, out currMarkInfo.currMarkData.pattern.fontValue.pitch);

                ReadPatternValue(ref currMarkInfo.currMarkData.pattern);
                //pattern.fontValue.thickness = 0.4;
                //ImageProcessManager.GetPatternValue(patName, bHeadType, ref currMarkInfo.currMarkData.pattern);
                //fName = ImageProcessManager.GetFontFileName(bHeadType, pattern.fontValue.fontName, pattern.laserValue.density);

                vininfo.vinNo = currMarkInfo.currMarkData.mesData.markvin;
                vininfo.fontName = currMarkInfo.currMarkData.pattern.fontValue.fontName;
                vininfo.width = currMarkInfo.currMarkData.pattern.fontValue.width;
                vininfo.height = currMarkInfo.currMarkData.pattern.fontValue.height;
                vininfo.pitch = currMarkInfo.currMarkData.pattern.fontValue.pitch;
                vininfo.thickness = currMarkInfo.currMarkData.pattern.fontValue.thickness;

                currMarkInfo.currMarkData.pattern = (PatternValueEx)currMarkInfo.currMarkData.pattern.Clone();

                //Util.GetPrivateProfileValue("OPTION", "FONTDIRECTION", "0", ref value, Constants.PARAMS_INI_FILE);
                //byte.TryParse(value, out fontdirection);

                //retval = ImageProcessManager.GetFontDataEx(vininfo, bHeadType, currMarkInfo.currMarkData.pattern.laserValue.density, ref currMarkInfo.currMarkData.fontData, ref currMarkInfo.revsData, ref currMarkInfo.currMarkData.fontSizeX, ref currMarkInfo.currMarkData.fontSizeY, ref currMarkInfo.currMarkData.shiftValue, ref errorCode);
                retval = ImageProcessManager.GetFontDataEx(vininfo, bHeadType, currMarkInfo.currMarkData.pattern.laserValue.density, 1, ref currMarkInfo.currMarkData.fontData, ref currMarkInfo.currMarkData.fontSizeX, ref currMarkInfo.currMarkData.fontSizeY, ref currMarkInfo.currMarkData.shiftValue, ref errorCode);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET FONT ERROR" + retval.ToString());
                    return retval.execResult;
                }
                //bReadFontValue = true;
                //GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.revsData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                retval.execResult = ex.HResult;
            }
            return retval.execResult;
        }

        private async Task ShowCurrentMarkingInformation(string vin, PatternValueEx pattern, List<List<FontDataClass>> fontdata, double fontSizeX, double fontSizeY, double shiftVal, byte showFlag)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowCurrentMarkingInformation";
            string stringcolorfore = "#FFCBCBCB";
            string stringcolorback = "#FFE1E1E1";
            Color colorback;
            Color colorfore;

            try
            {
                if (CheckAccess())
                {
                    //lbllblCurrentSerial.Content = seq;
                    //lbllblCurrentType.Content = cartype.Trim();
                    if (showFlag == 1)
                    {
                        Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND1", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                        Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND1", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                        colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                        colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                    }
                    else if (showFlag == 2)
                    {
                        Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND2", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                        Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND2", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                        colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                        colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                    }
                    else if (showFlag == 3)
                    {
                        Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND3", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                        Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND3", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                        colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                        colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                    }
                    else if (showFlag == 0)
                    {
                        return;
                    }
                    else
                    {
                        Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND1", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                        Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND1", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                        colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                        colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                    }

                    await showRecogCharacters2(vin, fontdata, pattern, fontSizeX, fontSizeY, shiftVal, colorfore, colorback);
                }
                else
                {
                    Dispatcher.Invoke(new Action(async delegate
                    {
                        if (showFlag == 1)
                        {
                            Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND1", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                            Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND1", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                            colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                            colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                        }
                        else if (showFlag == 2)
                        {
                            Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND2", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                            Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND2", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                            colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                            colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                        }
                        else if (showFlag == 3)
                        {
                            Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND3", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                            Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND3", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                            colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                            colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                        }
                        else if (showFlag == 0)
                        {
                            return;
                        }
                        else
                        {
                            Util.GetPrivateProfileValue("COLOR", "VINBACKGROUND1", stringcolorback, ref stringcolorback, Constants.PARAMS_INI_FILE);
                            Util.GetPrivateProfileValue("COLOR", "VINFOREGROUND1", stringcolorfore, ref stringcolorfore, Constants.PARAMS_INI_FILE);
                            colorback = (Color)ColorConverter.ConvertFromString(stringcolorback);
                            colorfore = (Color)ColorConverter.ConvertFromString(stringcolorfore);
                        }

                        await showRecogCharacters2(vin, fontdata, pattern, fontSizeX, fontSizeY, shiftVal, colorfore, colorback);
                    }));
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }



        //private async Task showRecogCharacters2(string vin, PatternValueLaser pattern, Color fore, Color back)
        //{
        //    string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
        //    string funcName = "showRecogCharacters2";// MethodBase.GetCurrentMethod().Name;
        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

        //    //bool bShowLabel = false;
        //    double fontSizeX = 0.0d;
        //    double fontSizeY = 0.0d;
        //    double fontSizeZ = 0.0d;
        //    Dictionary<int, List<FontDataLaser>> MyData = new Dictionary<int, List<FontDataLaser>>();
        //    string ErrorCode = "";
        //    int retval = 0;
        //    int charNum = 0;
        //    Canvas[] cvsshowChar = new Canvas[19];
        //    string ctrlName = "";
        //    VinNoInfo vininfo = new VinNoInfo();
        //    int count = vin.Length;
        //    string colorstring = "#FFC8C8C8";
        //    Color color;// = (Color)ColorConverter.ConvertFromString(colorstring);
        //    Brush brush;// = new Brush();
        //    //string fonttype = "";

        //    try
        //    {
        //        vininfo.vinNo = vin;
        //        vininfo.fontName = pattern.fontValue.fontName;
        //        vininfo.width = pattern.fontValue.width;
        //        vininfo.height = pattern.fontValue.height;
        //        vininfo.pitch = pattern.fontValue.pitch;
        //        vininfo.thickness = pattern.fontValue.thickness;

        //        retval = ImageProcessManagerLaser.GetFontData(vininfo, ref MyData, out fontSizeX, out fontSizeY, out fontSizeZ, out ErrorCode);
        //        if (retval != 0)
        //            return;
        //        //bShowLabel = true;

        //        //Util.GetPrivateProfileValue("USEFONT", "TYPE", "0", ref fonttype, "Parameter/FONT.ini");

        //        for (int i = 0; i < count; i++)
        //        {
        //            charNum = (int)vin[i] - 1;
        //            ctrlName = string.Format("cvsshowChar{0:D2}", i);
        //            cvsshowChar[i] = (Canvas)FindName(ctrlName);
        //            if (cvsshowChar[i] == null)
        //                continue;

        //            cvsshowChar[i].Background = new SolidColorBrush(back);
        //            brush = new SolidColorBrush(fore);

        //            if ((charNum >= 31) && (charNum <= 128))
        //            {
        //                List<FontDataLaser> fdata = new List<FontDataLaser>();
        //                fdata = MyData[charNum];
        //                if (CheckAccess())
        //                {
        //                    //if (fonttype == "0")
        //                    //    retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                    //else
        //                        retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                }
        //                else
        //                {
        //                    Dispatcher.Invoke(new Action(async delegate
        //                    {
        //                        //if (fonttype == "0")
        //                        //    retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                        //else
        //                            retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                    }));
        //                }
        //            }

        //            //lblshowScore[0, i].Content = string.Format("{0:00.00}", confidence[i - 1] * 100);
        //            //lblshowScore[1, i].Content = string.Format("{0:00.00}", quality[i - 1] * 100);
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        //Debug.WriteLine("showRecogCharacters excption {0} - {1}", ex.HResult, ex.Message);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //    }

        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
        //}


        //private async Task showRecogCharacters2(string vin, Dictionary<int,List<FontData>>MyData, Color fore, Color back)
        //{
        //    string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
        //    string funcName = "showRecogCharacters2";// MethodBase.GetCurrentMethod().Name;
        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

        //    //bool bShowLabel = false;
        //    //double fontSizeX = 0.0d;
        //    //double fontSizeY = 0.0d;
        //    //double fontSizeZ = 0.0d;
        //    ////Dictionary<int, List<FontDataLaser>> MyData = new Dictionary<int, List<FontDataLaser>>();
        //    //string ErrorCode = "";
        //    int retval = 0;
        //    int charNum = 0;
        //    Canvas[] cvsshowChar = new Canvas[19];
        //    string ctrlName = "";
        //    //VinNoInfo vininfo = new VinNoInfo();
        //    int count = vin.Length;
        //    string colorstring = "#FFC8C8C8";
        //    Color color;// = (Color)ColorConverter.ConvertFromString(colorstring);
        //    Brush brush;// = new Brush();
        //    //string fonttype = "";

        //    try
        //    {
        //        //vininfo.vinNo = vin;
        //        //vininfo.fontName = pattern.fontValue.fontName;
        //        //vininfo.width = pattern.fontValue.width;
        //        //vininfo.height = pattern.fontValue.height;
        //        //vininfo.pitch = pattern.fontValue.pitch;
        //        //vininfo.thickness = pattern.fontValue.thickness;

        //        //retval = ImageProcessManagerLaser.GetFontData(vininfo, ref MyData, out fontSizeX, out fontSizeY, out fontSizeZ, out ErrorCode);
        //        //if (retval != 0)
        //        //    return;
        //        ////bShowLabel = true;

        //        //Util.GetPrivateProfileValue("USEFONT", "TYPE", "0", ref fonttype, "Parameter/FONT.ini");

        //        for (int i = 0; i < count; i++)
        //        {
        //            charNum = (int)vin[i] - 1;
        //            ctrlName = string.Format("cvsshowChar{0:D2}", i);
        //            cvsshowChar[i] = (Canvas)FindName(ctrlName);
        //            if (cvsshowChar[i] == null)
        //                continue;

        //            cvsshowChar[i].Background = new SolidColorBrush(back);
        //            brush = new SolidColorBrush(fore);

        //            if ((charNum >= 31) && (charNum <= 128))
        //            {
        //                List<FontData> fdata = new List<FontData>();
        //                fdata = MyData[charNum];
        //                if (CheckAccess())
        //                {
        //                    //if (fonttype == "0")
        //                    //    retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                    //else
        //                    retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                }
        //                else
        //                {
        //                    Dispatcher.Invoke(new Action(async delegate
        //                    {
        //                        //if (fonttype == "0")
        //                        //    retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                        //else
        //                        retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                    }));
        //                }
        //            }

        //            //lblshowScore[0, i].Content = string.Format("{0:00.00}", confidence[i - 1] * 100);
        //            //lblshowScore[1, i].Content = string.Format("{0:00.00}", quality[i - 1] * 100);
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        //Debug.WriteLine("showRecogCharacters excption {0} - {1}", ex.HResult, ex.Message);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //    }

        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
        //}

        //public void showRecogCharacters(string vin, PatternValueEx pattern)
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "showRecogCharacters";
        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

        //    double fontSizeX = 0.0d;
        //    double fontSizeY = 0.0d;
        //    Dictionary<int, List<FontDataClass>> MyData = new Dictionary<int, List<FontDataClass>>();
        //    string ErrorCode = "";
        //    int retval = 0;
        //    int charNum = 0;
        //    Canvas[] cvsshowChar = new Canvas[19];
        //    string ctrlName = "";
        //    VinNoInfo vininfo = new VinNoInfo();
        //    int count = vin.Length;

        //    try
        //    {
        //        vininfo.vinNo = vin;
        //        vininfo.fontName = pattern.fontValue.fontName;
        //        vininfo.width = pattern.fontValue.width;
        //        vininfo.height = pattern.fontValue.height;
        //        vininfo.pitch = pattern.fontValue.pitch;
        //        vininfo.thickness = pattern.fontValue.thickness;

        //        //retval = GetFontData(vininfo, ref MyData, out fontSizeX, out fontSizeY, out ErrorCode);
        //        if (retval != 0)
        //            return;
        //        Brush brush;
        //        string fonttype = AppDomain.CurrentDomain.BaseDirectory + vininfo.fontName + ".FON";

        //        for (int i = 0; i < count; i++)
        //        {
        //            charNum = (int)vin[i] - 1;
        //            ctrlName = string.Format("cvsshowChar{0:D2}", i);
        //            cvsshowChar[i] = Dispatcher.Invoke(() => (Canvas)FindName(ctrlName));
        //            if (cvsshowChar[i] == null)
        //                continue;
        //            brush = Brushes.Black;

        //            if ((charNum >= 31) && (charNum <= 128))
        //            {
        //                List<FontDataClass> fdata = new List<FontDataClass>();
        //                fdata = MyData[charNum];

        //                Dispatcher.Invoke(new Action(async delegate
        //                {
        //                    if (fonttype == "0")
        //                        retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                    else
        //                        retval = await ShowOneVinNoCharacter(fdata, vininfo, fontSizeX, fontSizeY, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
        //                }));

        //            }
        //        }


        //    }
        //    catch (Exception ex)
        //    {
        //        //Debug.WriteLine("showRecogCharacters excption {0} - {1}", ex.HResult, ex.Message);
        //        //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //    }

        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
        //}

        private async Task showRecogCharacters2(string vin, List<List<FontDataClass>> fontdata, PatternValueEx pattern, double fontSizeX, double fontSizeY, double shiftVal, Color fore, Color back)
        {
            string className = "SetControllerWindow3";
            string funcName = "showRecogCharacters2";
            int retval = 0;
            int charNum = 0;
            Canvas[] cvsshowChar = new Canvas[19];
            string ctrlName = "";
            VinNoInfo vininfo = new VinNoInfo();
            int count = 0;
            Brush brush;
            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

            try
            {
                count = vin.Length;

                vininfo.vinNo = vin;
                vininfo.fontName = pattern.fontValue.fontName;
                vininfo.width = pattern.fontValue.width;
                vininfo.height = pattern.fontValue.height;
                vininfo.pitch = pattern.fontValue.pitch;
                vininfo.thickness = pattern.fontValue.thickness;

                for (int i = 0; i < count; i++)
                {
                    charNum = (int)vin[i] - 1;
                    ctrlName = string.Format("cvsshowChar{0:D2}", i);
                    cvsshowChar[i] = (Canvas)FindName(ctrlName);
                    if (cvsshowChar[i] == null)
                        continue;

                    cvsshowChar[i].Background = new SolidColorBrush(back);
                    brush = new SolidColorBrush(fore);

                    //if ((charNum >= 31) && (charNum <= 128))
                    {
                        List<FontDataClass> fdata = new List<FontDataClass>();
                        if (fontdata.Count >= i)
                            fdata = fontdata[i].ToList();
                        if (CheckAccess())
                            retval = await ShowOneVinNoCharacter(fdata, vininfo, pattern.laserValue.density, fontSizeX, fontSizeY, shiftVal, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
                        else
                        {
                            Dispatcher.Invoke(new Action(async delegate
                            {
                                retval = await ShowOneVinNoCharacter(fdata, vininfo, pattern.laserValue.density, fontSizeX, fontSizeY, shiftVal, cvsshowChar[i], brush, cvsshowChar[i].Background, 1);
                            }));
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                //Debug.WriteLine("showRecogCharacters excption {0} - {1}", ex.HResult, ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }

            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
        }




        public async Task<ITNTResponseArgs> Start_TEXT2(string cmd, string vin, PatternValueEx pattern)    // Making Fire/Clean data by TM SHIN
        {
            string className = "SetControllerWindow3";
            string funcName = "Start_TEXT2";

            Vector3D SP0 = new Vector3D();
            Vector3D SP = new Vector3D();
            Vector3D CP = new Vector3D();
            Vector3D VectorNormal = new Vector3D();
            Vector3D VectorRot = new Vector3D();

            List<Vector3D> Rev_Point = new List<Vector3D>();
            double Step_W;
            double Step_H;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            int vinLength = 0;
            string value = "";
            byte headType = 0;
            VinNoInfo vininfo = new VinNoInfo();
            List<List<FontDataClass>> fontData = new List<List<FontDataClass>>();

            double fontsizeX = 0;
            double fontsizeY = 0;
            double shiftVal = 0;
            string errCode = "";

            double fontsizeX2 = 0;
            double fontsizeY2 = 0;
            double shiftVal2 = 0;

            double cleanPosition = 0;
            double totWidth = 0;
            double R11, R12, R13, R21, R22, R23, R31, R32, R33;

            int i, j;
            int idx = 0;
            List<FontDataClass> lineData = new List<FontDataClass>();
            List<FontDataClass> lineDataClean = new List<FontDataClass>();

            Vector3D M1 = new Vector3D();
            Vector3D M = new Vector3D();

            try
            {
                vinLength = vin.Length;
                if (vinLength <= 0)
                {
                    retval.execResult = -1;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "VIN LENGTH IS INVALID (" + vinLength.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out headType);

                vininfo.vinNo = vin;
                vininfo.fontName = pattern.fontValue.fontName;
                vininfo.width = pattern.fontValue.width;
                vininfo.height = pattern.fontValue.height;
                vininfo.pitch = pattern.fontValue.pitch;
                vininfo.thickness = pattern.fontValue.thickness;
                ImageProcessManager.GetFontDataEx(vininfo, headType, pattern.laserValue.density, 0, ref fontData, ref fontsizeX, ref fontsizeY, ref shiftVal, ref errCode);

                m_currCMD = (byte)'S';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SolOnOffTime(pattern.speedValue.solOnTime, pattern.speedValue.solOffTime);
                if (retval.execResult != 0)
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "SolOnOffTime ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                //m_currCMD = (byte)'d';
                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(pattern.speedValue.dwellTime);
                //if (retval.execResult != 0)
                //{
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "dwellTimeSet ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
                //    return retval;
                //}

                if (currMarkInfo.checkdata.bReady == false)
                {
                    CheckAreaData chkdata = new CheckAreaData();

                    chkdata = await Range_Test("START TEXT", vin, currMarkInfo.currMarkData.pattern, 0, 0);
                    //chkdata = await Range_Test("START TEXT", vin, currMarkInfo.currMarkData.pattern, 0, 0);
                    ////chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
                    if (chkdata.execResult != 0)
                    {
                        string log = "";
                        log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        retval.execResult = chkdata.execResult;
                        retval.errorInfo.sErrorMessage = chkdata.errorInfo.sErrorMessage;
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return retval;
                    }
                    currMarkInfo.checkdata = (CheckAreaData)chkdata.Clone();
                }

                totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

                // ABS mm at Center Point
                CP = pattern.positionValue.center3DPos;
                CP.Z += pattern.headValue.distance0Position;
                cleanPosition = pattern.laserValue.cleanPosition;
                cleanPosition += CP.Z;         // Relative Cleanning postion

                // Relative half size mm
                SP0.X = totWidth / 2;
                SP0.Y = pattern.fontValue.height / 2;
                SP0.Z = 0;
                SP = CP - SP0;
                SP.Z = 0.0d;

                VectorNormal = currMarkInfo.checkdata.NormalDir;
                VectorRot.X = -VectorNormal.Y;
                VectorRot.Y = VectorNormal.X;
                VectorRot.Z = 0.0;

                double sqXY = Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y);
                VectorRot.X /= sqXY; VectorRot.Y /= sqXY;
                // Angle between VectorNormal to Z Axis ==> Rodrigues' Matrix
                bool skipRot = false;
                double cosValue = VectorNormal.Z / Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y + VectorNormal.Z * VectorNormal.Z);
                double sinValue = Math.Sqrt(1.0 - cosValue * cosValue);

                if (cosValue > 0.9999986111)
                {      // 0.1 mm difference between 60mm
                    skipRot = true;
                    R11 = R12 = R13 = R21 = R22 = R23 = R31 = R32 = R33 = 0.0;
                    R11 = R22 = R33 = 1.0;
                }
                else
                {
                    R11 = cosValue + VectorRot.X * VectorRot.X * (1.0 - cosValue);
                    R12 = VectorRot.X * VectorRot.Y * (1.0 - cosValue) - VectorRot.Z * sinValue;
                    R13 = VectorRot.X * VectorRot.Z * (1.0 - cosValue) + VectorRot.Y * sinValue;
                    R21 = VectorRot.Y * VectorRot.X * (1.0 - cosValue) + VectorRot.Z * sinValue;
                    R22 = cosValue + VectorRot.Y * VectorRot.Y * (1.0 - cosValue);
                    R23 = VectorRot.Y * VectorRot.Z * (1.0 - cosValue) - VectorRot.X * sinValue;
                    R31 = VectorRot.Z * VectorRot.X * (1.0 - cosValue) - VectorRot.Y * sinValue;
                    R32 = VectorRot.Z * VectorRot.Y * (1.0 - cosValue) + VectorRot.X * sinValue;
                    R33 = cosValue + VectorRot.Z * VectorRot.Z * (1.0 - cosValue);
                }
                /////
                Step_W = pattern.fontValue.width / (fontsizeX - 1.0);
                Step_H = pattern.fontValue.height / (fontsizeY - 1.0);

                Int32[] RlowerBounds = { 0, -1, 0 };
                Int32[] Rlengths = { vinLength + 1, (int)(fontsizeY + 2), (int)(fontsizeX) };

                Int32[] ClowerBounds = { 0, -1, -1 };
                Int32[] Clengths = { vinLength, (int)(fontsizeY + 2), (int)(fontsizeX + 2) };

                FontData4Send[,,] RasterData = (FontData4Send[,,])Array.CreateInstance(typeof(FontData4Send), Rlengths, RlowerBounds);   // BLU
                FontData4Send[,,] AllClrData = (FontData4Send[,,])Array.CreateInstance(typeof(FontData4Send), Clengths, ClowerBounds);   // BLU

                currMarkInfo.senddata.sendDataFire.Clear();
                currMarkInfo.senddata.sendDataClean.Clear();

                //List<Vector3D> recvPoint = new List<Vector3D>();
                ImageProcessManager.GetStartPointLinear(vinLength, CP, SP, pattern.fontValue.pitch, pattern.fontValue.rotateAngle, ref Rev_Point);

                Vector3D[] LeftRightSP = new Vector3D[2];
                LeftRightSP[0] = ImageProcessManager.Rotate_Point2(SP.X - pattern.headValue.rasterSP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
                LeftRightSP[1] = ImageProcessManager.Rotate_Point2(SP.X + totWidth + pattern.headValue.rasterEP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);

                ImageProcessManager.GetFontDataOneEx(pattern.laserValue.charFull, pattern.fontValue.fontName, headType, pattern.laserValue.density, 0, ref lineDataClean, out fontsizeX2, out fontsizeY2, out shiftVal2, out errCode);

                for (i = 0; i < Rev_Point.Count; i++)
                {
                    if (vin.Substring(i, 1) != " ")      //Space Skip
                    {
                        lineData = fontData[i];
                        FontDataClass fd = new FontDataClass();
                        for (j = 0; j < lineData.Count; j++)
                        {
                            fd = (FontDataClass)lineData[j].Clone();
                            // ABS mm
                            M1.X = Rev_Point[i].X + fd.vector3d.X * Step_W;
                            // Font offset compensation
                            M1.Y = Rev_Point[i].Y + (fd.vector3d.Y - shiftVal) * Step_H;
                            M1.Z = SP.Z;

                            M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
                            M1.Z = SP.Z;

                            // TM SHIN
                            M1.X -= CP.X; M1.Y -= CP.Y;

                            M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

                            M.X += CP.X; M.Y += CP.Y;
                            double Mt = M.Z;
                            M.Z = (pattern.headValue.bySkipPlateCheck == 0) ? Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ : pattern.positionValue.teachingZHeight;
                            double Cz = 0.0;
                            Cz = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight+cleanPosition;         // Clean Axis

                            // Change mm to BLU(Unit 0.01mm)
                            M.X *= pattern.headValue.stepLength; M.Y *= pattern.headValue.stepLength; M.Z *= pattern.headValue.stepLength;
                            Cz *= pattern.headValue.stepLength;

                            FontData4Send font4Send = new FontData4Send();
                            font4Send.cN = (byte)i; font4Send.fN = (byte)j;
                            font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); font4Send.mF = (byte)fd.Flag;
                            font4Send.mC = (UInt16)(Cz + 0.5);
                            font4Send.mI = (UInt16)(fd.vector3d.X + 0.5);

                            if (pattern.laserValue.density == 1)
                            {
                                font4Send.mF = 0;
                                RasterData[i, (int)(fd.vector3d.Y - shiftVal), (int)Math.Round(fd.vector3d.X)] = (FontData4Send)font4Send.Clone();
                            }
                            else
                            {
                                var m_font = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mZ.ToString("X4") + font4Send.mF.ToString("X4");
                                currMarkInfo.senddata.sendDataFire.Add(m_font);
                            }

                            idx++;
                        }

                        idx = 0;
                        FontDataClass fdc = new FontDataClass();

                        //  make all clear data : 0, char dot clear data : 1
                        if (pattern.laserValue.charClean == 0 || pattern.laserValue.charClean == 1)
                        {
                            for (j = 0; j < lineDataClean.Count - 1; j++)
                            {
                                fdc = (FontDataClass)lineDataClean[j].Clone();

                                // ABS mm
                                M1.X = Rev_Point[i].X + fdc.vector3d.X * Step_W;
                                // Font offset compensation
                                //M1.Y = Rev_Point[i].Y + ((double.Parse(xy_[1])) - SF) * Step_H;
                                M1.Y = Rev_Point[i].Y + (fdc.vector3d.Y - shiftVal2) * Step_H;
                                M1.Z = SP.Z;

                                //M1 = Mode_File.Rotate_Point(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, double.Parse(Angle));
                                M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
                                M1.Z = SP.Z;

                                // TM SHIN
                                M1.X -= CP.X; M1.Y -= CP.Y;

                                M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

                                M.X += CP.X; M.Y += CP.Y;
                                double Mt = M.Z;
                                M.Z = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight;
                                double Cz = 0.0;
                                Cz = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight+cleanPosition;         // Clean Axis mm

                                // Change mm to BLU(Unit 0.01mm)
                                M.X *= pattern.headValue.stepLength; M.Y *= pattern.headValue.stepLength; M.Z *= pattern.headValue.stepLength;
                                Cz *= pattern.headValue.stepLength;

                                FontData4Send font4Send = new FontData4Send();
                                font4Send.cN = (byte)i; font4Send.fN = (byte)j;
                                font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); font4Send.mF = (byte)fdc.Flag;
                                font4Send.mC = (UInt16)(Cz + 0.5);
                                font4Send.mI = (UInt16)(fdc.vector3d.X + 0.5);

                                if (pattern.laserValue.density == 1)
                                {
                                    font4Send.mF = 0;
                                    AllClrData[i, (int)(fdc.vector3d.Y - shiftVal2), (int)Math.Round(fdc.vector3d.X)] = (FontData4Send)font4Send.Clone();
                                }
                                else
                                {
                                    var m_clean = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mZ.ToString("X4") + font4Send.mF.ToString("X4");
                                    currMarkInfo.senddata.sendDataClean.Add(m_clean);
                                }
                                idx++;
                            }
                        }

                        FontDataClass fd2 = new FontDataClass();

                        if (pattern.laserValue.charClean == 1)  // dot by dot clear only
                        {
                            for (j = 0; j < lineData.Count - 1; j++)
                            {
                                fd2 = lineData[j];

                                FontData4Send font4Send = new FontData4Send();

                                font4Send = RasterData[i, (int)(fd2.vector3d.Y - shiftVal), (int)Math.Round(fd2.vector3d.X)];
                                if (pattern.laserValue.density == 1)
                                {
                                    font4Send.mF = 0;
                                    AllClrData[i, (int)(fd2.vector3d.Y - shiftVal), (int)Math.Round(fd2.vector3d.X)] = font4Send;
                                }
                                else
                                {
                                    var m_clean = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mC.ToString("X4") + font4Send.mF.ToString("X4");
                                    currMarkInfo.senddata.sendDataClean.Add(m_clean);
                                }

                                idx++;
                            }
                        }
                    }
                }

                //
                // Make firing/cleanning data
                //
                idx = 0;
                int ifontsizeX = (int)(fontsizeX + 0.5);
                int ifontsizeY = (int)(fontsizeY + 0.5);

                if (pattern.laserValue.density == 1)       // Dot Firing
                {
                    // Calculate No of Dot point
                    ushort[,] NoPoints = (ushort[,])Array.CreateInstance(typeof(ushort), new int[2] { ifontsizeY + 2, 1 }, new int[2] { -1, 0 });

                    for (int y = -1; y < ifontsizeY + 1; y++)
                    {
                        for (i = 0; i < vinLength; i++)
                        {
                            for (int x = 0; x < ifontsizeX; x++)
                            {
                                if (RasterData[i, y, x] != null) NoPoints[y, 0]++;         // Data Number of fire data
                            }
                        }
                    }


                    ////
                    Debug.WriteLine("");

                    //
                    // Make Jump/Start data
                    for (i = -1; i < ifontsizeY + 1; i++)
                    {
                        for (j = 0; j < 2; j++)         // Jump/Start XXXXX
                        {
                            M1.X = LeftRightSP[j].X;
                            M1.Y = LeftRightSP[j].Y + (double)i * Step_H;
                            M1.Z = SP.Z;

                            //M1 = Mode_File.Rotate_Point(M1.X, M1.Y, LeftRightSP[j].X, LeftRightSP[j].Y, double.Parse(Angle));
                            M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, LeftRightSP[j].X, LeftRightSP[j].Y, pattern.fontValue.rotateAngle);
                            M1.Z = SP.Z;

                            M1.X -= CP.X; M1.Y -= CP.Y;

                            M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

                            M.X += CP.X; M.Y += CP.Y;
                            double Mt = M.Z;
                            M.Z = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight;        // Fire Z Axis
                            double Cz = 0.0;
                            Cz = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight+cleanPosition;         // Clean Z Axis
                            Debug.WriteLine(String.Format("J{0:D3}=>{1,7:F3},{2,7:F3},{3,7:F3}/{4,7:F3}", idx, M.X, M.Y, M.Z, Cz));

                            // Change to BLU(Unit 0.01mm)
                            M.X *= pattern.headValue.stepLength; M.Y *= pattern.headValue.stepLength; M.Z *= pattern.headValue.stepLength;
                            Cz *= pattern.headValue.stepLength;

                            FontData4Send font4Send = new FontData4Send();
                            font4Send.cN = (byte)i; font4Send.fN = (byte)j;
                            font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); //font4Send.mF = (byte)fd.Flag;
                            font4Send.mC = (UInt16)(Cz + 0.5);

                            RasterData[vinLength, i, j] = font4Send;
                            idx++;
                        }
                    }

                    idx = 0;
                    ushort[,] NoPointsC = (ushort[,])Array.CreateInstance(typeof(ushort), new int[2] { ifontsizeY + 2, 1 }, new int[2] { -1, 0 });
                    //
                    // Check Dot Pitching 0.6
                    if (pattern.laserValue.charClean == 1)
                    {
                        for (int y = 0; y < ifontsizeY; y++)
                            for (i = 0; i < vinLength; i++)
                                for (int x = 0; x < ifontsizeX; x++)
                                {
                                    if (checkDistance(AllClrData, i, y, x) == false)
                                    {
                                        if (AllClrData[i, y, x].mI == (double)x)
                                        {
                                            AllClrData[i, y, x] = null;
                                            Debug.WriteLine(String.Format("NULL=>V{0:D3},X{1:D3},Y{2:D3}", i, x, y));
                                        }
                                    }
                                }
                    }

                    for (int y = -1; y < ifontsizeY + 1; y++)
                        for (i = 0; i < vinLength; i++)
                            for (int x = -1; x < ifontsizeX + 1; x++)
                                if (AllClrData[i, y, x] != null) NoPointsC[y, 0]++;    // Data Number of clean data

                    //
                    //
                    //
                    if (pattern.headValue.spatterType == 0)  // 0 : Back
                    {
                        //
                        // Make Firing & cleanning Data for back spatter at 0 degree
                        if (pattern.fontValue.rotateAngle == 0.0)
                        {
                            // Fire & then Clean : Normal case
                            {
                                //
                                // Make firing Data for 0 degree, back spatter [B0D]
                                StringBuilder sb = new StringBuilder();
                                bool DirRight = true;
                                for (int y = 0; y < ifontsizeY; y++)
                                {
                                    if (DirRight == true)
                                    {   // Fire Data string
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y, 0]);
                                        for (i = 0; i < vinLength; i++)
                                            for (int x = 0; x < ifontsizeX; x++)
                                                if (RasterData[i, y, x] != null)
                                                    sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                        //Mode_File.SendData.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    else
                                    {   // Fire Data string
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y, 0]);
                                        for (i = vinLength - 1; i >= 0; i--)
                                            for (int x = ifontsizeX - 1; x >= 0; x--)
                                                if (RasterData[i, y, x] != null)
                                                    sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                        //Mode_File.SendData.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    DirRight = !DirRight;
                                }

                                //
                                //  Make Cleaning Data for 0 degree, back spatter [B0C]
                                sb = new StringBuilder();
                                ushort x2 = 0, y2 = 0, c2 = 0;

                                //Mode_File.TwoLineDisplay = false;
                                currMarkInfo.checkdata.TwoLineDisplay = false;
                                for (int y = ifontsizeY; y >= -1; y--)
                                {
                                    if (NoPointsC[y, 0] > 0)
                                    {
                                        if (DirRight == false)
                                        {
                                            x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                            y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                            c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                            x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                            y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                            c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                            for (i = vinLength - 1; i >= 0; i--)
                                                for (int x = ifontsizeX; x >= -1; x--)
                                                {
                                                    if (AllClrData[i, y, x] != null)
                                                    {
                                                        sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                    }
                                                }
                                            //Mode_File.SendClean.Add(sb.ToString());
                                            currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                            Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                            sb.Length = 0;
                                        }
                                        else
                                        {
                                            x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                            y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                            c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                            x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                            y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                            c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                            for (i = 0; i < vinLength; i++)
                                                for (int x = -1; x < ifontsizeX + 1; x++)
                                                {
                                                    if (AllClrData[i, y, x] != null)
                                                    {
                                                        sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                    }
                                                }
                                            //Mode_File.SendClean.Add(sb.ToString());
                                            currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                            Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                            sb.Length = 0;
                                        }
                                        DirRight = !DirRight;
                                    }   // NoPointsC
                                    else
                                    {
                                        //Mode_File.TwoLineDisplay = true;
                                        currMarkInfo.checkdata.TwoLineDisplay = true;
                                    }
                                }

                            } // CombineFireClean if-else
                        }
                        else
                        {
                            // 
                            // Make firing data at 180 degree for back spatter [B180D]
                            StringBuilder sb = new StringBuilder();
                            bool DirRight = true;
                            for (int y = ifontsizeY - 1; y >= 0; y--)
                            {
                                if (DirRight == false)
                                {   // Fire Data string
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y, 0]);
                                    for (i = vinLength - 1; i >= 0; i--)
                                        for (int x = ifontsizeX - 1; x >= 0; x--)
                                            if (RasterData[i, y, x] != null)
                                                sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                    //Mode_File.SendData.Add(sb.ToString());
                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                    Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                    sb.Length = 0;
                                }
                                else
                                {   // Fire Data string
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y, 0]);
                                    for (i = 0; i < vinLength; i++)
                                        for (int x = 0; x < ifontsizeX; x++)
                                            if (RasterData[i, y, x] != null)
                                                sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                    //Mode_File.SendData.Add(sb.ToString());
                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                    Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                    sb.Length = 0;
                                }
                                DirRight = !DirRight;
                            }

                            //
                            //  Make Cleaning Data for 180 degree, back spatter [B180C]
                            sb = new StringBuilder();
                            ushort x2 = 0, y2 = 0, c2 = 0;
                            currMarkInfo.checkdata.TwoLineDisplay = false;
                            for (int y = -1; y < ifontsizeY + 1; y++)
                            {
                                if (NoPointsC[y, 0] > 0)
                                {
                                    if (DirRight == false)
                                    {
                                        x2 = (ushort)RasterData[vinLength, y, 1].mX;
                                        y2 = (ushort)RasterData[vinLength, y, 1].mY;
                                        c2 = (ushort)RasterData[vinLength, y, 1].mC;
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                        x2 = (ushort)RasterData[vinLength, y, 0].mX;
                                        y2 = (ushort)RasterData[vinLength, y, 0].mY;
                                        c2 = (ushort)RasterData[vinLength, y, 0].mC;
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                        for (i = vinLength - 1; i >= 0; i--)
                                            for (int x = ifontsizeX; x >= -1; x--)
                                            {
                                                if (AllClrData[i, y, x] != null)
                                                {
                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                }
                                            }
                                        //Mode_File.SendClean.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    else
                                    {
                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                        for (i = 0; i < vinLength; i++)
                                            for (int x = -1; x < ifontsizeX + 1; x++)
                                            {
                                                if (AllClrData[i, y, x] != null)
                                                {
                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                }
                                            }
                                        //Mode_File.SendClean.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    DirRight = !DirRight;
                                } //
                                else
                                {
                                    currMarkInfo.checkdata.TwoLineDisplay = true;
                                }
                            }

                        }   // Back spatter
                    }
                    else    // Front spatter
                    {
                        //
                        // Make Firing & cleanning Data for front spatter at 0 degree
                        if (pattern.fontValue.rotateAngle == 0.0)
                        {
                            //
                            // Make firing Data for 0 degree, front spatter [F0D]
                            StringBuilder sb = new StringBuilder();
                            bool DirRight = true;
                            for (int y = ifontsizeY - 1; y >= 0; y--)
                            {
                                if (DirRight == true)
                                {   // Fire Data string for even line ->
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y, 0]);
                                    for (i = 0; i < vinLength; i++)
                                        for (int x = 0; x < ifontsizeX; x++)
                                            if (RasterData[i, y, x] != null)
                                                sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                    //Mode_File.SendData.Add(sb.ToString());
                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                    Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                    sb.Length = 0;
                                }
                                else
                                {   // Fire Data string for odd line <-
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y, 0]);
                                    for (i = vinLength - 1; i >= 0; i--)
                                        for (int x = ifontsizeX - 1; x >= 0; x--)
                                            if (RasterData[i, y, x] != null)
                                                sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                    //Mode_File.SendData.Add(sb.ToString());
                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                    Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                    sb.Length = 0;
                                }
                                DirRight = !DirRight;
                            }

                            //
                            //  Make Cleaning Data for 0 degree, front spatter [F0C]
                            sb = new StringBuilder();
                            ushort x2 = 0, y2 = 0, c2 = 0;

                            currMarkInfo.checkdata.TwoLineDisplay = false;
                            for (int y = -1; y < ifontsizeY + 1; y++)
                            {
                                if (NoPointsC[y, 0] > 0)
                                {
                                    if (DirRight == false)
                                    {
                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                        for (i = vinLength - 1; i >= 0; i--)
                                            for (int x = ifontsizeX; x >= -1; x--)
                                            {
                                                if (AllClrData[i, y, x] != null)
                                                {
                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                }
                                            }
                                        //Mode_File.SendClean.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    else
                                    {
                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                        for (i = 0; i < vinLength; i++)
                                            for (int x = -1; x < ifontsizeX + 1; x++)
                                            {
                                                if (AllClrData[i, y, x] != null)
                                                {
                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                }
                                            }
                                        //Mode_File.SendClean.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    DirRight = !DirRight;
                                }
                                else
                                {
                                    currMarkInfo.checkdata.TwoLineDisplay = true;
                                }
                            }
                        }
                        else
                        {
                            // 
                            // Make firing data at 180 degree for front spatter [F180D]
                            StringBuilder sb = new StringBuilder();
                            bool DirRight = true;
                            for (int y = 0; y < ifontsizeY; y++)
                            {
                                if (DirRight == false) // odd line <-
                                {   // Fire Data string
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y, 0]);
                                    for (i = vinLength - 1; i >= 0; i--)
                                        for (int x = ifontsizeX - 1; x >= 0; x--)
                                            if (RasterData[i, y, x] != null)
                                                sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                    //Mode_File.SendData.Add(sb.ToString());
                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                    Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                    sb.Length = 0;
                                }
                                else
                                {   // Fire Data string even line ->
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y, 0]);
                                    for (i = 0; i < vinLength; i++)
                                        for (int x = 0; x < ifontsizeX; x++)
                                            if (RasterData[i, y, x] != null)
                                                sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
                                    //Mode_File.SendData.Add(sb.ToString());
                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                    Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y, 0].ToString("000") + ":" + sb.ToString());
                                    sb.Length = 0;
                                }
                                DirRight = !DirRight;
                            }

                            //
                            //  Make Cleaning Data for 180 degree, front spatter [F180C]
                            sb = new StringBuilder();
                            ushort x2 = 0, y2 = 0, c2 = 0;

                            currMarkInfo.checkdata.TwoLineDisplay = false;
                            for (int y = ifontsizeY; y >= -1; y--)
                            {
                                if (NoPointsC[y, 0] > 0)
                                {
                                    if (DirRight == true)
                                    {
                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                        for (i = 0; i < vinLength; i++)
                                            for (int x = -1; x < ifontsizeX + 1; x++)
                                            {
                                                if (AllClrData[i, y, x] != null)
                                                {
                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                }
                                            }
                                        //Mode_File.SendClean.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    else
                                    {
                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y, 0]);

                                        for (i = vinLength - 1; i >= 0; i--)
                                            for (int x = ifontsizeX; x >= -1; x--)
                                            {
                                                if (AllClrData[i, y, x] != null)
                                                {
                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mX);
                                                }
                                            }
                                        //Mode_File.SendClean.Add(sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y, 0].ToString("000") + ":" + sb.ToString());
                                        sb.Length = 0;
                                    }
                                    DirRight = !DirRight;
                                }
                                else
                                {
                                    currMarkInfo.checkdata.TwoLineDisplay = true;
                                }
                            }

                        }   // front spatter
                        if (pattern.laserValue.charClean != 0)
                        {
                            currMarkInfo.checkdata.TwoLineDisplay = false;
                        }
                    }   // Back/front spatter
                }   // Dot firing

                //M_Count = idx;
                //Mark_Counter++;

                //Mode_File.Download_Data = true;
            }
            catch (Exception ex)
            {
                retval.execResult = ex.HResult;
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return retval;
            }

            return retval;

            // Local function

            Vector3D getRodrigueRotation(Vector3D XY0)
            {
                Vector3D Tmp = new Vector3D();
                Tmp.X = XY0.X * R11 + XY0.Y * R12 + XY0.Z * R13;
                Tmp.Y = XY0.X * R21 + XY0.Y * R22 + XY0.Z * R23;
                Tmp.Z = XY0.X * R31 + XY0.Y * R32 + XY0.Z * R33;

                return Tmp;
            }

            bool checkDistance(FontData4Send[,,] AllClrData, int ii, int yy, int xx)
            {
                if (AllClrData[ii, yy, xx - 1] != null)
                {
                    if (Math.Abs(AllClrData[ii, yy, xx].mI - AllClrData[ii, yy, xx - 1].mI) < 0.599)
                        return false;
                }
                if (AllClrData[ii, yy, xx + 1] != null)
                {
                    if (Math.Abs(AllClrData[ii, yy, xx].mI - AllClrData[ii, yy, xx + 1].mI) < 0.599)
                        return false;
                }
                return true;
            }

        }

        //public async Task<ITNTResponseArgs> Start_TEXT(string cmd, string vin, PatternValueEx pattern)    // Making Fire/Clean data by TM SHIN
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "Start_TEXT";

        //    ITNTResponseArgs retval = new ITNTResponseArgs();
        //    int vinLength = 0;

        //    Vector3D SP0 = new Vector3D();
        //    Vector3D SP = new Vector3D();
        //    Vector3D CP = new Vector3D();

        //    Vector3D VectorNormal = new Vector3D();
        //    Vector3D VectorRot = new Vector3D();
        //    List<Vector3D> Rev_Point = new List<Vector3D>();

        //    double Step_W;
        //    double Step_H;
        //    string value = "";
        //    byte headType = 0;
        //    VinNoInfo vininfo = new VinNoInfo();
        //    //List<List<FontDataClass>> MyData = new List<List<FontDataClass>>();
        //    List<List<FontDataClass>> fontData = new List<List<FontDataClass>>();
        //    double fontsizeX = 0, fontsizeY = 0, shiftVal = 0;
        //    double fontsizeX2 = 0, fontsizeY2 = 0, shiftVal2 = 0;
        //    double cleanPosition = 0;
        //    string errCode = "";
        //    double totWidth = 0;
        //    double R11, R12, R13, R21, R22, R23, R31, R32, R33;
        //    int i, j;
        //    int idx = 0;
        //    int ifontsizeX = 0, ifontsizeY = 0, ishiftVal = 0;

        //    Vector3D M1 = new Vector3D();                                   // for fire data mm
        //    Vector3D M2 = new Vector3D();                                   // for clean data mm
        //    Vector3D M = new Vector3D();
        //    Vector3D C = new Vector3D();
        //    //byte fontdirection = 0;
        //    string log = "";
        //    try
        //    {
        //        vinLength = vin.Length;
        //        if (vinLength <= 0)
        //        {
        //            retval.execResult = -1;
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "VIN LENGTH IS INVALID (" + vinLength.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

        //        Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
        //        byte.TryParse(value, out headType);

        //        vininfo.vinNo = vin;
        //        vininfo.fontName = pattern.fontValue.fontName;
        //        vininfo.width = pattern.fontValue.width;
        //        vininfo.height = pattern.fontValue.height;
        //        vininfo.pitch = pattern.fontValue.pitch;
        //        vininfo.thickness = pattern.fontValue.thickness;
        //        ImageProcessManager.GetFontDataEx(vininfo, headType, pattern.laserValue.density, 0, ref fontData, ref fontsizeX, ref fontsizeY, ref shiftVal, ref errCode);

        //        m_currCMD = (byte)'S';
        //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SolOnOffTime(pattern.speedValue.solOnTime, pattern.speedValue.solOffTime);
        //        if (retval.execResult != 0)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "SolOnOffTime ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        m_currCMD = (byte)'d';
        //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(pattern.speedValue.dwellTime);
        //        if (retval.execResult != 0)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "dwellTimeSet ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        if (currMarkInfo.checkdata.bReady == false)
        //        {
        //            CheckAreaData chkdata = new CheckAreaData();

        //            //#if LASER_YLR
        //            chkdata = await Range_Test("START TEXT", vin, currMarkInfo.currMarkData.pattern, 0, 0);
        //            //chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
        //            if (chkdata.execResult != 0)
        //            {
        //                log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
        //                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //                retval.execResult = chkdata.execResult;
        //                retval.sErrorMessage = chkdata.sErrorMessage;
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //                return retval;
        //            }
        //            //chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
        //            //if (chkdata.execResult != 0)
        //            //{
        //            //    //log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
        //            //    //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //            //    //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            //    //return;
        //            //    //string log = "";
        //            //    log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
        //            //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //            //    retval.execResult = chkdata.execResult;
        //            //    retval.sErrorMessage = chkdata.sErrorMessage;
        //            //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            //    return retval;
        //            //}
        //            //#else
        //            //                    //chkdata = await GetMarkPosition(currMarkInfo.currMarkData.pattern);
        //            //                    currMarkInfo.checkdata.NormalDir.X = currMarkInfo.checkdata.NormalDir.Y = 0.0;
        //            //                    currMarkInfo.checkdata.NormalDir.Z = 1.0;

        //            //                    chkdata = await GetMarkPosition(cmd, pattern, 0, 0);
        //            //                    if (chkdata.execResult != 0)
        //            //                    {
        //            //                        string log = "";
        //            //                        log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
        //            //                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //            //                        retval.execResult = chkdata.execResult;
        //            //                        retval.sErrorMessage = chkdata.sErrorMessage;
        //            //                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            //                        return retval;
        //            //                    }
        //            //#endif
        //            //chkdata = await Range_Test(cmd, vin, pattern, 0, 0);
        //            //if (chkdata.execResult != 0)
        //            //{
        //            //    return retval;
        //            //}
        //            //else
        //            currMarkInfo.checkdata = (CheckAreaData)chkdata.Clone();
        //        }

        //        ifontsizeX = (int)(fontsizeX + 0.5);
        //        ifontsizeY = (int)(fontsizeY + 0.5);
        //        ishiftVal = (int)(shiftVal + 0.5);

        //        CP = pattern.positionValue.center3DPos;
        //        CP.Z += pattern.headValue.distance0Position;
        //        cleanPosition = pattern.laserValue.cleanPosition;
        //        cleanPosition += CP.Z;         // Relative Cleanning postion

        //        SP0.X = totWidth / 2;
        //        SP0.Y = pattern.fontValue.height / 2;
        //        SP0.Z = 0;
        //        SP = CP - SP0;
        //        SP.Z = 0.0d;

        //        VectorNormal = currMarkInfo.checkdata.NormalDir;
        //        VectorRot.X = -VectorNormal.Y;
        //        VectorRot.Y = VectorNormal.X;
        //        VectorRot.Z = 0.0;

        //        double sqXY = Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y);
        //        //if (sqXY <= 0)
        //        //{
        //        //    VectorRot.X = 0;
        //        //    VectorRot.Y = 0;
        //        //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "sqXY is INVALID (" + sqXY.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //        //}
        //        if (sqXY != 0)
        //        {
        //            VectorRot.X /= sqXY;
        //            VectorRot.Y /= sqXY;
        //        }

        //        // Angle between VectorNormal to Z Axis ==> Rodrigues' Matrix
        //        bool skipRot = false;
        //        double cosValue = 0;
        //        if (VectorNormal.Length != 0)
        //            cosValue = VectorNormal.Z / VectorNormal.Length;

        //        double sinValue = Math.Sqrt(1.0d - cosValue * cosValue);

        //        if (cosValue > 0.9999986111)
        //        {      // 0.1 mm difference between 60mm
        //            skipRot = true;
        //            R11 = R12 = R13 = R21 = R22 = R23 = R31 = R32 = R33 = 0.0;
        //        }
        //        else
        //        {
        //            R11 = cosValue + VectorRot.X * VectorRot.X * (1.0 - cosValue);
        //            R12 = VectorRot.X * VectorRot.Y * (1.0 - cosValue) - VectorRot.Z * sinValue;
        //            R13 = VectorRot.X * VectorRot.Z * (1.0 - cosValue) + VectorRot.Y * sinValue;
        //            R21 = VectorRot.Y * VectorRot.X * (1.0 - cosValue) + VectorRot.Z * sinValue;
        //            R22 = cosValue + VectorRot.Y * VectorRot.Y * (1.0 - cosValue);
        //            R23 = VectorRot.Y * VectorRot.Z * (1.0 - cosValue) - VectorRot.X * sinValue;
        //            R31 = VectorRot.Z * VectorRot.X * (1.0 - cosValue) - VectorRot.Y * sinValue;
        //            R32 = VectorRot.Z * VectorRot.Y * (1.0 - cosValue) + VectorRot.X * sinValue;
        //            R33 = cosValue + VectorRot.Z * VectorRot.Z * (1.0 - cosValue);
        //        }
        //        /////
        //        Step_W = pattern.fontValue.width / (fontsizeX - 1.0);
        //        Step_H = pattern.fontValue.height / (fontsizeY - 1.0);

        //        FontData4Send[,,] RasterData = new FontData4Send[vinLength + 1, ifontsizeY, ifontsizeX];     // BLU
        //        FontData4Send[,,] AllClrData = new FontData4Send[vinLength + 1, ifontsizeY, ifontsizeX];

        //        currMarkInfo.senddata.sendDataFire.Clear();
        //        currMarkInfo.senddata.sendDataClean.Clear();

        //        //List<Vector3D> recvPoint = new List<Vector3D>();
        //        ImageProcessManager.GetStartPointLinear(vinLength, CP, SP, pattern.fontValue.pitch, pattern.fontValue.rotateAngle, ref Rev_Point);

        //        Vector3D[] LeftRightSP = new Vector3D[2];
        //        LeftRightSP[0] = ImageProcessManager.Rotate_Point2(SP.X - pattern.headValue.rasterSP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
        //        LeftRightSP[1] = ImageProcessManager.Rotate_Point2(SP.X + totWidth + pattern.headValue.rasterEP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
        //        List<FontDataClass> lineData = new List<FontDataClass>();
        //        List<FontDataClass> lineDataClean = new List<FontDataClass>();
        //        ImageProcessManager.GetFontDataOneEx('^', pattern.fontValue.fontName, headType, pattern.laserValue.density, 0, ref lineDataClean, out fontsizeX2, out fontsizeY2, out shiftVal2, out errCode);

        //        for (i = 0; i < Rev_Point.Count; i++)
        //        {
        //            if (vin.Substring(i, 1) != " ")      //Space Skip
        //            {
        //                //lineData = MyData[i];
        //                lineData = fontData[i];
        //                FontDataClass fd = new FontDataClass();
        //                for (j = 0; j < lineData.Count; j++)
        //                {
        //                    fd = (FontDataClass)lineData[j].Clone();
        //                    // ABS mm
        //                    M1.X = Rev_Point[i].X + fd.vector3d.X * Step_W;
        //                    M2.X = Rev_Point[i].X + Math.Round(fd.vector3d.X) * Step_W;

        //                    // Font offset compensation
        //                    M1.Y = Rev_Point[i].Y + fd.vector3d.Y * Step_H;
        //                    M2.Y = M1.Y;
        //                    M1.Z = M2.Z = SP.Z;

        //                    M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
        //                    M1.Z = SP.Z;
        //                    M2 = ImageProcessManager.Rotate_Point2(M2.X, M2.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
        //                    M2.Z = SP.Z;

        //                    // TM SHIN
        //                    M1.X -= CP.X; M1.Y -= CP.Y;
        //                    M2.X -= CP.X; M2.Y -= CP.Y;

        //                    M = (skipRot == true) ? M1 : getRodrigueRotation(M1);
        //                    C = (skipRot == true) ? M2 : getRodrigueRotation(M2);

        //                    M.X += CP.X; M.Y += CP.Y;
        //                    C.X += CP.X; C.Y += CP.Y;
        //                    double Mt = M.Z;
        //                    M.Z = Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ;
        //                    C.Z = Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ;         // Clean Axis

        //                    //Debug.WriteLine(String.Format("{0:D3} =>{1,7:F3},{2,7:F3},{3,7:F3}/{4,7:F3},{5,7:F3}", idx, M.X, M.Y, M.Z, C.X, C.Z));

        //                    // Change to BLU(Unit 0.01mm)
        //                    M = M * pattern.headValue.stepLength;
        //                    C = C * pattern.headValue.stepLength;
        //                    //M.X *= (double)Mode_File.Step_Length; M.Y *= (double)Mode_File.Step_Length; M.Z *= (double)Mode_File.Step_Length;
        //                    //C.X *= (double)Mode_File.Step_Length; C.Y *= (double)Mode_File.Step_Length; C.Z *= (double)Mode_File.Step_Length;

        //                    FontData4Send font4Send = new FontData4Send();

        //                    font4Send.cN = (byte)i; font4Send.fN = (byte)j;
        //                    font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); font4Send.mF = (byte)fd.Flag;
        //                    font4Send.mC = (UInt16)(C.Z + 0.5);
        //                    font4Send.mI = (UInt16)(C.X + 0.5);

        //                    if (pattern.laserValue.density == 1)
        //                    {
        //                        font4Send.mF = 0;
        //                        RasterData[i, (int)fd.vector3d.Y, (int)Math.Round(fd.vector3d.X)] = (FontData4Send)font4Send.Clone();
        //                        //Debug.WriteLine(String.Format("RASTER-({0},{1},{2}):{3}/{4}/{5}/{6}/{7}/{8}/{9}/{10}", i, (int)(fd.vector3d.Y - shiftVal), (int)Math.Round(fd.vector3d.X), font4Send.cN, font4Send.fN, font4Send.mC, font4Send.mF, font4Send.mI, font4Send.mX, font4Send.mY, font4Send.mZ));
        //                    }
        //                    else
        //                    {
        //                        var m_font = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mZ.ToString("X4") + font4Send.mF.ToString("X4");
        //                        currMarkInfo.senddata.sendDataFire.Add(m_font);
        //                        //var m_clean = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mC.ToString("X4") + font4Send.mF.ToString("X4");
        //                        //currMarkInfo.senddata.sendDataClean.Add(m_clean);
        //                    }

        //                    idx++;
        //                }


        //                idx = 0;

        //                lineData = fontData[i].ToList();
        //                if (pattern.laserValue.charClean == 0)
        //                    lineData = lineDataClean.ToList();
        //                //FontDataClass fdClean = new FontDataClass();
        //                fd.Clean();
        //                for (j = 0; j < lineData.Count; j++)
        //                {
        //                    fd = (FontDataClass)lineData[j].Clone();
        //                    // ABS mm
        //                    M1.X = Rev_Point[i].X + fd.vector3d.X * Step_W;
        //                    M2.X = Rev_Point[i].X + Math.Round(fd.vector3d.X) * Step_W;

        //                    // Font offset compensation
        //                    M1.Y = Rev_Point[i].Y + fd.vector3d.Y * Step_H;
        //                    //M1.Y = Rev_Point[i].Y + (fd.vector3d.Y - shiftVal) * Step_H;
        //                    M2.Y = M1.Y;
        //                    M1.Z = M2.Z = SP.Z;

        //                    M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
        //                    M1.Z = SP.Z;
        //                    M2 = ImageProcessManager.Rotate_Point2(M2.X, M2.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
        //                    M2.Z = SP.Z;

        //                    // TM SHIN
        //                    M1.X -= CP.X; M1.Y -= CP.Y;
        //                    M2.X -= CP.X; M2.Y -= CP.Y;

        //                    M = (skipRot == true) ? M1 : getRodrigueRotation(M1);
        //                    C = (skipRot == true) ? M2 : getRodrigueRotation(M2);

        //                    M.X += CP.X; M.Y += CP.Y;
        //                    C.X += CP.X; C.Y += CP.Y;
        //                    double Mt = M.Z;
        //                    M.Z = Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ;
        //                    C.Z = Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ;         // Clean Axis

        //                    //Debug.WriteLine(String.Format("{0:D3} =>{1,7:F3},{2,7:F3},{3,7:F3}/{4,7:F3},{5,7:F3}", idx, M.X, M.Y, M.Z, C.X, C.Z));

        //                    // Change to BLU(Unit 0.01mm)
        //                    M = M * pattern.headValue.stepLength;
        //                    C = C * pattern.headValue.stepLength;
        //                    //M.X *= (double)Mode_File.Step_Length; M.Y *= (double)Mode_File.Step_Length; M.Z *= (double)Mode_File.Step_Length;
        //                    //C.X *= (double)Mode_File.Step_Length; C.Y *= (double)Mode_File.Step_Length; C.Z *= (double)Mode_File.Step_Length;

        //                    FontData4Send font4Send = new FontData4Send();

        //                    font4Send.cN = (byte)i; font4Send.fN = (byte)j;
        //                    font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); font4Send.mF = (byte)fd.Flag;
        //                    font4Send.mC = (UInt16)(C.Z + 0.5);
        //                    font4Send.mI = (UInt16)(C.X + 0.5);

        //                    if (pattern.laserValue.density == 1)
        //                    {
        //                        font4Send.mF = 0;
        //                        AllClrData[i, (int)fd.vector3d.Y, (int)Math.Round(fd.vector3d.X)] = (FontData4Send)font4Send.Clone();
        //                        //AllClrData[i, (int)(fd.vector3d.Y - shiftVal), (int)Math.Round(fd.vector3d.X)] = (FontData4Send)font4Send.Clone();
        //                        //Debug.WriteLine(String.Format("RASTER-({0},{1},{2}):{3}/{4}/{5}/{6}/{7}/{8}/{9}/{10}", i, (int)(fd.vector3d.Y - shiftVal), (int)Math.Round(fd.vector3d.X), font4Send.cN, font4Send.fN, font4Send.mC, font4Send.mF, font4Send.mI, font4Send.mX, font4Send.mY, font4Send.mZ));
        //                    }
        //                    else
        //                    {
        //                        var m_clean = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mC.ToString("X4") + font4Send.mF.ToString("X4");
        //                        currMarkInfo.senddata.sendDataClean.Add(m_clean);
        //                        //var m_clean = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mC.ToString("X4") + font4Send.mF.ToString("X4");
        //                        //currMarkInfo.senddata.sendDataClean.Add(m_clean);
        //                    }

        //                    idx++;
        //                }
        //            }
        //        }





        //        //Debug.WriteLine("RASTER DATA");
        //        //for (i = 0; i < vin.Length; i++)
        //        //{
        //        //    for(j = 0; j < fontsizeY; j++)
        //        //        for(int k = 0; k < fontsizeX; k++)
        //        //            Debug.WriteLine(String.Format("RASTER[{0},{1},{2}] = {3},{4},{5},{6},{7}", i, j, k, RasterData[i, j, k].mX, RasterData[i, j, k].mY, RasterData[i, j, k].mZ, RasterData[i, j, k].mI, RasterData[i, j, k].mC));
        //        //}

        //        idx = 0;

        //        if (pattern.laserValue.density == 1)       // Dot Firing
        //        {
        //            // Calculate No of Dot point
        //            ushort[] NoPoints = new ushort[ifontsizeY];
        //            ushort[] NoPointsC = new ushort[ifontsizeY];

        //            for (int y = 0; y < ifontsizeY; y++)
        //            {
        //                for (i = 0; i < vinLength; i++)
        //                {
        //                    for (int x = 0; x < ifontsizeX; x++)
        //                    {
        //                        if (RasterData[i, y, x] != null)
        //                            NoPoints[y]++;         // Data Number of fire data
        //                    }
        //                }
        //            }


        //            ////
        //            Debug.WriteLine("");

        //            //
        //            // Make Jump/Start data
        //            for (i = 0; i < ifontsizeY; i++)
        //            {
        //                for (j = 0; j < 2; j++)         // Jump/Start XXXXX
        //                {
        //                    M1.X = LeftRightSP[j].X;
        //                    M1.Y = LeftRightSP[j].Y + (double)i * Step_H;
        //                    M1.Z = SP.Z;

        //                    M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, LeftRightSP[j].X, LeftRightSP[j].Y, pattern.fontValue.rotateAngle);// double.Parse(Angle));
        //                    M1.Z = SP.Z;

        //                    M1.X -= CP.X; M1.Y -= CP.Y;

        //                    M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

        //                    M.X += CP.X; M.Y += CP.Y;
        //                    double Mt = M.Z;
        //                    M.Z = Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ;       // Fire Z Axis
        //                    C.Z = Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ;         // Clean Z Axis
        //                    Debug.WriteLine(String.Format("J{0:D3}=>{1,7:F3},{2,7:F3},{3,7:F3}/{4,7:F3}", idx, M.X, M.Y, M.Z, C.Z));

        //                    // Change to BLU(Unit 0.01mm)
        //                    //M.X *= (double)Mode_File.Step_Length; M.Y *= (double)Mode_File.Step_Length; M.Z *= (double)Mode_File.Step_Length; C.Z *= (double)Mode_File.Step_Length;
        //                    M *= pattern.headValue.stepLength;
        //                    C.Z *= pattern.headValue.stepLength;

        //                    //M_FONT FontData = new M_FONT();
        //                    FontData4Send FontData = new FontData4Send();

        //                    FontData.cN = (byte)i; FontData.fN = (byte)j;
        //                    FontData.mX = (UInt16)(M.X + 0.5); FontData.mY = (UInt16)(M.Y + 0.5); FontData.mZ = (UInt16)(M.Z + 0.5);
        //                    FontData.mC = (UInt16)(C.Z + 0.5);
        //                    FontData.mI = 0;
        //                    FontData.mF = 0;

        //                    RasterData[vinLength, i, j] = FontData;

        //                    idx++;
        //                }
        //            }

        //            idx = 0;
        //            //
        //            for (int y = 0; y < ifontsizeY; y++)
        //                for (i = 0; i < vinLength; i++)
        //                    for (int x = 0; x < ifontsizeX; x++)
        //                        if (AllClrData[i, y, x] != null)
        //                            NoPointsC[y]++;    // Data Number of clean data
        //                                               //
        //            if (pattern.headValue.spatterType == 0)  // 0 : Back
        //            {
        //                //
        //                // Make Firing & cleanning Data for back spatter at 0 degree
        //                if (pattern.fontValue.rotateAngle == 0.0)
        //                {
        //                    if (pattern.laserValue.combineFireClean != 0)
        //                    {
        //                        //
        //                        // Make firing | clean Data for 0 degree, back spatter [1FC]
        //                        StringBuilder sb = new StringBuilder();
        //                        ushort x2 = 0, y2 = 0, c2 = 0;

        //                        bool DirRight = true;
        //                        for (int y = 0; y < ifontsizeY; y++)
        //                        {
        //                            if (DirRight == true)
        //                            {   // Fire Data string
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y]);
        //                                for (i = 0; i < vinLength; i++)
        //                                    for (int x = 0; x < ifontsizeX; x++)
        //                                        if (RasterData[i, y, x] != null)
        //                                            sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                                currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                                //Mode_File.SendData.Add(sb.ToString());
        //                                //Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                sb.Length = 0;
        //                            }
        //                            else
        //                            {   // Fire Data string
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y]);
        //                                for (i = vinLength - 1; i >= 0; i--)
        //                                    for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        if (RasterData[i, y, x] != null)
        //                                            sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                                currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                                //Mode_File.SendData.Add(sb.ToString());
        //                                //Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                sb.Length = 0;
        //                            }
        //                            DirRight = !DirRight;

        //                            //
        //                            //  Make Cleaning Data for 0 degree, back spatter [1C]
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == false)
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                                    //Mode_File.SendData.Add(sb.ToString());
        //                                    //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                                    //Mode_File.SendData.Add(sb.ToString());
        //                                    //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            }   // NoPointsC
        //                            else
        //                            {
        //                                currMarkInfo.checkdata.TwoLineDisplay = false;
        //                            }
        //                        }
        //                    }
        //                    else  // Fire & Clean
        //                    {
        //                        //
        //                        // Make firing Data for 0 degree, back spatter [1F]
        //                        StringBuilder sb = new StringBuilder();
        //                        bool DirRight = true;
        //                        for (int y = 0; y < ifontsizeY; y++)
        //                        {
        //                            if (DirRight == true)
        //                            {   // Fire Data string
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y]);
        //                                for (i = 0; i < vinLength; i++)
        //                                    for (int x = 0; x < ifontsizeX; x++)
        //                                        if (RasterData[i, y, x] != null)
        //                                            sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                                currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                                //Mode_File.SendData.Add(sb.ToString());
        //                                Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                sb.Length = 0;
        //                            }
        //                            else
        //                            {   // Fire Data string
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
        //                                sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y]);
        //                                for (i = vinLength - 1; i >= 0; i--)
        //                                    for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        if (RasterData[i, y, x] != null)
        //                                            sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                                currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                                //Mode_File.SendData.Add(sb.ToString());
        //                                Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                sb.Length = 0;
        //                            }
        //                            DirRight = !DirRight;
        //                        }

        //                        //
        //                        //  Make Cleaning Data for 0 degree, back spatter [1C]
        //                        sb = new StringBuilder();
        //                        ushort x2 = 0, y2 = 0, c2 = 0;

        //                        if (ifontsizeY > 10)  // Y Font Size > 10
        //                        {
        //                            currMarkInfo.checkdata.TwoLineDisplay = true;
        //                            for (int y = ifontsizeY - 1; y >= 0; y--)
        //                            {
        //                                if (NoPointsC[y] > 0)
        //                                {
        //                                    if (DirRight == false)
        //                                    {
        //                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                        y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                        y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                        for (i = vinLength - 1; i >= 0; i--)
        //                                            for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                            {
        //                                                if (AllClrData[i, y, x] != null)
        //                                                {
        //                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                                }
        //                                            }
        //                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                        //Mode_File.SendClean.Add(sb.ToString());
        //                                        //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                        sb.Length = 0;
        //                                    }
        //                                    else
        //                                    {
        //                                        x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                        y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                        y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                        c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                        x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                        y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                        y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                        c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                        for (i = 0; i < vinLength; i++)
        //                                            for (int x = 0; x < ifontsizeX; x++)
        //                                            {
        //                                                if (AllClrData[i, y, x] != null)
        //                                                {
        //                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                                }
        //                                            }
        //                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                        //Mode_File.SendClean.Add(sb.ToString());
        //                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                        sb.Length = 0;
        //                                    }
        //                                    DirRight = !DirRight;
        //                                }   // NoPointsC
        //                                else
        //                                {
        //                                    currMarkInfo.checkdata.TwoLineDisplay = false;
        //                                }
        //                            }
        //                        }
        //                        else  // Y Font Size <= 10
        //                        {
        //                            currMarkInfo.checkdata.TwoLineDisplay = false;
        //                            for (int y = ifontsizeY - 1; y >= 0; y--)
        //                            {
        //                                if (NoPointsC[y] > 0)
        //                                {
        //                                    if (DirRight == false)
        //                                    {
        //                                        x2 = (ushort)RasterData[vinLength, y, 1].mX;
        //                                        y2 = (ushort)RasterData[vinLength, y, 1].mY;
        //                                        //y2 += CDelta;
        //                                        c2 = (ushort)RasterData[vinLength, y, 1].mC;
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                        x2 = (ushort)RasterData[vinLength, y, 0].mX;
        //                                        y2 = (ushort)RasterData[vinLength, y, 0].mY;
        //                                        //y2 += CDelta;
        //                                        c2 = (ushort)RasterData[vinLength, y, 0].mC;
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                        for (i = vinLength - 1; i >= 0; i--)
        //                                            for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                            {
        //                                                if (AllClrData[i, y, x] != null)
        //                                                {
        //                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                                }
        //                                            }
        //                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                        //Mode_File.SendClean.Add(sb.ToString());
        //                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                        sb.Length = 0;
        //                                    }
        //                                    else
        //                                    {
        //                                        x2 = (ushort)RasterData[vinLength, y, 0].mX;
        //                                        y2 = (ushort)RasterData[vinLength, y, 0].mY;
        //                                        //y2 += CDelta;
        //                                        c2 = (ushort)RasterData[vinLength, y, 0].mC;
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                        x2 = (ushort)RasterData[vinLength, y, 1].mX;
        //                                        y2 = (ushort)RasterData[vinLength, y, 1].mY;
        //                                        //y2 += CDelta;
        //                                        c2 = (ushort)RasterData[vinLength, y, 1].mC;
        //                                        sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                        for (i = 0; i < vinLength; i++)
        //                                            for (int x = 0; x < ifontsizeX; x++)
        //                                            {
        //                                                if (AllClrData[i, y, x] != null)
        //                                                {
        //                                                    sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                                }
        //                                            }
        //                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                        //Mode_File.SendClean.Add(sb.ToString());
        //                                        Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                        sb.Length = 0;
        //                                    }
        //                                    DirRight = !DirRight;

        //                                }   // NoPointsC
        //                            }
        //                        }
        //                    } // CombineFireClean if-else
        //                }
        //                else
        //                {
        //                    // 
        //                    // Make firing data at 180 degree for back spatter [2F]
        //                    StringBuilder sb = new StringBuilder();
        //                    bool DirRight = true;
        //                    for (int y = ifontsizeY - 1; y >= 0; y--)
        //                    {
        //                        if (DirRight == false)
        //                        {   // Fire Data string
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y]);
        //                            for (i = vinLength - 1; i >= 0; i--)
        //                                for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                    if (RasterData[i, y, x] != null)
        //                                        sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                            currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                            //Mode_File.SendData.Add(sb.ToString());
        //                            //Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                            sb.Length = 0;
        //                        }
        //                        else
        //                        {   // Fire Data string
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y]);
        //                            for (i = 0; i < vinLength; i++)
        //                                for (int x = 0; x < ifontsizeX; x++)
        //                                    if (RasterData[i, y, x] != null)
        //                                        sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                            currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                            //Mode_File.SendData.Add(sb.ToString());
        //                            Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                            sb.Length = 0;
        //                        }
        //                        DirRight = !DirRight;
        //                    }

        //                    //
        //                    //  Make Cleaning Data for 180 degree, back spatter [2C]
        //                    sb = new StringBuilder();
        //                    ushort x2 = 0, y2 = 0, c2 = 0;
        //                    if (ifontsizeY > 10)  // Y Font Size > 10
        //                    {
        //                        currMarkInfo.checkdata.TwoLineDisplay = false;
        //                        for (int y = 0; y < ifontsizeY; y++)
        //                        {
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == false)
        //                                {
        //                                    x2 = (ushort)RasterData[vinLength, y, 1].mX;
        //                                    y2 = (ushort)RasterData[vinLength, y, 1].mY;
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)RasterData[vinLength, y, 1].mC;
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)RasterData[vinLength, y, 0].mX;
        //                                    y2 = (ushort)RasterData[vinLength, y, 0].mY;
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)RasterData[vinLength, y, 0].mC;
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 += (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            } //
        //                            else
        //                            {
        //                                currMarkInfo.checkdata.TwoLineDisplay = true;
        //                            }
        //                        }
        //                    }
        //                    else  // Y Font Size <= 10
        //                    {
        //                        currMarkInfo.checkdata.TwoLineDisplay = false;
        //                        for (int y = 0; y < ifontsizeY; y++)
        //                        {
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == false)
        //                                {
        //                                    x2 = (ushort)RasterData[vinLength, y, 1].mX;
        //                                    y2 = (ushort)RasterData[vinLength, y, 1].mY;
        //                                    //y2 += CDelta;
        //                                    c2 = (ushort)RasterData[vinLength, y, 1].mC;
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)RasterData[vinLength, y, 0].mX;
        //                                    y2 = (ushort)RasterData[vinLength, y, 0].mY;
        //                                    //y2 += CDelta;
        //                                    c2 = (ushort)RasterData[vinLength, y, 0].mC;
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    //y2 += CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    //y2 += CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    //Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            } //
        //                        }
        //                    }
        //                }   // Back spatter
        //            }
        //            else    // Front spatter
        //            {
        //                //
        //                // Make Firing & cleanning Data for front spatter at 0 degree
        //                if (pattern.fontValue.rotateAngle == 0.0)
        //                {
        //                    //
        //                    // Make firing Data for 0 degree, front spatter [3F]
        //                    StringBuilder sb = new StringBuilder();
        //                    bool DirRight = true;
        //                    for (int y = ifontsizeY - 1; y >= 0; y--)
        //                    {
        //                        if (DirRight == true)
        //                        {   // Fire Data string for even line ->
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y]);
        //                            for (i = 0; i < vinLength; i++)
        //                                for (int x = 0; x < ifontsizeX; x++)
        //                                    if (RasterData[i, y, x] != null)
        //                                        sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                            currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                            //Mode_File.SendData.Add(sb.ToString());
        //                            Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                            sb.Length = 0;
        //                        }
        //                        else
        //                        {   // Fire Data string for odd line <-
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y]);
        //                            for (i = vinLength - 1; i >= 0; i--)
        //                                for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                    if (RasterData[i, y, x] != null)
        //                                        sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                            currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                            //Mode_File.SendData.Add(sb.ToString());
        //                            Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                            sb.Length = 0;
        //                        }
        //                        DirRight = !DirRight;
        //                    }

        //                    //
        //                    //  Make Cleaning Data for 0 degree, front spatter [3C]
        //                    sb = new StringBuilder();
        //                    ushort x2 = 0, y2 = 0, c2 = 0;

        //                    if (ifontsizeY > 10)  // Y Font Size > 10
        //                    {
        //                        currMarkInfo.checkdata.TwoLineDisplay = false;
        //                        for (int y = 0; y < ifontsizeY; y++)
        //                        {
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == false)
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            }
        //                            else
        //                            {
        //                                currMarkInfo.checkdata.TwoLineDisplay = true;
        //                            }
        //                        }
        //                    }
        //                    else  // Y Font Size <= 10
        //                    {
        //                        currMarkInfo.checkdata.TwoLineDisplay = false;
        //                        for (int y = 0; y < ifontsizeY; y++)
        //                        {
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == false)
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            }
        //                        }
        //                    }
        //                }
        //                else
        //                {
        //                    // 
        //                    // Make firing data at 180 degree for front spatter [4F]
        //                    StringBuilder sb = new StringBuilder();
        //                    bool DirRight = true;
        //                    for (int y = 0; y < ifontsizeY; y++)
        //                    {
        //                        if (DirRight == false) // odd line <-
        //                        {   // Fire Data string
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, (ushort)y);
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, NoPoints[y]);
        //                            for (i = vinLength - 1; i >= 0; i--)
        //                                for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                    if (RasterData[i, y, x] != null)
        //                                        sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                            currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                            //Mode_File.SendData.Add(sb.ToString());
        //                            Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                            sb.Length = 0;
        //                        }
        //                        else
        //                        {   // Fire Data string even line ->
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', RasterData[vinLength, y, 0].mX, RasterData[vinLength, y, 0].mY, RasterData[vinLength, y, 0].mZ, (ushort)y);
        //                            sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', RasterData[vinLength, y, 1].mX, RasterData[vinLength, y, 1].mY, RasterData[vinLength, y, 1].mZ, NoPoints[y]);
        //                            for (i = 0; i < vinLength; i++)
        //                                for (int x = 0; x < ifontsizeX; x++)
        //                                    if (RasterData[i, y, x] != null)
        //                                        sb.AppendFormat("{0:X4}", RasterData[i, y, x].mX);
        //                            currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
        //                            //Mode_File.SendData.Add(sb.ToString());
        //                            Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                            sb.Length = 0;
        //                        }
        //                        DirRight = !DirRight;
        //                    }

        //                    //
        //                    //  Make Cleaning Data for 180 degree, front spatter [4C]
        //                    sb = new StringBuilder();
        //                    ushort x2 = 0, y2 = 0, c2 = 0;
        //                    if (ifontsizeY > 10)  // Y Font Size > 10
        //                    {
        //                        currMarkInfo.checkdata.TwoLineDisplay = false;
        //                        for (int y = ifontsizeY - 1; y >= 0; y--)
        //                        {
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == true)
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    y2 -= (ushort)pattern.laserValue.cleanDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            }
        //                            else
        //                            {
        //                                currMarkInfo.checkdata.TwoLineDisplay = true;
        //                            }
        //                        }
        //                    }
        //                    else  // Y Font Size <= 10
        //                    {
        //                        currMarkInfo.checkdata.TwoLineDisplay = false;
        //                        for (int y = ifontsizeY - 1; y >= 0; y--)
        //                        {
        //                            if (NoPointsC[y] > 0)
        //                            {
        //                                if (DirRight == true)
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = 0; i < vinLength; i++)
        //                                        for (int x = 0; x < ifontsizeX; x++)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                else
        //                                {
        //                                    x2 = (ushort)(RasterData[vinLength, y, 1].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 1].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 1].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'J', x2, y2, c2, (ushort)y);
        //                                    x2 = (ushort)(RasterData[vinLength, y, 0].mX);
        //                                    y2 = (ushort)(RasterData[vinLength, y, 0].mY);
        //                                    //y2 -= CDelta;
        //                                    c2 = (ushort)(RasterData[vinLength, y, 0].mC);
        //                                    sb.AppendFormat("{0:X4}{1:X4}{2:X4}{3:X4}{4:X4}", (ushort)'S', x2, y2, c2, NoPointsC[y]);

        //                                    for (i = vinLength - 1; i >= 0; i--)
        //                                        for (int x = ifontsizeX - 1; x >= 0; x--)
        //                                        {
        //                                            if (AllClrData[i, y, x] != null)
        //                                            {
        //                                                sb.AppendFormat("{0:X4}", AllClrData[i, y, x].mI);
        //                                            }
        //                                        }
        //                                    currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
        //                                    //Mode_File.SendClean.Add(sb.ToString());
        //                                    Debug.WriteLine(y.ToString("00") + "C" + NoPointsC[y].ToString("000") + ":" + sb.ToString());
        //                                    sb.Length = 0;
        //                                }
        //                                DirRight = !DirRight;
        //                            }
        //                        }
        //                    }
        //                }   // front spatter
        //                if (pattern.laserValue.charClean != 0)
        //                {
        //                    currMarkInfo.checkdata.TwoLineDisplay = false;
        //                }
        //            }   // Back/front spatter
        //        }   // Dot firing
        //        currMarkInfo.checkdata.TwoLineDisplay = true;

        //        return retval;
        //    }
        //    catch (Exception ex)
        //    {
        //        retval.execResult = ex.HResult;
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //        return retval;
        //    }


        //    //
        //    // Make firing/cleanning data
        //    //

        //    // Local function

        //    Vector3D getRodrigueRotation(Vector3D XY0)
        //    {
        //        Vector3D Tmp = new Vector3D();
        //        Tmp.X = XY0.X * R11 + XY0.Y * R12 + XY0.Z * R13;
        //        Tmp.Y = XY0.X * R21 + XY0.Y * R22 + XY0.Z * R23;
        //        Tmp.Z = XY0.X * R31 + XY0.Y * R32 + XY0.Z * R33;

        //        return Tmp;
        //    }

        //}

        public async Task<ITNTResponseArgs> Start_DOTMISSING(string cmd, string vin, PatternValueEx pattern, List<string> DotMiss)    // Making Dot Missing data by TM SHIN
        {
            string className = "SetControllerWindow3";
            string funcName = "Start_DOTMISSING";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            int vinLength = 0;

            Vector3D SP0 = new Vector3D();
            Vector3D SP = new Vector3D();
            Vector3D CP = new Vector3D();

            Vector3D VectorNormal = new Vector3D();
            Vector3D VectorRot = new Vector3D();
            List<Vector3D> Rev_Point = new List<Vector3D>();

            double Step_W;
            double Step_H;
            string value = "";
            byte headType = 0;
            VinNoInfo vininfo = new VinNoInfo();
            //List<List<FontDataClass>> MyData = new List<List<FontDataClass>>();
            List<List<FontDataClass>> fontData = new List<List<FontDataClass>>();
            double fontsizeX = 0, fontsizeY = 0, shiftVal = 0;
            double fontsizeX2 = 0, fontsizeY2 = 0, shiftVal2 = 0;
            double cleanPosition = 0;
            string errCode = "";
            double totWidth = 0;
            double R11, R12, R13, R21, R22, R23, R31, R32, R33;
            int i, j;
            int idx = 0;
            int ifontsizeX = 0, ifontsizeY = 0, ishiftVal = 0;

            Vector3D M1 = new Vector3D();                                   // for fire data mm
            Vector3D M2 = new Vector3D();                                   // for clean data mm
            Vector3D M = new Vector3D();
            Vector3D C = new Vector3D();

            try
            {
                vinLength = vin.Length;
                if (vinLength <= 0)
                {
                    retval.execResult = -1;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "VIN LENGTH IS INVALID (" + vinLength.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out headType);

                vininfo.vinNo = vin;
                vininfo.fontName = pattern.fontValue.fontName;
                vininfo.width = pattern.fontValue.width;
                vininfo.height = pattern.fontValue.height;
                vininfo.pitch = pattern.fontValue.pitch;
                vininfo.thickness = pattern.fontValue.thickness;
                ImageProcessManager.GetFontDataEx(vininfo, headType, pattern.laserValue.density, 0, ref fontData, ref fontsizeX, ref fontsizeY, ref shiftVal, ref errCode);

                m_currCMD = (byte)'S';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SolOnOffTime(pattern.speedValue.solOnTime, pattern.speedValue.solOffTime);
                if (retval.execResult != 0)
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "SolOnOffTime ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                m_currCMD = (byte)'d';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(pattern.speedValue.dwellTime);
                if (retval.execResult != 0)
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "dwellTimeSet ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                if (currMarkInfo.checkdata.bReady == false)
                {
                    CheckAreaData chkdata = new CheckAreaData();

                    //#if LASER_YLR
                    chkdata = await Range_Test("START DO MISSING", vin, currMarkInfo.currMarkData.pattern, 0, 0);
                    //chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
                    if (chkdata.execResult != 0)
                    {
                        string log = "";
                        log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        retval.execResult = chkdata.execResult;
                        retval.errorInfo.sErrorMessage = chkdata.errorInfo.sErrorMessage;
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return retval;
                    }
                    //chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
                    //if (chkdata.execResult != 0)
                    //{
                    //    log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                    //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //    return;
                    //}
//#else
//                    currMarkInfo.checkdata.NormalDir.X = currMarkInfo.checkdata.NormalDir.Y = 0.0;
//                    currMarkInfo.checkdata.NormalDir.Z = 1.0;

//                    chkdata = await GetMarkPosition(cmd, pattern, 0, 0);
//                    if (chkdata.execResult != 0)
//                    {
//                        string log = "";
//                        log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        retval.execResult = chkdata.execResult;
//                        retval.sErrorMessage = chkdata.sErrorMessage;
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        return retval;
//                    }
//#endif
                    //chkdata = await Range_Test(cmd, vin, pattern, 0, 0);
                    //if (chkdata.execResult != 0)
                    //{
                    //    return retval;
                    //}
                    //else
                        currMarkInfo.checkdata = (CheckAreaData)chkdata.Clone();
                }

                ifontsizeX = (int)(fontsizeX + 0.5);
                ifontsizeY = (int)(fontsizeY + 0.5);
                ishiftVal = (int)(shiftVal + 0.5);

                CP = pattern.positionValue.center3DPos;
                CP.Z += pattern.headValue.distance0Position;
                cleanPosition = pattern.laserValue.cleanPosition;
                if (cleanPosition < CP.Z) cleanPosition = CP.Z;
                //cleanPosition += CP.Z;         // Relative Cleanning postion

                SP0.X = totWidth / 2;
                SP0.Y = pattern.fontValue.height / 2;
                SP0.Z = 0;
                SP = CP - SP0;
                SP.Z = 0.0d;

                VectorNormal = currMarkInfo.checkdata.NormalDir;
                VectorRot.X = -VectorNormal.Y;
                VectorRot.Y = VectorNormal.X;
                VectorRot.Z = 0.0;

                double sqXY = Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y);

                if (sqXY != 0)
                {
                    VectorRot.X /= sqXY;
                    VectorRot.Y /= sqXY;
                }

                // Angle between VectorNormal to Z Axis ==> Rodrigues' Matrix
                bool skipRot = false;
                double cosValue = 0;
                if (VectorNormal.Length != 0)
                    cosValue = VectorNormal.Z / VectorNormal.Length;

                double sinValue = Math.Sqrt(1.0d - cosValue * cosValue);
                if (cosValue > 0.9999986111)
                {      // 0.1 mm difference between 60mm
                    skipRot = true;
                    R11 = R12 = R13 = R21 = R22 = R23 = R31 = R32 = R33 = 0.0;
                    R11 = R22 = R33 = 1.0;
                }
                else
                {
                    R11 = cosValue + VectorRot.X * VectorRot.X * (1.0 - cosValue);
                    R12 = VectorRot.X * VectorRot.Y * (1.0 - cosValue) - VectorRot.Z * sinValue;
                    R13 = VectorRot.X * VectorRot.Z * (1.0 - cosValue) + VectorRot.Y * sinValue;
                    R21 = VectorRot.Y * VectorRot.X * (1.0 - cosValue) + VectorRot.Z * sinValue;
                    R22 = cosValue + VectorRot.Y * VectorRot.Y * (1.0 - cosValue);
                    R23 = VectorRot.Y * VectorRot.Z * (1.0 - cosValue) - VectorRot.X * sinValue;
                    R31 = VectorRot.Z * VectorRot.X * (1.0 - cosValue) - VectorRot.Y * sinValue;
                    R32 = VectorRot.Z * VectorRot.Y * (1.0 - cosValue) + VectorRot.X * sinValue;
                    R33 = cosValue + VectorRot.Z * VectorRot.Z * (1.0 - cosValue);
                }
                /////
                Step_W = pattern.fontValue.width / (fontsizeX - 1.0);
                Step_H = pattern.fontValue.height / (fontsizeY - 1.0);

                FontData4Send[,,] RasterData = new FontData4Send[vinLength + 1, ifontsizeY, ifontsizeX];     // BLU
                FontData4Send[,,] AllClrData = new FontData4Send[vinLength + 1, ifontsizeY, ifontsizeX];

                currMarkInfo.senddata.sendDataFire.Clear();
                currMarkInfo.senddata.sendDataClean.Clear();

                //List<Vector3D> recvPoint = new List<Vector3D>();
                ImageProcessManager.GetStartPointLinear(vinLength, CP, SP, pattern.fontValue.pitch, pattern.fontValue.rotateAngle, ref Rev_Point);

                Vector3D[] LeftRightSP = new Vector3D[2];
                LeftRightSP[0] = ImageProcessManager.Rotate_Point2(SP.X - pattern.headValue.rasterSP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
                LeftRightSP[1] = ImageProcessManager.Rotate_Point2(SP.X + totWidth + pattern.headValue.rasterEP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
                List<FontDataClass> lineData = new List<FontDataClass>();
                List<FontDataClass> lineDataClean = new List<FontDataClass>();
                ImageProcessManager.GetFontDataOneEx('^', pattern.fontValue.fontName, headType, pattern.laserValue.density, 0, ref lineDataClean, out fontsizeX2, out fontsizeY2, out shiftVal2, out errCode);


                for (i = 0; i < Rev_Point.Count; i++)
                {
                    if (vin.Substring(i, 1) != " ")      //Space Skip
                    {
                        lineData = fontData[i];
                        FontDataClass fd = new FontDataClass();

                        //xy_Temp = (Mode_File.FONT_[Strings.Asc(DATA_.Substring(i, 1))]).Split(';');
                        //string[] xy_Data = new string[0];
                        List<FontDataClass> dotlist = new List<FontDataClass>();
                        //var xy_List = new List<string>();

                        var dmStr = new string[0];
                        if (DotMiss != null)
                        {
                            dmStr = DotMiss[i].Substring(2).Split(',');
                            if (dmStr.Length > 0)
                            {
                                if (Int32.Parse(dmStr[0]) == -1) continue;
                                else
                                {
                                    for (int n = 0; n < dmStr.Length - 1; n++)
                                    {
                                        fd = (FontDataClass)lineData[Int32.Parse(dmStr[n])].Clone();
                                        dotlist.Add(fd);
                                        //xy_List.Add(lineData[Int32.Parse(dmStr[n])]);
                                    }
                                    //xy_Data = xy_List.ToArray();
                                    //xy_List.Clear();
                                }
                            }
                        }

                        for (j = 0; j < dotlist.Count; j++)
                        {
                            fd = (FontDataClass)dotlist[j].Clone();
                            // ABS mm
                            M1.X = Rev_Point[i].X + fd.vector3d.X * Step_W;
                            // Font offset compensation
                            M1.Y = Rev_Point[i].Y + fd.vector3d.Y * Step_H;
                            M1.Z = SP.Z;

                            //M1 = Mode_File.Rotate_Point(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, double.Parse(Angle));
                            M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
                            M1.Z = SP.Z;

                            // TM SHIN
                            M1.X -= CP.X; M1.Y -= CP.Y;

                            M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

                            M.X += CP.X; M.Y += CP.Y;
                            double Mt = M.Z;
                            M.Z = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight;
                            //M.Z = Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ;
                            double Cz = 0.0;
                            Cz = (currMarkInfo.currMarkData.pattern.headValue.bySkipPlateCheck == 0) ? Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ : currMarkInfo.currMarkData.pattern.positionValue.teachingZHeight+cleanPosition;
                            //Cz = Mt + cleanPosition + currMarkInfo.checkdata.PlaneCenterZ;         // Clean Axis

                            Debug.WriteLine(String.Format("{0:D3} =>{1,7:F3},{2,7:F3},{3,7:F3}/{4,7:F3}", idx, M.X, M.Y, M.Z, Cz));

                            // Change to BLU(Unit 0.01mm)
                            //M.X *= (double)Mode_File.Step_Length; M.Y *= (double)Mode_File.Step_Length; M.Z *= (double)Mode_File.Step_Length;
                            //Cz *= (double)Mode_File.Step_Length;

                            M = M * pattern.headValue.stepLength;
                            Cz = Cz * pattern.headValue.stepLength;

                            FontData4Send font4Send = new FontData4Send();

                            font4Send.cN = (byte)i; font4Send.fN = (byte)int.Parse(dmStr[j]);
                            font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); font4Send.mF = (byte)fd.Flag;
                            font4Send.mC = (UInt16)(Cz + 0.5);
                            font4Send.mI = (UInt16)(fd.vector3d.X + 0.5);

                            //M_FONT FontData = new M_FONT();

                            //FontData.cN = (byte)i;
                            //FontData.fN = (byte)int.Parse(dmStr[j]);
                            //FontData.mX = (UInt16)(M.X + 0.5); FontData.mY = (UInt16)(M.Y + 0.5); FontData.mZ = (UInt16)(M.Z + 0.5); FontData.mF = byte.Parse(xy_[2]);
                            //FontData.mC = (UInt16)(Cz + 0.5);
                            //FontData.mI = double.Parse(xy_[0]);

                            if (pattern.laserValue.density == 1)
                            {
                                //FontData.mF = 0;
                                font4Send.mF = 0;
                                RasterData[i, (int)(fd.vector3d.Y - ishiftVal), (int)(fd.vector3d.X + 0.5)] = font4Send;
                            }
                            else
                            {
                                var m_font = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mZ.ToString("X4") + font4Send.mF.ToString("X4");
                                currMarkInfo.senddata.sendDataFire.Add(m_font);
                                //Mode_File.SendData.Add(m_font);
                                var m_clean = font4Send.cN.ToString("X2") + font4Send.fN.ToString("X2") + font4Send.mX.ToString("X4") + font4Send.mY.ToString("X4") + font4Send.mC.ToString("X4") + font4Send.mF.ToString("X4");
                                currMarkInfo.senddata.sendDataClean.Add(m_clean);
                                //Mode_File.SendClean.Add(m_clean);
                            }

                            idx++;
                        }
                    }
                }

                if (pattern.laserValue.density == 1)       // Dot Firing
                {
                    ushort[] NoPoints = new ushort[ifontsizeY];

                    for (int y = 0; y < ifontsizeY; y++)
                    {
                        for (i = 0; i < vinLength; i++)
                        {
                            for (int x = 0; x < ifontsizeX; x++)
                            {
                                if (RasterData[i, y, x] != null) NoPoints[y]++;         // Data Number of fire data
                            }
                        }
                    }

                    //
                    Debug.WriteLine("");

                    //
                    // Make Firing Data for dot missing
                    if (pattern.fontValue.rotateAngle == 0.0)
                    {           // 0 degree
                        StringBuilder sb = new StringBuilder();
                        for (i = 0; i < vinLength; i++)
                        {
                            // Fire Data string
                            for (int y = 0; y < ifontsizeY; y++)
                                for (int x = 0; x < ifontsizeX; x++)
                                    if (RasterData[i, y, x] != null)
                                    {
                                        sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mZ, RasterData[i, y, x].mF);
                                        Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
                                        currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                        sb.Clear();
                                        //Mode_File.SendData.Add(sb.ToString()); sb.Clear();
                                    }
                        }

                        //
                        //  Make Cleaning Data
                        sb = new StringBuilder();
                        for (i = vinLength - 1; i >= 0; i--)
                        {
                            for (int y = ifontsizeY - 1; y >= 0; y--)
                                for (int x = ifontsizeX - 1; x >= 0; x--)
                                    if (RasterData[i, y, x] != null)
                                    {
                                        sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mC, RasterData[i, y, x].mF);
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPoints[y].ToString("000") + ":" + sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        sb.Clear();
                                        //Mode_File.SendClean.Add(sb.ToString()); sb.Clear();
                                    }
                        }
                    }
                    else
                    {       // 180 degree
                        StringBuilder sb = new StringBuilder();
                        for (i = vinLength - 1; i >= 0; i--)
                        {
                            // Fire Data string
                            for (int y = ifontsizeY - 1; y >= 0; y--)
                                for (int x = ifontsizeX - 1; x >= 0; x--)
                                    if (RasterData[i, y, x] != null)
                                    {
                                        sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mZ, RasterData[i, y, x].mF);
                                        Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
                                        currMarkInfo.senddata.sendDataFire.Add(sb.ToString());
                                        sb.Clear();
                                        //Mode_File.SendData.Add(sb.ToString()); sb.Clear();
                                    }
                        }

                        //
                        //  Make Cleaning Data
                        sb = new StringBuilder();
                        for (i = 0; i < vinLength; i++)
                        {
                            for (int y = 0; y < ifontsizeY; y++)
                                for (int x = 0; x < ifontsizeX; x++)
                                    if (RasterData[i, y, x] != null)
                                    {
                                        sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mC, RasterData[i, y, x].mF);
                                        Debug.WriteLine(y.ToString("00") + "C" + NoPoints[y].ToString("000") + ":" + sb.ToString());
                                        currMarkInfo.senddata.sendDataClean.Add(sb.ToString());
                                        sb.Clear();
                                        //Mode_File.SendClean.Add(sb.ToString()); sb.Clear();
                                    }
                        }
                    }
                }

                //M_Count = idx;
                //Mark_Counter++;

                //Mode_File.Download_Data = true;



                //M_Count = idx;
                ////Mark_Counter++;

                //Mode_File.Download_Data = true;

                return retval;

                Vector3D getRodrigueRotation(Vector3D XY0)
                {
                    Vector3D Tmp = new Vector3D();
                    Tmp.X = XY0.X * R11 + XY0.Y * R12 + XY0.Z * R13;
                    Tmp.Y = XY0.X * R21 + XY0.Y * R22 + XY0.Z * R23;
                    Tmp.Z = XY0.X * R31 + XY0.Y * R32 + XY0.Z * R33;

                    return Tmp;
                }
            }
            catch (Exception ex)
            {
                retval.execResult = ex.HResult;
                //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return retval;
            }
        }

        //public async Task<ITNTResponseArgs> Start_DOTMISSING(string cmd, string vin, PatternValueEx pattern, List<string> DotMiss)    // Making Dot Missing data by TM SHIN
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "Start_DOTMISSING";

        //    ITNTResponseArgs retval = new ITNTResponseArgs();
        //    int vinLength = 0;

        //    Vector3D SP0 = new Vector3D();
        //    Vector3D SP = new Vector3D();
        //    Vector3D CP = new Vector3D();

        //    Vector3D VectorNormal = new Vector3D();
        //    Vector3D VectorRot = new Vector3D();
        //    List<Vector3D> Rev_Point = new List<Vector3D>();

        //    double Step_W;
        //    double Step_H;
        //    string value = "";
        //    byte headType = 0;
        //    VinNoInfo vininfo = new VinNoInfo();
        //    //List<List<FontDataClass>> MyData = new List<List<FontDataClass>>();
        //    List<List<FontDataClass>> fontData = new List<List<FontDataClass>>();
        //    double fontsizeX = 0, fontsizeY = 0, shiftVal = 0;
        //    double fontsizeX2 = 0, fontsizeY2 = 0, shiftVal2 = 0;
        //    double cleanPosition = 0;
        //    string errCode = "";
        //    double totWidth = 0;
        //    double R11, R12, R13, R21, R22, R23, R31, R32, R33;
        //    int i, j;
        //    int idx = 0;
        //    int ifontsizeX = 0, ifontsizeY = 0, ishiftVal = 0;

        //    Vector3D M1 = new Vector3D();                                   // for fire data mm
        //    Vector3D M2 = new Vector3D();                                   // for clean data mm
        //    Vector3D M = new Vector3D();
        //    Vector3D C = new Vector3D();

        //    try
        //    {
        //        vinLength = vin.Length;
        //        if (vinLength <= 0)
        //        {
        //            retval.execResult = -1;
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "VIN LENGTH IS INVALID (" + vinLength.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

        //        Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
        //        byte.TryParse(value, out headType);

        //        vininfo.vinNo = vin;
        //        vininfo.fontName = pattern.fontValue.fontName;
        //        vininfo.width = pattern.fontValue.width;
        //        vininfo.height = pattern.fontValue.height;
        //        vininfo.pitch = pattern.fontValue.pitch;
        //        vininfo.thickness = pattern.fontValue.thickness;
        //        ImageProcessManager.GetFontDataEx(vininfo, headType, pattern.laserValue.density, 0, ref fontData, ref fontsizeX, ref fontsizeY, ref shiftVal, ref errCode);

        //        m_currCMD = (byte)'S';
        //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SolOnOffTime(pattern.speedValue.solOnTime, pattern.speedValue.solOffTime);
        //        if (retval.execResult != 0)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "SolOnOffTime ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        m_currCMD = (byte)'d';
        //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(pattern.speedValue.dwellTime);
        //        if (retval.execResult != 0)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "dwellTimeSet ERROR (" + retval.execResult.ToString() + ")", Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        if (currMarkInfo.checkdata.bReady == false)
        //        {
        //            CheckAreaData chkdata = new CheckAreaData();
        //            chkdata = await Range_Test2(cmd, vin, pattern);
        //            if (chkdata.execResult != 0)
        //            {
        //                return retval;
        //            }
        //            else
        //                currMarkInfo.checkdata = (CheckAreaData)chkdata.Clone();
        //        }

        //        ifontsizeX = (int)(fontsizeX + 0.5);
        //        ifontsizeY = (int)(fontsizeY + 0.5);
        //        ishiftVal = (int)(shiftVal + 0.5);

        //        CP = pattern.positionValue.center3DPos;
        //        cleanPosition = pattern.laserValue.cleanPosition;
        //        cleanPosition += CP.Z;         // Relative Cleanning postion

        //        SP0.X = totWidth / 2;
        //        SP0.Y = pattern.fontValue.height / 2;
        //        SP0.Z = 0;
        //        SP = CP - SP0;
        //        SP.Z = 0.0d;

        //        VectorNormal = currMarkInfo.checkdata.NormalDir;
        //        VectorRot.X = -VectorNormal.Y;
        //        VectorRot.Y = VectorNormal.X;
        //        VectorRot.Z = 0.0;

        //        double sqXY = Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y);

        //        if (sqXY != 0)
        //        {
        //            VectorRot.X /= sqXY;
        //            VectorRot.Y /= sqXY;
        //        }

        //        // Angle between VectorNormal to Z Axis ==> Rodrigues' Matrix
        //        bool skipRot = false;
        //        double cosValue = 0;
        //        if (VectorNormal.Length != 0)
        //            cosValue = VectorNormal.Z / VectorNormal.Length;

        //        double sinValue = Math.Sqrt(1.0d - cosValue * cosValue);
        //        if (cosValue > 0.9999986111)
        //        {      // 0.1 mm difference between 60mm
        //            skipRot = true;
        //            R11 = R12 = R13 = R21 = R22 = R23 = R31 = R32 = R33 = 0.0;
        //            R11 = R22 = R33 = 1.0;
        //        }
        //        else
        //        {
        //            R11 = cosValue + VectorRot.X * VectorRot.X * (1.0 - cosValue);
        //            R12 = VectorRot.X * VectorRot.Y * (1.0 - cosValue) - VectorRot.Z * sinValue;
        //            R13 = VectorRot.X * VectorRot.Z * (1.0 - cosValue) + VectorRot.Y * sinValue;
        //            R21 = VectorRot.Y * VectorRot.X * (1.0 - cosValue) + VectorRot.Z * sinValue;
        //            R22 = cosValue + VectorRot.Y * VectorRot.Y * (1.0 - cosValue);
        //            R23 = VectorRot.Y * VectorRot.Z * (1.0 - cosValue) - VectorRot.X * sinValue;
        //            R31 = VectorRot.Z * VectorRot.X * (1.0 - cosValue) - VectorRot.Y * sinValue;
        //            R32 = VectorRot.Z * VectorRot.Y * (1.0 - cosValue) + VectorRot.X * sinValue;
        //            R33 = cosValue + VectorRot.Z * VectorRot.Z * (1.0 - cosValue);
        //        }
        //        /////
        //        Step_W = pattern.fontValue.width / (fontsizeX - 1.0);
        //        Step_H = pattern.fontValue.height / (fontsizeY - 1.0);

        //        FontData4Send[,,] RasterData = new FontData4Send[vinLength + 1, ifontsizeY, ifontsizeX];     // BLU
        //        FontData4Send[,,] AllClrData = new FontData4Send[vinLength + 1, ifontsizeY, ifontsizeX];

        //        currMarkInfo.senddata.sendDataFire.Clear();
        //        currMarkInfo.senddata.sendDataClean.Clear();

        //        //List<Vector3D> recvPoint = new List<Vector3D>();
        //        ImageProcessManager.GetStartPointLinear(vinLength, CP, SP, pattern.fontValue.pitch, pattern.fontValue.rotateAngle, ref Rev_Point);

        //        Vector3D[] LeftRightSP = new Vector3D[2];
        //        LeftRightSP[0] = ImageProcessManager.Rotate_Point2(SP.X - pattern.positionValue.rasterSP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
        //        LeftRightSP[1] = ImageProcessManager.Rotate_Point2(SP.X + totWidth + pattern.positionValue.rasterEP, SP.Y, CP.X, CP.Y, pattern.fontValue.rotateAngle);
        //        List<FontDataClass> lineData = new List<FontDataClass>();
        //        List<FontDataClass> lineDataClean = new List<FontDataClass>();
        //        ImageProcessManager.GetFontDataOneEx('^', pattern.fontValue.fontName, headType, pattern.laserValue.density, 0, ref lineDataClean, out fontsizeX2, out fontsizeY2, out shiftVal2, out errCode);








        //        for (i = 0; i < Rev_Point.Count; i++)
        //        {
        //            if (vin.Substring(i, 1) != " ")      //Space Skip
        //            {
        //                lineData = fontData[i];
        //                FontDataClass fd = new FontDataClass();

        //                //xy_Temp = (Mode_File.FONT_[Strings.Asc(DATA_.Substring(i, 1))]).Split(';');
        //                //string[] xy_Data = new string[0];
        //                //var xy_List = new List<string>();

        //                //var dmStr = new string[0];
        //                //if (DotMiss != null)
        //                //{
        //                //    dmStr = DotMiss[i].Substring(2).Split(',');
        //                //    if (dmStr.Length > 0)
        //                //    {
        //                //        if (Int32.Parse(dmStr[0]) == -1) continue;
        //                //        else
        //                //        {
        //                //            for (int n = 0; n < dmStr.Length - 1; n++)
        //                //            {
        //                //                xy_List.Add(xy_Temp[Int32.Parse(dmStr[n])]);
        //                //            }
        //                //            xy_Data = xy_List.ToArray();
        //                //            xy_List.Clear();
        //                //        }
        //                //    }
        //                //}

        //                for (j = 0; j < lineData.Count; j++)
        //                {
        //                    fd = (FontDataClass)lineData[j].Clone();
        //                    // ABS mm
        //                    M1.X = Rev_Point[i].X + fd.vector3d.X * Step_W;
        //                    // Font offset compensation
        //                    M1.Y = Rev_Point[i].Y + fd.vector3d.Y * Step_H;
        //                    M1.Z = SP.Z;

        //                    //M1 = Mode_File.Rotate_Point(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, double.Parse(Angle));
        //                    M1 = ImageProcessManager.Rotate_Point2(M1.X, M1.Y, Rev_Point[i].X, Rev_Point[i].Y, pattern.fontValue.rotateAngle);
        //                    M1.Z = SP.Z;

        //                    // TM SHIN
        //                    M1.X -= CP.X; M1.Y -= CP.Y;

        //                    M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

        //                    M.X += CP.X; M.Y += CP.Y;
        //                    double Mt = M.Z;
        //                    M.Z = Mt + CP.Z + currMarkInfo.checkdata.PlaneCenterZ;
        //                    double Cz = 0.0;
        //                    Cz = Mt + currMarkInfo.currMarkData.pattern.laserValue.cleanPosition + currMarkInfo.checkdata.PlaneCenterZ;         // Clean Axis

        //                    Debug.WriteLine(String.Format("{0:D3} =>{1,7:F3},{2,7:F3},{3,7:F3}/{4,7:F3}", idx, M.X, M.Y, M.Z, Cz));

        //                    // Change to BLU(Unit 0.01mm)
        //                    //M.X *= (double)Mode_File.Step_Length; M.Y *= (double)Mode_File.Step_Length; M.Z *= (double)Mode_File.Step_Length;
        //                    //Cz *= (double)Mode_File.Step_Length;

        //                    M = M * pattern.headValue.stepLength;
        //                    C = C * pattern.headValue.stepLength;

        //                    FontData4Send font4Send = new FontData4Send();

        //                    font4Send.cN = (byte)i; font4Send.fN = (byte)j;
        //                    font4Send.mX = (UInt16)(M.X + 0.5); font4Send.mY = (UInt16)(M.Y + 0.5); font4Send.mZ = (UInt16)(M.Z + 0.5); font4Send.mF = (byte)fd.Flag;
        //                    font4Send.mC = (UInt16)(C.Z + 0.5);
        //                    font4Send.mI = (UInt16)(C.X + 0.5);

        //                    M_FONT FontData = new M_FONT();

        //                    FontData.cN = (byte)i;
        //                    FontData.fN = (byte)int.Parse(dmStr[j]);
        //                    FontData.mX = (UInt16)(M.X + 0.5); FontData.mY = (UInt16)(M.Y + 0.5); FontData.mZ = (UInt16)(M.Z + 0.5); FontData.mF = byte.Parse(xy_[2]);
        //                    FontData.mC = (UInt16)(Cz + 0.5);
        //                    FontData.mI = double.Parse(xy_[0]);

        //                    if (Density == 1)
        //                    {
        //                        FontData.mF = 0;
        //                        RasterData[i, int.Parse(xy_[1]) - SF, (int)(double.Parse(xy_[0]) + 0.5)] = FontData;
        //                    }
        //                    else
        //                    {
        //                        var m_font = FontData.cN.ToString("X2") + FontData.fN.ToString("X2") + FontData.mX.ToString("X4") + FontData.mY.ToString("X4") + FontData.mZ.ToString("X4") + FontData.mF.ToString("X4");
        //                        Mode_File.SendData.Add(m_font);
        //                        var m_clean = FontData.cN.ToString("X2") + FontData.fN.ToString("X2") + FontData.mX.ToString("X4") + FontData.mY.ToString("X4") + FontData.mC.ToString("X4") + FontData.mF.ToString("X4");
        //                        Mode_File.SendClean.Add(m_clean);
        //                    }

        //                    idx++;
        //                }
        //            }
        //        }

        //        if (currMarkInfo.currMarkData.pattern.laserValue.density == 1)       // Dot Firing
        //        {
        //            ushort[] NoPoints = new ushort[YF];

        //            for (int y = 0; y < YF; y++)
        //            {
        //                for (i = 0; i < vinLength; i++)
        //                {
        //                    for (int x = 0; x < XF; x++)
        //                    {
        //                        if (RasterData[i, y, x] != null) NoPoints[y]++;         // Data Number of fire data
        //                    }
        //                }
        //            }

        //            //
        //            Debug.WriteLine("");

        //            //
        //            // Make Firing Data for dot missing
        //            if (Ag == 0.0)
        //            {           // 0 degree
        //                StringBuilder sb = new StringBuilder();
        //                for (i = 0; i < vinLength; i++)
        //                {
        //                    // Fire Data string
        //                    for (int y = 0; y < YF; y++)
        //                        for (int x = 0; x < XF; x++)
        //                            if (RasterData[i, y, x] != null)
        //                            {
        //                                sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mZ, RasterData[i, y, x].mF);
        //                                Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                Mode_File.SendData.Add(sb.ToString()); sb.Clear();
        //                            }
        //                }

        //                //
        //                //  Make Cleaning Data
        //                sb = new StringBuilder();
        //                for (i = vinLength - 1; i >= 0; i--)
        //                {
        //                    for (int y = YF - 1; y >= 0; y--)
        //                        for (int x = XF - 1; x >= 0; x--)
        //                            if (RasterData[i, y, x] != null)
        //                            {
        //                                sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mC, RasterData[i, y, x].mF);
        //                                Debug.WriteLine(y.ToString("00") + "C" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                Mode_File.SendClean.Add(sb.ToString()); sb.Clear();
        //                            }
        //                }
        //            }
        //            else
        //            {       // 180 degree
        //                StringBuilder sb = new StringBuilder();
        //                for (i = vinLength - 1; i >= 0; i--)
        //                {
        //                    // Fire Data string
        //                    for (int y = YF - 1; y >= 0; y--)
        //                        for (int x = XF - 1; x >= 0; x--)
        //                            if (RasterData[i, y, x] != null)
        //                            {
        //                                sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mZ, RasterData[i, y, x].mF);
        //                                Debug.WriteLine(y.ToString("00") + "F" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                Mode_File.SendData.Add(sb.ToString()); sb.Clear();
        //                            }
        //                }

        //                //
        //                //  Make Cleaning Data
        //                sb = new StringBuilder();
        //                for (i = 0; i < vinLength; i++)
        //                {
        //                    for (int y = 0; y < YF; y++)
        //                        for (int x = 0; x < XF; x++)
        //                            if (RasterData[i, y, x] != null)
        //                            {
        //                                sb.AppendFormat("{0:X2}{1:X2}{2:X4}{3:X4}{4:X4}{5:X4}", RasterData[i, y, x].cN, RasterData[i, y, x].fN, RasterData[i, y, x].mX, RasterData[i, y, x].mY, RasterData[i, y, x].mC, RasterData[i, y, x].mF);
        //                                Debug.WriteLine(y.ToString("00") + "C" + NoPoints[y].ToString("000") + ":" + sb.ToString());
        //                                Mode_File.SendClean.Add(sb.ToString()); sb.Clear();
        //                            }
        //                }
        //            }
        //        }

        //        M_Count = idx;
        //        //Mark_Counter++;

        //        Mode_File.Download_Data = true;






        //        //M_Count = idx;
        //        ////Mark_Counter++;

        //        //Mode_File.Download_Data = true;

        //        return retval;

        //        Vector3D getRodrigueRotation(Vector3D XY0)
        //        {
        //            Vector3D Tmp = new Vector3D();
        //            Tmp.X = XY0.X * R11 + XY0.Y * R12 + XY0.Z * R13;
        //            Tmp.Y = XY0.X * R21 + XY0.Y * R22 + XY0.Z * R23;
        //            Tmp.Z = XY0.X * R31 + XY0.Y * R32 + XY0.Z * R33;

        //            return Tmp;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        retval.execResult = ex.HResult;
        //        //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //        return retval;
        //    }
        //}

        private async void btnFixDotMissing_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnFixDotMissing_Click";

            OpenFileDialog openFileDialog = new OpenFileDialog();
            List<string> missList = new List<string>();
            ITNTResponseArgs retval = new ITNTResponseArgs();
            PatternValueEx pattern = new PatternValueEx();
            string value = "";
            byte bHeadType = 0;

            CheckAreaData chkdata = new CheckAreaData();
            string patName = "";
            string cmd = "FIX DOT MISSING";
            string log = "";
            short posX = 0;
            short posY = 0;
            short posZ = 0;
            LASERSTATUS Status;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");
                openFileDialog.InitialDirectory = "C\\ITNT\\DOTMISSING\\";// AppDomain.CurrentDomain.BaseDirectory + Constants.PARAMS_PATH;
                openFileDialog.Filter = "dot missing files (*.dot)|*.dot";

                if (openFileDialog.ShowDialog() == false)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "USER CANCEL");
                    return;
                }

                if (File.Exists(openFileDialog.FileName) == false)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "FILE NOT FOUND");
                    return;
                }

                Util.GetPrivateProfileValue("OPTION", "MARKINGLOGLEVEL", "0", ref value, Constants.PARAMS_INI_FILE);
                byte logLevel = 0;
                byte.TryParse(value, out logLevel);

                string readDotMiss = File.ReadAllText(openFileDialog.FileName);
                string[] tmpmiss = readDotMiss.Replace('\r', ' ').Split('\n');
                for (int i = 0; i < tmpmiss.Length; i++)
                {
                    if (tmpmiss[i].Length > 0)
                        missList.Add(tmpmiss[i]);
                }
                //missList = readDotMiss.Replace('\r', ' ').Split('\n').ToList<string>();
                var strbVin = new StringBuilder();
                for (int i = 0; i < missList.Count; i++)
                    strbVin.Append(missList[i][0]);
                var strVin = strbVin.ToString().ToUpper();

                //SetString4Textbox(strVin, txtVIN, null, null);
                ShowTextBoxData(txtVIN, strVin);


                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                }
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                }
                ShowRectangle(AimingLamp, Brushes.Red);

                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }

                patName = cbxPatternList.SelectedItem.ToString();
                //ImageProcessManager.GetPatternValue(patName, byH)
                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);
                ImageProcessManager.GetPatternValue(patName, bHeadType, ref pattern);

                //#if LASER_YLR
                chkdata = await Range_Test("DOT MISSING", strVin, pattern, 0, 0);
                //chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
                if (chkdata.execResult != 0)
                {
                    log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    retval.execResult = chkdata.execResult;
                    retval.errorInfo.sErrorMessage = chkdata.errorInfo.sErrorMessage;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                //chkdata = await Range_Test(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
                //    if (chkdata.execResult != 0)
                //    {
                //        log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                //        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //        return;
                //    }
//#else
//                currMarkInfo.checkdata.NormalDir.X = currMarkInfo.checkdata.NormalDir.Y = 0.0;
//                currMarkInfo.checkdata.NormalDir.Z = 1.0;

//                chkdata = await GetMarkPosition(cmd, pattern, 0, 0);
//                if (chkdata.execResult != 0)
//                {
//                    log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }
//#endif

                //chkdata = await Range_Test(cmd, strVin, pattern, 0, 0);
                //if (chkdata.execResult != 0)
                //{
                //    return;
                //}

                if (chkdata.ErrorDistanceSensor == true)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    ShowRectangle(AimingLamp, Brushes.Black);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                ShowRectangle(AimingLamp, Brushes.Black);


                statusTimer.Stop();



                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                if (retval.execResult != 0)
                {
                    log = "ReadDeviceStatus (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }
                string[] st = retval.recvString.Split(':');
                Status = (LASERSTATUS)UInt32.Parse(st[1]);
                if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    //retval = await EmissionOFF();
                    if (retval.execResult != 0)
                    {
                        log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    ShowRectangle(EmissionLamp, Brushes.Black);
                    //EmissionLamp.Fill = Brushes.Black;
                }

                //Util.GetPrivateProfileValue("PROFILE", "PROFILEFIRE", "0", ref value, "Parameter.ini");                 // load waveform profile number
                //ProfileTxt.Text = value;
#if LASER_YLR_PULSEMODE
                ShowTextBoxData(txtCurrProfile, pattern.laserValue.waveformNum.ToString());
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(pattern.laserValue.waveformNum.ToString());
                string[] prsel = retval.recvString.Split('[', ']');
                if (prsel[0] == "PRSEL: ")
                {
                    string[] sel = prsel[1].Split(':');
                    if (value != sel[0])
                    {
                        Debug.WriteLine("Profile setting Error! / ");      // Error
                        statusTimer.Start();
                        return;
                    }
                }
                else
                {
                    Debug.WriteLine("Profile setting response Error! / "); // Error
                    statusTimer.Start();
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
                if (retval.execResult != 0)
                {
                    log = "ConfigWaveformMode (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }
                string[] pcfg = retval.recvString.Split('[', ']');
#else
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SELECT MARK POWER. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SELECT MARK WIDTH. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    return;
                }
#endif

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.FontFlush();
                if (retval.execResult != 0)
                {
                    log = "FontFlush (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }
                ClearMarkVINDisplay();


                retval.execResult = ReadFontData(cmd, patName);
                if (retval.execResult != 0)
                {
                    log = "READ FONT ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }
                await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
                GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);
                bReadFontValue = true;


                retval = await Start_DOTMISSING(cmd, strVin, pattern, missList);
                if (retval.execResult != 0)
                {
                    log = "Start_DOTMISSING. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }


                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }

                int iDotDelay = 0;
                Util.GetPrivateProfileValue("LASERSOURCE", "DOTDELAY", "100", ref value, Constants.MARKING_INI_FILE);
                int.TryParse(value, out iDotDelay);


                currMarkInfo.senddata.CleanFireFlag = false;    // Fire sending
                                                                //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataFire.Count;
                string StPoint = currMarkInfo.senddata.sendDataFire.ElementAt(0);

                m_currCMD = (byte)'K';
                value = StPoint.Substring(4, 4);
                short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posX);

                value = StPoint.Substring(8, 4);
                short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posY);

                value = StPoint.Substring(12, 4);
                short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posZ);
                posZ += 500;

                //StPoint.Substring(4, 4 + 4);
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                if (retval.execResult != 0)
                {
                    log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.MarkMoving);
                if (retval.execResult != 0)
                {
                    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                //mark.Density("N", Density.ToString("X4"));
                //ShowLog("MARKING - SET DENSITY");
                m_currCMD = (byte)'N';
                //Density232 = (short)currMarkInfo.currMarkData.pattern.laserValue.density;
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)0);
                if (retval.execResult != 0)
                {
                    log = "SET DENSITY. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }

                // Run Marking
                Stopwatch sw = Stopwatch.StartNew();

                if ((bool)EmissionAuto.IsChecked)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    //retval = await EmissionON();
                    if (retval.execResult != 0)
                    {
                        log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    ShowRectangle(EmissionLamp, Brushes.Red);
                    //EmissionLamp.Fill = Brushes.Red;
                }

                //Marking Start
                //ShowLog("MARKING - START MARKING");

                foreach (var str in currMarkInfo.senddata.sendDataFire)
                {
                    m_currCMD = (byte)'@';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(str, false, logLevel);
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        statusTimer.Start();
                        return;
                    }

                    await Task.Delay(iDotDelay);

                    m_currCMD = (byte)'O';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(0, true);
                    if (retval.execResult != 0)
                    {
                        log = "TestSolFet ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        statusTimer.Start();
                        return;
                    }
                }


                if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    //retval = await EmissionOFF();
                    if (retval.execResult != 0)
                    {
                        log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    ShowRectangle(EmissionLamp, Brushes.Black);
                    //EmissionLamp.Fill = Brushes.Black;
                }





                bReadFontValue = false;
                currMarkInfo.checkdata.bReady = false;
                currMarkInfo.senddata.bReady = false;
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
                if (retval.execResult != 0)
                {
                    log = "ReadDeviceStatus. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }
                else
                {
                    st = retval.recvString.Split(':');
                    Status = (LASERSTATUS)UInt32.Parse(st[1]);

                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
                    {
                        //ShowLog("MARKING - START CLEANING");

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        //retval = await EmissionOFF();
                        if (retval.execResult != 0)
                        {
                            log = "StopEmission. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            statusTimer.Start();
                            return;
                        }
                        ShowRectangle(EmissionLamp, Brushes.Black);

#if LASER_YLR
                        //Util.GetPrivateProfileValue("VINDATA", "PROFILECLEAN", "0", ref value, "Parameter.ini");                 // load waveform profile number
                        value = currMarkInfo.currMarkData.pattern.laserValue.waveformClean.ToString();
                        ShowTextBoxData(txtCurrProfile, value);
                        //txtCurrProfile.Text = value;
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value);
                        prsel = retval.recvString.Split('[', ']');
                        if (prsel[0] != "PRSEL: ")
                        {
                            log = "Profile setting Error2!. (PRSEL[0] = " + prsel[0] + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            statusTimer.Start();
                            return;
                        }
                        string[] sel = prsel[1].Split(':');
                        if (value != sel[0])
                        {
                            log = "Profile setting Error!. (SEL[0] = " + sel[0] + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            statusTimer.Start();
                            return;
                        }
#else
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            return;
                        }

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.spotPower);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SELECT SPOT POWER. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.spotWidth);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - SELECT SPOT WIDTH. (" + retval.execResult.ToString() + ")";
                            //ShowLog(log);
                            retval.errorInfo.sErrorMessage = log;
                            retval.errorInfo.sErrorCode = "";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }
#endif
                        if ((bool)EmissionAuto.IsChecked)
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //retval = await EmissionON();
                            if (retval.execResult != 0)
                            {
                                log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
                            ShowRectangle(EmissionLamp, Brushes.Red);
                            //EmissionLamp.Fill = Brushes.Red;
                        }

                        //currMarkInfo.senddata.SendDataIndex = 0;
                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;




                        foreach (var str in currMarkInfo.senddata.sendDataClean)
                        {
                            m_currCMD = (byte)'@';
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(str, true, logLevel);
                            if (retval.execResult != 0)
                            {
                                log = "MARKING ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                statusTimer.Start();
                                return;
                            }

                            await Task.Delay(iDotDelay);

                            m_currCMD = (byte)'O';
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(0, true);
                            if (retval.execResult != 0)
                            {
                                log = "TestSolFet ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                statusTimer.Start();
                                return;
                            }
                        }


                        log = "CLEAN TIME : " + sw.ElapsedMilliseconds.ToString();
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    }

                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        //retval = await EmissionOFF();
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        ShowRectangle(EmissionLamp, Brushes.Black);
                        //EmissionLamp.Fill = Brushes.Black;
                    }
                }


                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)currMarkInfo.currMarkData.pattern.laserValue.density);
                if (retval.execResult != 0)
                {
                    log = "SetDensity (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }



                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }

                short stepLeng = currMarkInfo.currMarkData.pattern.headValue.stepLength;
                if (stepLeng <= 0)
                    stepLeng = 100;

                posX = (short)(currMarkInfo.currMarkData.pattern.headValue.park3DPos.X * stepLeng); if (posX <= 0) posX = (short)(70 * stepLeng);
                posY = (short)(currMarkInfo.currMarkData.pattern.headValue.park3DPos.Y * stepLeng); if (posY <= 0) posY = (short)(20 * stepLeng);
                posZ = (short)(currMarkInfo.currMarkData.pattern.headValue.park3DPos.Z * stepLeng); if (posZ <= 0) posZ = (short)(110 * stepLeng);
                m_currCMD = (byte)'K';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                if (retval.execResult != 0)
                {
                    log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    statusTimer.Start();
                    return;
                }

                //Debug.WriteLine("Running Time : " + sw.Elapsed);
                sw.Stop();
                log = "TOTAL MARKING TIME : " + sw.ElapsedMilliseconds.ToString();
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "Running Time : " + sw.Elapsed.ToString(), Thread.CurrentThread.ManagedThreadId);
                statusTimer.Start();



                m_currCMD = (byte)'N';
                //Density232 = (short)currMarkInfo.currMarkData.pattern.laserValue.density;
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)currMarkInfo.currMarkData.pattern.laserValue.density);
                if (retval.execResult != 0)
                {
                    log = "SET DENSITY. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
            }
            catch (Exception ex)
            {
                //MessageBox.Show(ERR.ToString());
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        public void ShowMarkingOneLine(int xcharIndex, int fontIndex)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowMarkingOneLine";

            Canvas showcanvas = new Canvas();
            string name = "";
            double canvaswidth = 0;
            double canvasheight = 0;
            double OriginX = 0;
            double OriginY = 0;
            double orgWidth = 0;
            double orgHeight = 0;
            double CharHeight = 0;
            double CharWidth = 0;
            double CharThick = 0;
            double heightRatio = 0;
            double widthRatio = 0;
            int Dotsize = 5;
            List<FontDataClass> fdata = new List<FontDataClass>();
            FontDataClass font;
            double left, right, top, bottom;

            try
            {
                showcanvas = new Canvas();

                if (xcharIndex < 0 || fontIndex < 0)
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("INVALID INDEX - CH : {0}/{1}", xcharIndex, fontIndex), Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                name = string.Format("cvsshowChar{0:D2}", xcharIndex);
                showcanvas = (Canvas)FindName(name);
                if (showcanvas == null)
                    return;

                canvaswidth = showcanvas.Width;
                canvasheight = showcanvas.Height;
                OriginX = 1.5d * Util.PXPERMM;// 1.5D
                OriginY = 2.5d * Util.PXPERMM;//2.5D
                orgWidth = (currMarkInfo.currMarkData.pattern.fontValue.width) * Util.PXPERMM + OriginX * 2;
                orgHeight = Util.PXPERMM * currMarkInfo.currMarkData.pattern.fontValue.height + OriginY * 2;

                CharHeight = currMarkInfo.currMarkData.pattern.fontValue.height * Util.PXPERMM;
                CharWidth = currMarkInfo.currMarkData.pattern.fontValue.width * Util.PXPERMM;
                CharThick = currMarkInfo.currMarkData.pattern.fontValue.thickness * Util.PXPERMM * canvaswidth / orgWidth;
                heightRatio = canvasheight / orgHeight;
                widthRatio = canvaswidth / orgWidth;
                Dotsize = 5;
                //Debug.WriteLine(String.Format("EVENT-({0},{1})", xcharIndex, fontIndex));

                switch (currMarkInfo.currMarkData.pattern.laserValue.density)
                {
                    case 0:
                        fdata = currMarkInfo.currMarkData.fontData[xcharIndex].ToList();
                        font = (FontDataClass)fdata[fontIndex].Clone();

                        if (font.Flag == 1 || font.Flag == 2 || font.Flag == 3 || font.Flag == 4 || font.Flag == 5)
                        {
                            Dotline = new Ellipse
                            {
                                Stroke = (currMarkInfo.senddata.CleanFireFlag == false) ? Brushes.Red : Brushes.LightGreen,
                                //Stroke = Brushes.Red,
                                StrokeThickness = CharThick,
                                Height = (double)Dotsize,
                                Width = (double)Dotsize,
                                Fill = Brushes.Red,
                                Margin = new Thickness((OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio - (double)Dotsize / 2.0, (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio - (double)Dotsize / 2.0, 0, 0)
                            };
                            Canvas.SetZIndex(Dotline, (int)(CharThick + 0.5));
                            ////showcanvas.Children.Add(img);
                            showcanvas.Children.Add(Dotline);
                            ////showcanvas.Children.Remove(img);
                        }
                        break;

                    case 1:
                        for (int v = 0; v < currMarkInfo.currMarkData.mesData.markvin.Length; v++)
                        {
                            Canvas showcanvas1 = new Canvas();
                            string names = string.Format("cvsshowChar{0:D2}", v);
                            showcanvas1 = (Canvas)FindName(names);
                            if (showcanvas1 == null)
                            {
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:00}:{1}()  {2}", className, funcName, string.Format("CANVAS IS NULL ({0})", v), Thread.CurrentThread.ManagedThreadId);
                                //Debug.WriteLine(string.Format("CANVAS IS NULL ({0})", v));
                                continue;
                            }
                            //img.Source = new BitmapImage(new Uri(@"C:\ITNTLASER\ITNTMARK_CONFIG\laser_beam.png"));
                            //img.Height = 10.0; img.Width = 10.0;

                            for (int x = 0; x < currMarkInfo.currMarkData.fontDot.GetLength(1); x++)
                            {
                                if (fontIndex > currMarkInfo.currMarkData.fontDot.GetLength(2))
                                {
                                    continue;
                                }

                                FontDataClass fontdot = (FontDataClass)currMarkInfo.currMarkData.fontDot[v, x, fontIndex].Clone();
                                if (fontdot.Flag != 0)
                                {
                                    //Debug.WriteLine(String.Format("MARK-({0}:{1},{2})", fontIndex, fontdot.vector3d.X, fontdot.vector3d.Y));
                                    ////Canvas.SetLeft(img, ((OriginX + (font.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio - img.Height / 2));
                                    ////Canvas.SetTop(img, (OriginY + (font.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio - img.Width / 2);
                                    left = (OriginX + (fontdot.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio - (double)Dotsize / 2.0;
                                    right = (OriginY + (fontdot.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio - (double)Dotsize / 2.0;
                                    top = 0;
                                    bottom = 0;
                                    //Debug.WriteLine(String.Format("DISP-({3}/{0}:{1},{2}:{4}.{5})", fontIndex, fontdot.vector3d.X, fontdot.vector3d.Y, xcharIndex, left, right));
                                    Dotline = new Ellipse
                                    {
                                        //Stroke = (currMarkInfo.senddata.CleanFireFlag == false) ? Brushes.Red : Brushes.LightGreen,
                                        Stroke = (currMarkInfo.senddata.CleanFireFlag == false) ? Brushes.Red : Brushes.LightBlue,
                                        StrokeThickness = CharThick,
                                        Height = (double)Dotsize,
                                        Width = (double)Dotsize,
                                        Fill = Brushes.Red,
                                        Margin = new Thickness(left, right, 0, 0)
                                    };
                                    Canvas.SetZIndex(Dotline, (int)(CharThick + 0.5));
                                    ////showcanvas.Children.Add(img);
                                    showcanvas1.Children.Add(Dotline);
                                    ////showcanvas.Children.Remove(img);
                                }
                            }
                        }
                        break;

                    default:
                        fdata = currMarkInfo.currMarkData.fontData[xcharIndex].ToList();
                        font = (FontDataClass)fdata[fontIndex].Clone();
                        if (font.Flag == 1)
                        {
                            // (showcanvas.Parent as Canvas).Children.Clear();
                            charline = new System.Windows.Shapes.Line
                            {
                                Stroke = Brushes.Red,
                                StrokeThickness = CharThick,
                                StrokeStartLineCap = PenLineCap.Round,
                                StrokeEndLineCap = PenLineCap.Round,
                                StrokeLineJoin = PenLineJoin.Round,
                                X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio,
                                Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio
                            };
                            charline.X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                            charline.Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio;
                        }
                        else if (font.Flag == 2 || font.Flag == 3 || font.Flag == 5)
                        {
                            if (charline != null)
                            {
                                charline.X2 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                                charline.Y2 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio;

                                showcanvas.Children.Add(charline);

                                charline = new System.Windows.Shapes.Line
                                {
                                    Stroke = Brushes.Red,
                                    StrokeThickness = CharThick,
                                    StrokeStartLineCap = PenLineCap.Round,
                                    StrokeEndLineCap = PenLineCap.Round,
                                    StrokeLineJoin = PenLineJoin.Round,
                                    X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio,
                                    Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio,
                                };
                                charline.X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                                charline.Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio;
                            }
                        }
                        else if (font.Flag == 4)
                        {
                            if (charline != null)
                            {
                                charline.X2 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                                charline.Y2 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightRatio;
                                showcanvas.Children.Add(charline);
                            }
                        }
                        else
                        {

                        }
                        break;
                }
                return;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:00}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return;
            }
        }

        public void ShowMarkingOneLine(int xcharIndex, int fontIndex, Int16 densityRun, bool FireCleanDotColor = true)
        {
            string className = "SetControllerWindow3";
            string funcName = "ShowOneVinNoCharacter";
            Canvas showcanvas = new Canvas();
            string name = "";

            try
            {
                name = string.Format("cvsshowChar{0:D2}", xcharIndex);
                showcanvas = (Canvas)FindName(name);
                if (showcanvas == null)
                    return;

                double canvaswidth = showcanvas.ActualWidth;
                double canvasheight = showcanvas.ActualHeight;
                double OriginX = 1.5d * Util.PXPERMM;// 1.5D
                double OriginY = 2.5d * Util.PXPERMM;//2.5D
                double orgWidth = (currMarkInfo.currMarkData.pattern.fontValue.width) * Util.PXPERMM + OriginX * 2;
                double orgHeight = Util.PXPERMM * currMarkInfo.currMarkData.pattern.fontValue.height + OriginY * 2;

                /***********************************
                1 inch  25.4mm
                1 inch  72 pt
                1 inch  96 px        dpi
                1 mm    2.83465 pt
                1 mm    3.7795 px    dpi/ 25.4
                ***********************************/
                double CharHeight = currMarkInfo.currMarkData.pattern.fontValue.height * Util.PXPERMM;
                double CharWidth = currMarkInfo.currMarkData.pattern.fontValue.width * Util.PXPERMM;
                double CharThick = currMarkInfo.currMarkData.pattern.fontValue.thickness * Util.PXPERMM * canvaswidth / orgWidth;
                double heightthRatio = canvasheight / orgHeight;
                double widthRatio = canvaswidth / orgWidth;
                int Dotsize = 5;
                //Image img = new Image();

                List<FontDataClass> fdata = new List<FontDataClass>();
                FontDataClass font;

                switch (densityRun)//currMarkInfo.currMarkData.pattern.laserValue.density)
                {
                    case 0:     // Density 0 : Dot Marking : Dot
                        fdata = currMarkInfo.currMarkData.fontData[xcharIndex].ToList();
                        font = (FontDataClass)fdata[fontIndex].Clone();

                        //if (font.Flag == 1 || font.Flag == 2 || font.Flag == 3 || font.Flag == 4 || font.Flag == 5)
                        if (font.Flag != 0)
                        {
                            Dotline = new Ellipse
                            {
                                Stroke = (FireCleanDotColor == false) ? Brushes.Red : Brushes.LightGreen,
                                StrokeThickness = CharThick,
                                Height = (double)Dotsize,
                                Width = (double)Dotsize,
                                Fill = Brushes.Red,
                                Margin = new Thickness((OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio - (double)Dotsize / 2.0, (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio - (double)Dotsize / 2.0, 0, 0)
                            };
                            Canvas.SetZIndex(Dotline, (int)(CharThick + 0.5));
                            ////showcanvas.Children.Add(img);
                            showcanvas.Children.Add(Dotline);
                            ////showcanvas.Children.Remove(img);
                        }
                        break;

                    case 1:     // Density 1 : Dot Marking : Line
                        for (int v = 0; v < currMarkInfo.currMarkData.mesData.markvin.Length; v++)
                        {
                            Canvas showcanvas1 = new Canvas();
                            string names = string.Format("cvsshowChar{0:D2}", v);
                            showcanvas1 = (Canvas)FindName(names);
                            if (showcanvas1 == null)
                                return;

                            for (int x = 0; x < currMarkInfo.currMarkData.fontDot.GetLength(1); x++)
                            {
                                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:00}:{1}()  {2}", className, funcName, "V = " + v.ToString() + ", X = " + x.ToString(), Thread.CurrentThread.ManagedThreadId);

                                FontDataClass fontdot = (FontDataClass)currMarkInfo.currMarkData.fontDot[v, x, fontIndex].Clone();
                                if (fontdot.Flag != 0)
                                {
                                    ////Canvas.SetLeft(img, ((OriginX + (font.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio - img.Height / 2));
                                    ////Canvas.SetTop(img, (OriginY + (font.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio - img.Width / 2);
                                    Dotline = new Ellipse
                                    {
                                        Stroke = (FireCleanDotColor == false) ? Brushes.Red : Brushes.LightGreen,
                                        StrokeThickness = CharThick,
                                        Height = (double)Dotsize,
                                        Width = (double)Dotsize,
                                        Fill = Brushes.Red,
                                        Margin = new Thickness((OriginX + (fontdot.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio - (double)Dotsize / 2.0, (OriginY + (fontdot.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio - (double)Dotsize / 2.0, 0, 0)
                                    };
                                    Canvas.SetZIndex(Dotline, (int)(CharThick + 0.5));
                                    ////showcanvas.Children.Add(img);
                                    showcanvas1.Children.Add(Dotline);
                                    ////showcanvas.Children.Remove(img);
                                }
                            }
                        }
                        break;

                    default:    // Divided Dot Marking  :  Density > 1
                        fdata = currMarkInfo.currMarkData.fontData[xcharIndex].ToList();
                        font = (FontDataClass)fdata[fontIndex].Clone();
                        if (font.Flag == 1)
                        {
                            // (showcanvas.Parent as Canvas).Children.Clear();
                            charline = new System.Windows.Shapes.Line
                            {
                                Stroke = Brushes.Red,
                                StrokeThickness = CharThick,
                                StrokeStartLineCap = PenLineCap.Round,
                                StrokeEndLineCap = PenLineCap.Round,
                                StrokeLineJoin = PenLineJoin.Round,
                                X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio,
                                Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio
                            };
                            charline.X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                            charline.Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio;
                        }
                        else if (font.Flag == 2 || font.Flag == 3 || font.Flag == 5)
                        {
                            if (charline != null)
                            {
                                charline.X2 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                                charline.Y2 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio;

                                showcanvas.Children.Add(charline);

                                charline = new System.Windows.Shapes.Line
                                {

                                    Stroke = Brushes.Red,
                                    StrokeThickness = CharThick,
                                    StrokeStartLineCap = PenLineCap.Round,
                                    StrokeEndLineCap = PenLineCap.Round,
                                    StrokeLineJoin = PenLineJoin.Round,
                                    X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio,
                                    Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio,

                                };
                                charline.X1 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                                charline.Y1 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio;
                            }
                        }
                        else if (font.Flag == 4)
                        {
                            if (charline != null)
                            {
                                charline.X2 = (OriginX + (font.vector3d.X * CharWidth) / currMarkInfo.currMarkData.fontSizeX) * widthRatio;
                                charline.Y2 = (OriginY + (font.vector3d.Y * CharHeight) / currMarkInfo.currMarkData.fontSizeY) * heightthRatio;
                                showcanvas.Children.Add(charline);
                            }
                        }
                        else
                        {

                        }
                        break;

                }
                return;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:00}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return;
            }
        }



        public async Task<distanceSensorData> GetMeasureLength(Vector3D vp3, int pos, byte count)
        {
            string className = "SetControllerWindow3";
            string funcName = "GetMeasureLength";

            distanceSensorData sensorData = new distanceSensorData();
            ITNTResponseArgs retval = new ITNTResponseArgs();

            try
            {
                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint((int)(vp3.X), (int)(vp3.Y), (int)(vp3.Z), pos);
                if (retval.execResult != 0)
                {
                    sensorData.execResult = retval.execResult;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GoPoint ERROR : " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                    return sensorData;
                }

                sensorData = await ((MainWindow)System.Windows.Application.Current.MainWindow).ReadDisplacementSensor(count);
                if (sensorData.execResult != 0)
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "ReadDisplacementSensor : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                    return sensorData;
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                sensorData.execResult = ex.HResult;
            }
            return sensorData;
        }


        //public async Task<CheckAreaData> Range_Test2(string cmd, string vin, PatternValueEx pattern)   // Plating  by TM SHIN
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "Range_Test2";

        //    CheckAreaData retval = new CheckAreaData();
        //    distanceSensorData snsdata = new distanceSensorData();
        //    ITNTResponseArgs respArg = new ITNTResponseArgs();

        //    int NoVin;
        //    double totWidth = 0;

        //    Vector3D SP0 = new Vector3D();
        //    Vector3D SP1 = new Vector3D();
        //    Vector3D CP = new Vector3D();

        //    Vector3D PointLU = new Vector3D();
        //    Vector3D PointLD = new Vector3D();
        //    Vector3D PointRU = new Vector3D();

        //    Vector3D[] vCheckPos = new Vector3D[7];
        //    double[] HeightVal = new double[7];
        //    Vector3D vector3 = new Vector3D();

        //    double HeightCT0 = 0;
        //    string value = "";
        //    string log = "";
        //    byte bHeadType = 0;
        //    string fName = "";

        //    List<Vector3D> planePoints = new List<Vector3D>();

        //    short gMinX = 0;
        //    short gMaxX = 0;
        //    short gMinY = 0;
        //    short gMaxY = 0;
        //    short? CenterX = null;
        //    short? CenterY = null;
        //    short? CenterZ = null;

        //    try
        //    {
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

        //        Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
        //        byte.TryParse(value, out bHeadType);

        //        NoVin = vin.Length;
        //        if (NoVin <= 0)
        //        {
        //            log = "VIN LENGTH <= 0 (" + NoVin.ToString() + ")";
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = -1;
        //            return retval;
        //        }

        //        if (cbxPatternList.SelectedIndex >= 0)
        //            fName = cbxPatternList.SelectedItem.ToString();
        //        else
        //            fName = "Pattern_DEFAULT";


        //        totWidth = pattern.fontValue.pitch * (NoVin - 1) + pattern.fontValue.width;
        //        planePoints.Clear();
        //        retval.ErrorDistanceSensor = false;

        //        if (ckbSkipCheckPlane.IsChecked == true)
        //        {
        //            retval.NormalDir.X = 0;
        //            retval.NormalDir.Y = 0;
        //            retval.NormalDir.Z = 1;

        //            retval.bReady = true;
        //            retval.execResult = 0;
        //            return retval;
        //        }

        //        // SET Motor Speed
        //        respArg = await SendMotorSpeed(cmd, (byte)motorSpeedType.MeasureMoving);
        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - SET MOTOR SPEED(MEASURE) ERROR = " + retval.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET MOTOR SPEED(MEASURE) ERROR - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }

        //        //respArg = 


        //        // Laser Beam ON
        //        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - SET BEAM CONTROLL ERROR : " + retval.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET BEAM CONTROLL ERROR - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }

        //        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - BEAM ON ERROR : " + retval.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM ON ERROR - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }
        //        ShowRectangle(AimingLamp, Brushes.Red);

        //        // Absolute mm of Center Point
        //        CP = pattern.positionValue.center3DPos;
        //        SP0.X = totWidth / 2;
        //        SP0.Y = pattern.fontValue.height / 2;

        //        SP1 = CP - SP0;
        //        SP1.Z = CP.Z;

        //        // ABS mm
        //        double MinX = SP1.X;
        //        double MaxX = SP1.X + totWidth;
        //        double MinY = SP1.Y;
        //        double MaxY = SP1.Y + pattern.fontValue.height;// Ht;

        //        // ABS BLU
        //        gMinX = (short)(MinX * pattern.headValue.stepLength + 0.5);
        //        gMaxX = (short)(MaxX * pattern.headValue.stepLength + 0.5);
        //        gMinY = (short)(MinY * pattern.headValue.stepLength + 0.5);
        //        gMaxY = (short)(MaxY * pattern.headValue.stepLength + 0.5);

        //        // ABS mm
        //        double CX = (MaxX + MinX) / 2.0;
        //        double CY = (MaxY + MinY) / 2.0;

        //        // ABS BLU
        //        short tCX = (short)(CX * pattern.headValue.stepLength + 0.5);
        //        short tCY = (short)(CY * pattern.headValue.stepLength + 0.5);
        //        CenterX = tCX;
        //        CenterY = tCY;
        //        CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);

        //        short Parking_Z = (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5);

        //        vector3.X = tCX;
        //        vector3.Y = tCY;
        //        vector3.Z = Parking_Z;

        //        snsdata = await GetMeasureLength(vector3, 0, 1);
        //        if (snsdata.execResult != 0)
        //        {
        //            retval.execResult = snsdata.execResult;
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR 0 - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CT) : ERROR = " + snsdata.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        double ShiftCT = snsdata.sensorshift;
        //        double HeightCT = snsdata.sensoroffset;

        //        if (Math.Abs(HeightCT) > 20.0)      // Z Diff Max. 60mm
        //        {
        //            retval.ErrorDistanceSensor = true;
        //            Dispatcher.Invoke(new Action(delegate
        //            {
        //                lblDispCenXCenY.Foreground = Brushes.Red;
        //                lblDispCenXCenY.Content = HeightCT.ToString("0.000");       // Sensor shift value 
        //                lblDispMinXMaxY.Content = "";
        //                lblDispMinXMinY.Content = "";
        //                lblDispMaxXMaxY.Content = "";
        //                lblDispMaxXMinY.Content = "";
        //                lblDispCenXMaxY.Content = "";
        //                lblDispCenXMinY.Content = "";
        //            }));

        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CENTER Z Range is OUT OF RANGE");
        //            retval.execResult = -2;
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + HeightCT.ToString("0.0000"), Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }


        //        if (pattern.headValue.sensorPosition == 0)  // RIGHT
        //        {
        //            gMinX -= (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            gMaxX -= (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //        }
        //        else                                       // LEFT
        //        {
        //            gMinX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            gMaxX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //        }

        //        // Sensor Shift compensation
        //        Dispatcher.Invoke(new Action(delegate
        //        {
        //            lblDispCenXCenY.Foreground = Brushes.Black;
        //            lblDispCenXCenY.Content = HeightCT.ToString("0.000");       // Sensor shift value 
        //            lblDispMinXMaxY.Content = "";
        //            lblDispMinXMinY.Content = "";
        //            lblDispMaxXMaxY.Content = "";
        //            lblDispMaxXMinY.Content = "";
        //            lblDispCenXMaxY.Content = "";
        //            lblDispCenXMinY.Content = "";
        //        }));

        //        tCX = (short)(((double)gMaxX + (double)gMinX) / 2.0 + 0.5);
        //        tCY = (short)(((double)gMaxY + (double)gMinY) / 2.0 + 0.5);

        //        double[] vCheckPosX = new double[] { gMinX, gMinX, tCX, gMaxX, gMaxX, tCX, tCX };
        //        double[] vCheckPosY = new double[] { gMaxY, gMinY, gMinY, gMinY, gMaxY, gMaxY, tCY };

        //        Vector3D[] vAddPos = new Vector3D[7];
        //        double left = MinX - CP.X;
        //        double centerX = (MaxX + MinX) / 2.0 - CP.X;
        //        double right = MaxX - CP.X;
        //        double up = MaxY - CP.Y;
        //        double centerY = (MaxY + MinY) / 2.0 - CP.Y;
        //        double down = MinY - CP.Y;

        //        double[] vAddPosX = new double[] { left, left, centerX, right, right, centerX, centerX };
        //        double[] vAddPosY = new double[] { up, down, down, down, up, up, centerY };

        //        Label[] lblValue = new Label[] { lblDispMinXMaxY, lblDispMinXMinY, lblDispCenXMinY, lblDispMaxXMinY, lblDispMaxXMaxY, lblDispCenXMaxY, lblDispCenXCenY };
        //        for (int i = 0; i < 7; i++)
        //        {
        //            vCheckPos[i].X = vCheckPosX[i];
        //            vCheckPos[i].Y = vCheckPosY[i];
        //            vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

        //            snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
        //            if (snsdata.execResult != 0)
        //            {
        //                retval.execResult = snsdata.execResult;
        //                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (i+1).ToString() + " - " + retval.execResult.ToString());
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
        //                return retval;
        //            }

        //            vAddPos[i].X = vAddPosX[i];
        //            vAddPos[i].Y = vAddPosY[i];
        //            vAddPos[i].Z = snsdata.sensoroffset;
        //            HeightVal[i] = snsdata.sensoroffset;
        //            if (Math.Abs(HeightVal[i]) > 20.0)
        //            {
        //                retval.ErrorDistanceSensor = true;
        //            }

        //            planePoints.Add(vAddPos[i]);
        //            if (lblValue[i] != null)
        //            {
        //                if (lblValue[i].CheckAccess())
        //                    lblValue[i].Content = HeightVal[i].ToString("0.000");
        //                else
        //                {
        //                    lblValue[i].Dispatcher.Invoke(new Action(delegate
        //                    {
        //                        lblValue[i].Content = HeightVal[i].ToString("0.000");
        //                    }));
        //                }
        //            }
        //        }

        //        // Laser Aiming Beam OFF
        //        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
        //        ShowRectangle(AimingLamp, Brushes.Black);

        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }


        //        if (retval.ErrorDistanceSensor)
        //        {
        //            Vector3D TmpPoint = new Vector3D();
        //            planePoints.Clear();

        //            HeightCT0 = HeightCT;
        //            HeightCT = 20.0;

        //            TmpPoint.X = MinX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);
        //            TmpPoint.X = MinX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);
        //            TmpPoint.X = CX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);
        //            TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);
        //            TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);
        //            TmpPoint.X = CX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);
        //            TmpPoint.X = CX - CP.X; TmpPoint.Y = CY - CP.Y; TmpPoint.Z = 20.0; planePoints.Add(TmpPoint);

        //            // ?????
        //        }

        //        HeightCT = vAddPos[6].Z;

        //        CenterZ += (short)(HeightCT * pattern.headValue.stepLength + 0.5);

        //        //// REL mm at 4 Corners, CD
        //        PointLU.X = SP1.X - CP.X;
        //        PointLU.Y = SP1.Y - CP.Y + pattern.fontValue.height;
        //        PointLD.Y = SP1.Y - CP.Y;
        //        PointRU.X = SP1.X - CP.X + totWidth;
        //        ////
        //        Vector3D Sum = new Vector3D();
        //        foreach (var mPoint in planePoints)
        //        {
        //            Sum.X += mPoint.X; Sum.Y += mPoint.Y; Sum.Z += mPoint.Z;
        //        }
        //        Vector3D Centroid = new Vector3D();
        //        Centroid.X = Sum.X / planePoints.Count;
        //        Centroid.Y = Sum.Y / planePoints.Count;
        //        Centroid.Z = Sum.Z / planePoints.Count;
        //        double xx, xy, xz, yy, yz, zz;
        //        xx = xy = xz = yy = yz = zz = 0.0;
        //        foreach (var mPoint in planePoints)
        //        {
        //            xx += (mPoint.X - Centroid.X) * (mPoint.X - Centroid.X);
        //            xy += (mPoint.X - Centroid.X) * (mPoint.Y - Centroid.Y);
        //            xz += (mPoint.X - Centroid.X) * (mPoint.Z - Centroid.Z);
        //            yy += (mPoint.Y - Centroid.Y) * (mPoint.Y - Centroid.Y);
        //            yz += (mPoint.Y - Centroid.Y) * (mPoint.Z - Centroid.Z);
        //            zz += (mPoint.Z - Centroid.Z) * (mPoint.Z - Centroid.Z);
        //        }

        //        retval.NormalDir.X = xy * yz - xz * yy;
        //        retval.NormalDir.Y = xy * xz - yz * xx;
        //        retval.NormalDir.Z = xx * yy - xy * xy;

        //        double Ds = retval.NormalDir.X * Centroid.X + retval.NormalDir.Y * Centroid.Y + retval.NormalDir.Z * Centroid.Z;


        //        ////
        //        double PlaneLU = GetZfromPlane(PointLU.X, PointLU.Y);
        //        double PlaneLD = GetZfromPlane(PointLU.X, PointLD.Y);
        //        double PlaneRU = GetZfromPlane(PointRU.X, PointLU.Y);
        //        double PlaneRD = GetZfromPlane(PointRU.X, PointLD.Y);
        //        double PlaneCU = GetZfromPlane(0, PointLU.Y);
        //        double PlaneCD = GetZfromPlane(0, PointLD.Y);

        //        retval.PlaneCenterZ = GetZfromPlane(0, 0);

        //        double PdiffLU, PdiffLD, PdiffRD, PdiffRU, PdiffCU, PdiffCD;
        //        PdiffLU = PlaneLU - retval.PlaneCenterZ;
        //        PdiffLD = PlaneLD - retval.PlaneCenterZ;
        //        PdiffRU = PlaneRU - retval.PlaneCenterZ;
        //        PdiffRD = PlaneRD - retval.PlaneCenterZ;
        //        PdiffCU = PlaneCU - retval.PlaneCenterZ;
        //        PdiffCD = PlaneCD - retval.PlaneCenterZ;
        //        double PminDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
        //        double PmaxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
        //        double PdiffDiff = Math.Abs(PmaxDiff - PminDiff);

        //        ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", "NORMALDIR = " + retval.NormalDir.X.ToString("F4") + ", " + retval.NormalDir.Y.ToString("F4") + ", " + retval.NormalDir.Z.ToString("F4") + ", PLANECENTERZ = " + retval.PlaneCenterZ.ToString("F4"));

        //        if (PdiffDiff > 1.0)
        //        {
        //            Debug.WriteLine(string.Format("ERROR => Too much inclined Plate : {0:F3} mm", PdiffDiff));
        //            // Error handling required!!
        //        }

        //        Dispatcher.Invoke(new Action(delegate
        //        {
        //            lblDispCenXCenY.Foreground = (retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.DarkGreen;
        //            lblDispCenXCenY.Content = retval.PlaneCenterZ.ToString("0.000;-0.000;0.000");

        //            TxtZeroOffset.Content = retval.PlaneCenterZ.ToString("0.000;-0.000;0.000");

        //            lblDispMinXMaxY.Foreground = (PdiffLU > 0 || retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
        //            lblDispMinXMaxY.Content = PdiffLU.ToString("+ 0.000;- 0.000;0.000");

        //            lblDispMinXMinY.Foreground = (PdiffLD > 0 || retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
        //            lblDispMinXMinY.Content = PdiffLD.ToString("+ 0.000;- 0.000;0.000");

        //            lblDispMaxXMaxY.Foreground = (PdiffRU > 0 || retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
        //            lblDispMaxXMaxY.Content = PdiffRU.ToString("+ 0.000;- 0.000;0.000");

        //            lblDispMaxXMinY.Foreground = (PdiffRD > 0 || retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
        //            lblDispMaxXMinY.Content = PdiffRD.ToString("+ 0.000;- 0.000;0.000");

        //            lblDispCenXMaxY.Foreground = (PdiffCU > 0 || retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
        //            lblDispCenXMaxY.Content = PdiffCU.ToString("+ 0.000;- 0.000;0.000");

        //            lblDispCenXMinY.Foreground = (PdiffCD > 0 || retval.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
        //            lblDispCenXMinY.Content = PdiffCD.ToString("+ 0.000;- 0.000;0.000");
        //        }
        //        ));

        //        int jc = (int)((PointLU.Y - PointLD.Y) + 0.5);
        //        int ic = (int)((PointRU.X - PointLU.X) + 0.5);
        //        byte[,] HC = new byte[jc, ic];

        //        double Yy = PointLU.Y;
        //        double Xx = PointLU.X;
        //        double Zz = 0;
        //        for (int r = 0; r < jc; r++)
        //        {
        //            Xx = PointLU.X;
        //            for (int c = 0; c < ic; c++)
        //            {
        //                Zz = (GetZfromPlane(Xx, Yy) - GetZfromPlane(0, 0)) * 200.0;
        //                if (Zz > 127.0) Zz = 127.0;
        //                if (Zz < -127.0) Zz = -127.0;
        //                HC[r, c] = (byte)(Zz + 127.0);
        //                Xx += 1.0;  // +1 mm;
        //            }
        //            Yy -= 1.0;      // -1 mm;
        //        }

        //        Dispatcher.Invoke(new Action(delegate
        //        {
        //            PlateColoring(HC);
        //        }));

        //        retval.bReady = true;

        //        double GetZfromPlane(double x, double y)
        //        {
        //            double pz;
        //            if (retval.NormalDir.Z != 0)
        //                pz = Ds / retval.NormalDir.Z - retval.NormalDir.X / retval.NormalDir.Z * x - retval.NormalDir.Y / retval.NormalDir.Z * y;
        //            else
        //                pz = 0;
        //            return pz;
        //        }
        //        return retval;
        //    }
        //    catch (Exception ex)
        //    {
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //        retval.execResult = ex.HResult;
        //        return retval;
        //    }
        //}


        //public async Task<CheckAreaData> Range_Test4High(string cmd, string vin, PatternValueEx pattern, byte errHeightFlag, byte errClineFlag)   // Plating  by TM SHIN
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "Range_Test4High";

        //    CheckAreaData retval = new CheckAreaData();
        //    distanceSensorData snsdata = new distanceSensorData();
        //    ITNTResponseArgs respArg = new ITNTResponseArgs();

        //    int vinLength;
        //    double totWidth = 0;

        //    Vector3D SP0 = new Vector3D();
        //    Vector3D SP1 = new Vector3D();
        //    Vector3D CP = new Vector3D();

        //    Vector3D PointLU = new Vector3D();
        //    Vector3D PointLD = new Vector3D();
        //    Vector3D PointRU = new Vector3D();

        //    Vector3D[] vCheckPos = new Vector3D[7];
        //    double[] HeightVal = new double[7];
        //    Vector3D vector3 = new Vector3D();

        //    double HeightCT0 = 0;
        //    string value = "";
        //    string log = "";
        //    byte bHeadType = 0;
        //    string fName = "";

        //    List<Vector3D> planePoints = new List<Vector3D>();

        //    short gMinX = 0;
        //    short gMaxX = 0;
        //    short gMinY = 0;
        //    short gMaxY = 0;
        //    //short? CenterX = null;
        //    //short? CenterY = null;
        //    //short? CenterZ = null;

        //    //double SpX, SpY, SpZ, Ht, Wd, Pt, Ag;
        //    //double AZ = 0.0;
        //    //string AreaPosition = "";

        //    try
        //    {
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

        //        Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
        //        byte.TryParse(value, out bHeadType);

        //        vinLength = vin.Length;
        //        if (vinLength <= 0)
        //        {
        //            log = "EMPTY VIN (LENGTH <= " + vinLength.ToString() + ")";
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = -1;
        //            retval.sErrorMessage = log;
        //            return retval;
        //        }

        //        if (cbxPatternList.SelectedIndex >= 0)
        //            fName = cbxPatternList.SelectedItem.ToString();
        //        else
        //        {
        //            log = "SELECT PATTERN";
        //            retval.sErrorMessage = log;
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //            return retval;
        //        }


        //        if (ckbSkipCheckPlane.IsChecked == true)
        //        {
        //            retval.NormalDir.X = 0;
        //            retval.NormalDir.Y = 0;
        //            retval.NormalDir.Z = 1;

        //            retval.bReady = true;
        //            retval.execResult = 0;
        //            return retval;
        //        }

        //        // Laser Beam ON
        //        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - SET BEAM CONTROLL ERROR : " + respArg.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET BEAM CONTROLL ERROR - " + respArg.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }

        //        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - BEAM ON ERROR : " + respArg.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM ON ERROR - " + respArg.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }
        //        ShowRectangle(AimingLamp, Brushes.Red);

        //        //txtAreaPosition.Text = "25.0";
        //        //Util.GetPrivateProfileValue("PLATE", "AREAPOSITION", "25.0", ref AreaPosition, Constants.PARAMS_INI_FILE);
        //        //AreaPosition = txtAreaPosition.Text;
        //        //AZ = double.Parse(AreaPosition);

        //        totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

        //        CP = pattern.positionValue.center3DPos;
        //        //if (AZ < CP.Z) AZ = CP.Z;

        //        SP0.X = totWidth / 2;
        //        SP0.Y = pattern.fontValue.height / 2;
        //        SP0.Z = 0;

        //        SP1 = CP - SP0; SP1.Z = CP.Z;




        //        // ABS mm
        //        double MinX = SP1.X;
        //        double MaxX = SP1.X + totWidth;
        //        double MinY = SP1.Y;
        //        double MaxY = SP1.Y + pattern.fontValue.height;

        //        //Mode_File.dMinX = MinX;
        //        //Mode_File.dMaxX = MaxX;
        //        //Mode_File.dMinY = MinY;
        //        //Mode_File.dMaxY = MaxY;

        //        // ABS BLU
        //        gMinX = (short)(MinX * pattern.headValue.stepLength + 0.5);
        //        gMaxX = (short)(MaxX * pattern.headValue.stepLength + 0.5);
        //        gMinY = (short)(MinY * pattern.headValue.stepLength + 0.5);
        //        gMaxY = (short)(MaxY * pattern.headValue.stepLength + 0.5);

        //        // ABS mm
        //        //double CX = (MaxX + MinX) / 2.0;
        //        //double CY = (MaxY + MinY) / 2.0;
        //        double CX = CP.X;
        //        double CY = CP.Y;

        //        // ABS BLU
        //        short tCX = (short)(CX * pattern.headValue.stepLength + 0.5);
        //        short tCY = (short)(CY * pattern.headValue.stepLength + 0.5);
        //        //Mode_File.CenterX = tCX;
        //        //Mode_File.CenterY = tCY;
        //        //Mode_File.CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);
        //        //CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);
        //        retval.centerPoint.X = CX;
        //        retval.centerPoint.Y = CY;
        //        retval.centerPoint.Z = CP.Z;
        //        retval.centerPointBLU.X = tCX;
        //        retval.centerPointBLU.Y = tCY;
        //        retval.centerPointBLU.Z = (short)(CP.Z * pattern.headValue.stepLength + 0.5);
        //        //CenterZ = (short)(CP.Z * pattern.headValue.stepLength + 0.5);


        //        respArg = await SendMotorSpeed("RANGE_TEST", (byte)motorSpeedType.MeasureMoving);
        //        if (respArg.execResult != 0)
        //        {
        //            //return retval;
        //            log = "CHECK PLATE FAIL - SET MOTOR SPEED(MEASURE) ERROR = " + respArg.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET MOTOR SPEED(MEASURE) ERROR - " + respArg.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }

        //        //m_currCMD = (byte)'M';
        //        //respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(tCX, tCY, (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5), 0);
        //        //if (respArg.execResult != 0)
        //        //{
        //        //    return retval;
        //        //}


        //        //respArg = await SendMotorSpeed("RANGE_TEST", (byte)motorSpeedType.MeasureMoving);
        //        //if (respArg.execResult != 0)
        //        //{
        //        //    return retval;
        //        //}

        //        vector3 = new Vector3D(tCX, tCY, (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5));
        //        snsdata = await GetMeasureLength(vector3, 0, 1);
        //        if (snsdata.execResult != 0)
        //        {
        //            retval.execResult = snsdata.execResult;
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR 0 - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CT) : ERROR = " + snsdata.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
        //            return retval;
        //        }

        //        double ShiftCT = snsdata.sensorshift;
        //        double HeightCT = snsdata.sensoroffset;
        //        double sensorDistance = snsdata.rawdistance;

        //        if (Math.Abs(HeightCT) > pattern.positionValue.checkDistanceHeight)      // Z Diff Max. 60mm
        //        {
        //            retval.ErrorDistanceSensor = true;
        //            ShowLabelData2(lblDispCenXCenY, HeightCT.ToString("0.000"), Brushes.Red, null);
        //            //ShowLabelColor(lblDispCenXCenY, Brushes.Red, null);

        //            ShowLabelData(lblDispMinXMaxY, "");
        //            ShowLabelData(lblDispMinXMinY, "");
        //            ShowLabelData(lblDispMaxXMaxY, "");
        //            ShowLabelData(lblDispMaxXMinY, "");
        //            ShowLabelData(lblDispCenXMaxY, "");
        //            ShowLabelData(lblDispCenXMinY, "");

        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CENTER Z Range is OUT OF RANGE : " + HeightCT.ToString("F3"));
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + HeightCT.ToString("0.0000"), Thread.CurrentThread.ManagedThreadId);
        //            if (errHeightFlag == 0)
        //            {
        //                retval.execResult = -2;
        //                return retval;
        //            }
        //        }

        //        if (pattern.headValue.sensorPosition == 0)      //RIGHT
        //        {
        //            gMinX -= (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            if (gMinX < pattern.headValue.stepLength) // 1mm                            // && 7
        //                gMinX = pattern.headValue.stepLength;                                   // && 7

        //            gMaxX -= (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            if (gMaxX > (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength))    // MAX_X - 1mm   // && 7
        //                gMaxX = (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength);                     // && 7
        //        }
        //        else
        //        {
        //            gMinX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            if (gMinX < (short)pattern.headValue.stepLength)                                         // && 7
        //            {
        //                gMinX = (short)pattern.headValue.stepLength;
        //                MinX = 1.0 - ShiftCT;
        //            }
        //            gMaxX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            if (gMaxX > (short)(pattern.headValue.max_X - pattern.headValue.stepLength))                     // && 7
        //            {
        //                gMaxX = (short)(pattern.headValue.max_X - pattern.headValue.stepLength);                     // && 7
        //                MaxX = pattern.headValue.max_X / pattern.headValue.stepLength - ShiftCT - 1.0;
        //            }
        //            tCX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);

        //            //gMinX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            //if (gMinX < pattern.headValue.stepLength) // 1mm                            // && 7
        //            //    gMinX = pattern.headValue.stepLength;
        //            //gMaxX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
        //            //if (gMaxX > (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength))    // MAX_X - 1mm   // && 7
        //            //    gMaxX = (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength);                     // && 7
        //        }

        //        ShowLabelData2(lblDispCenXCenY, HeightCT.ToString("0.000"), Brushes.Black, null);

        //        ShowLabelData(lblDispMinXMaxY, "");
        //        ShowLabelData(lblDispMinXMinY, "");
        //        ShowLabelData(lblDispMaxXMaxY, "");
        //        ShowLabelData(lblDispMaxXMinY, "");
        //        ShowLabelData(lblDispCenXMaxY, "");
        //        ShowLabelData(lblDispCenXMinY, "");

        //        //tCX = (short)((gMaxX + gMinX) / 2.0 + 0.5);
        //        //tCY = (short)((gMaxY + gMinY) / 2.0 + 0.5);

        //        double[] vCheckPosX = new double[] { gMinX, gMinX, tCX, gMaxX, gMaxX, tCX, tCX };
        //        double[] vCheckPosY = new double[] { gMaxY, gMinY, gMinY, gMinY, gMaxY, gMaxY, tCY };

        //        Vector3D[] vAddPos = new Vector3D[7];
        //        double left = MinX - CP.X;
        //        double centerX = CX - CP.X;
        //        double right = MaxX - CP.X;
        //        double up = MaxY - CP.Y;
        //        double centerY = CY - CP.Y;
        //        double down = MinY - CP.Y;

        //        double[] vAddPosX = new double[] { left, left, centerX, right, right, centerX, centerX };
        //        double[] vAddPosY = new double[] { up, down, down, down, up, up, centerY };

        //        Label[] lblValue = new Label[] { lblDispMinXMaxY, lblDispMinXMinY, lblDispCenXMinY, lblDispMaxXMinY, lblDispMaxXMaxY, lblDispCenXMaxY, lblDispCenXCenY };
        //        for (int i = 0; i < 7; i++)
        //        {
        //            vCheckPos[i].X = vCheckPosX[i];
        //            vCheckPos[i].Y = vCheckPosY[i];
        //            vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

        //            snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
        //            if (snsdata.execResult != 0)
        //            {
        //                retval.execResult = snsdata.execResult;
        //                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (i + 1).ToString() + " - " + retval.execResult.ToString());
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
        //                return retval;
        //            }

        //            vAddPos[i].X = vAddPosX[i];
        //            vAddPos[i].Y = vAddPosY[i];
        //            vAddPos[i].Z = snsdata.sensoroffset;
        //            HeightVal[i] = snsdata.sensoroffset;
        //            if (Math.Abs(HeightVal[i]) > pattern.positionValue.checkDistanceHeight)
        //            {
        //                retval.ErrorDistanceSensor = true;
        //                retval.sErrorMessage = "";
        //            }

        //            planePoints.Add(vAddPos[i]);
        //            ShowLabelData(lblValue[i], HeightVal[i].ToString("0.000"));
        //            HeightCT = HeightVal[i];    // TM SHIN
        //        }

        //        // Laser Aiming Beam OFF
        //        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
        //        ShowRectangle(AimingLamp, Brushes.Black);

        //        if (respArg.execResult != 0)
        //        {
        //            log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = respArg.execResult;
        //            return retval;
        //        }


        //        if (retval.ErrorDistanceSensor)
        //        {
        //            Vector3D TmpPoint = new Vector3D();
        //            planePoints.Clear();

        //            HeightCT0 = HeightCT;
        //            HeightCT = pattern.positionValue.checkDistanceHeight;

        //            TmpPoint.X = MinX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
        //            TmpPoint.X = MinX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
        //            TmpPoint.X = CX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
        //            TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
        //            TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
        //            TmpPoint.X = CX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
        //            TmpPoint.X = CX - CP.X; TmpPoint.Y = CY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);


        //            log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
        //            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //            if (errHeightFlag == 0)
        //            {
        //                retval.execResult = -4;
        //                return retval;
        //            }
        //        }


        //        //double D_0_Gap_Z = CP.Z + pattern.headValue.distance0Position;                                                                     // && 8             // mm

        //        //CenterZ += (short)(HeightCT * pattern.headValue.stepLength + 0.5);

        //        //// REL mm at 4 Corners, CD
        //        PointLU.X = SP1.X - CP.X;
        //        PointLU.Y = SP1.Y + pattern.fontValue.height - CP.Y;
        //        PointLD.Y = SP1.Y - CP.Y;
        //        PointRU.X = SP1.X + totWidth - CP.X;
        //        ////
        //        ///
        //        Vector3D Sum = new Vector3D();
        //        foreach (var mPoint in planePoints)
        //        {
        //            Sum.X += mPoint.X; Sum.Y += mPoint.Y; Sum.Z += mPoint.Z;
        //        }

        //        Vector3D Centroid = new Vector3D();
        //        Centroid.X = Sum.X / planePoints.Count;
        //        Centroid.Y = Sum.Y / planePoints.Count;
        //        Centroid.Z = Sum.Z / planePoints.Count;
        //        double xx, xy, xz, yy, yz, zz;
        //        xx = xy = xz = yy = yz = zz = 0.0;
        //        foreach (var mPoint in planePoints)
        //        {
        //            xx += (mPoint.X - Centroid.X) * (mPoint.X - Centroid.X);
        //            xy += (mPoint.X - Centroid.X) * (mPoint.Y - Centroid.Y);
        //            xz += (mPoint.X - Centroid.X) * (mPoint.Z - Centroid.Z);
        //            yy += (mPoint.Y - Centroid.Y) * (mPoint.Y - Centroid.Y);
        //            yz += (mPoint.Y - Centroid.Y) * (mPoint.Z - Centroid.Z);
        //            zz += (mPoint.Z - Centroid.Z) * (mPoint.Z - Centroid.Z);
        //        }
        //        retval.NormalDir.X = xy * yz - xz * yy;
        //        retval.NormalDir.Y = xy * xz - yz * xx;
        //        retval.NormalDir.Z = xx * yy - xy * xy;

        //        double Ds = retval.NormalDir.X * Centroid.X + retval.NormalDir.Y * Centroid.Y + retval.NormalDir.Z * Centroid.Z;
        //        ////

        //        //double diffLU, diffLD, diffRD, diffRU, diffCU, diffCD;
        //        //diffLU = HeightLU - Mode_File.HeightCT;
        //        //diffLD = HeightLD - Mode_File.HeightCT;
        //        //diffRU = Mode_File.HeightRU - Mode_File.HeightCT;
        //        //diffRD = Mode_File.HeightRD - Mode_File.HeightCT;
        //        //diffCU = Mode_File.HeightCU - Mode_File.HeightCT;
        //        //diffCD = Mode_File.HeightCD - Mode_File.HeightCT;
        //        //double minDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
        //        //double maxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
        //        //double diffDiff = Math.Abs(maxDiff - minDiff);

        //        ////
        //        double PlaneLU = GetZfromPlane(PointLU.X, PointLU.Y);
        //        double PlaneLD = GetZfromPlane(PointLU.X, PointLD.Y);
        //        double PlaneRU = GetZfromPlane(PointRU.X, PointLU.Y);
        //        double PlaneRD = GetZfromPlane(PointRU.X, PointLD.Y);
        //        double PlaneCU = GetZfromPlane(0, PointLU.Y);
        //        double PlaneCD = GetZfromPlane(0, PointLD.Y);
        //        retval.PlaneCenterZ = GetZfromPlane(0, 0);

        //        //CenterZ = (short)((CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ) * (double)pattern.headValue.stepLength + 0.5);              // BLU // && 8
        //        retval.centerPoint.Z = CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ;
        //        retval.centerPointBLU.Z = (short)((CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ) * (double)pattern.headValue.stepLength + 0.5);

        //        double PdiffLU, PdiffLD, PdiffRD, PdiffRU, PdiffCU, PdiffCD;
        //        PdiffLU = PlaneLU - retval.PlaneCenterZ;
        //        PdiffLD = PlaneLD - retval.PlaneCenterZ;
        //        PdiffRU = PlaneRU - retval.PlaneCenterZ;
        //        PdiffRD = PlaneRD - retval.PlaneCenterZ;
        //        PdiffCU = PlaneCU - retval.PlaneCenterZ;
        //        PdiffCD = PlaneCD - retval.PlaneCenterZ;
        //        double PminDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
        //        double PmaxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
        //        double PdiffDiff = Math.Abs(PmaxDiff - PminDiff);

        //        if (PdiffDiff > 5.0)
        //        {
        //            Debug.WriteLine(string.Format("ERROR => Too much inclined Plate : {0:F3} mm", PdiffDiff));
        //            log = string.Format("ERROR => Too much inclined Plate : {0:F3} mm", PdiffDiff);
        //            ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", log, log);

        //            // Error handling required!!
        //            if (errClineFlag == 0)
        //            {
        //                retval.execResult = -5;
        //                return retval;
        //            }
        //        }

        //        ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", "NORMALDIR = " + retval.NormalDir.X.ToString("F4") + ", " + retval.NormalDir.Y.ToString("F4") + ", " + retval.NormalDir.Z.ToString("F4") + ", PLANECENTERZ = " + retval.PlaneCenterZ.ToString("F4"));


        //        ShowLabelData2(lblDispCenXCenY, retval.PlaneCenterZ.ToString("0.000;-0.000;0.000"), Brushes.DarkGreen, null);
        //        if (PdiffLU > 0)
        //            ShowLabelData2(lblDispMinXMaxY, PdiffLU.ToString("+ 0.000;- 0.000;0.000"), Brushes.LightSkyBlue, null);
        //        else
        //            ShowLabelData2(lblDispMinXMaxY, PdiffLU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);

        //        if (PdiffLD > 0)
        //            ShowLabelData2(lblDispMinXMinY, PdiffLD.ToString("+ 0.000;- 0.000;0.000"), Brushes.LightSkyBlue, null);
        //        else
        //            ShowLabelData2(lblDispMinXMinY, PdiffLD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);

        //        if (PdiffRU > 0)
        //            ShowLabelData2(lblDispMaxXMaxY, PdiffRU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
        //        else
        //            ShowLabelData2(lblDispMaxXMaxY, PdiffRU.ToString("+ 0.000;- 0.000;0.000"), Brushes.LightSkyBlue, null);

        //        if (PdiffRD > 0)
        //            ShowLabelData2(lblDispMaxXMinY, PdiffRD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
        //        else
        //            ShowLabelData2(lblDispMaxXMinY, PdiffRD.ToString("+ 0.000;- 0.000;0.000"), Brushes.LightSkyBlue, null);

        //        if (PdiffCU > 0)
        //            ShowLabelData2(lblDispCenXMaxY, PdiffCU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
        //        else
        //            ShowLabelData2(lblDispCenXMaxY, PdiffCU.ToString("+ 0.000;- 0.000;0.000"), Brushes.LightSkyBlue, null);

        //        if (PdiffCD > 0)
        //            ShowLabelData2(lblDispCenXMinY, PdiffCD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
        //        else
        //            ShowLabelData2(lblDispCenXMinY, PdiffCD.ToString("+ 0.000;- 0.000;0.000"), Brushes.LightSkyBlue, null);


        //        //ShowLabelData(TxtZeroOffset, retval.PlaneCenterZ.ToString("0.000;-0.000;0.000"));
        //        //Console.WriteLine(String.Format("Normal Vector ({0:F4},{1:F4},{2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ));

        //        //ControlWindow.Dispatcher.Invoke(new Action(delegate
        //        //{
        //        //    var NormalStr = String.Format("Normal Vector ({0:F4}, {1:F4}, {2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ);
        //        //    ControlWindow.txt_log.AppendText(NormalStr + Environment.NewLine);

        //        //    ControlWindow.normalX.Content = Mode_File.NormalDir.X.ToString("F4");
        //        //    ControlWindow.normalY.Content = Mode_File.NormalDir.Y.ToString("F4");
        //        //    ControlWindow.normalZ.Content = Mode_File.NormalDir.Z.ToString("F4");
        //        //    ControlWindow.planeZ.Content = Mode_File.PlaneCenterZ.ToString("F4");

        //        //    ControlWindow.lblDispCenXCenY.Foreground = (Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.DarkGreen;
        //        //    ControlWindow.lblDispCenXCenY.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

        //        //    ControlWindow.TxtZeroOffset.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

        //        //    ControlWindow.lblDispMinXMaxY.Foreground = (PdiffLU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
        //        //    ControlWindow.lblDispMinXMaxY.Content = PdiffLU.ToString("+ 0.000;- 0.000;0.000");

        //        //    ControlWindow.lblDispMinXMinY.Foreground = (PdiffLD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
        //        //    ControlWindow.lblDispMinXMinY.Content = PdiffLD.ToString("+ 0.000;- 0.000;0.000");

        //        //    ControlWindow.lblDispMaxXMaxY.Foreground = (PdiffRU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
        //        //    ControlWindow.lblDispMaxXMaxY.Content = PdiffRU.ToString("+ 0.000;- 0.000;0.000");

        //        //    ControlWindow.lblDispMaxXMinY.Foreground = (PdiffRD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
        //        //    ControlWindow.lblDispMaxXMinY.Content = PdiffRD.ToString("+ 0.000;- 0.000;0.000");

        //        //    ControlWindow.lblDispCenXMaxY.Foreground = (PdiffCU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
        //        //    ControlWindow.lblDispCenXMaxY.Content = PdiffCU.ToString("+ 0.000;- 0.000;0.000");

        //        //    ControlWindow.lblDispCenXMinY.Foreground = (PdiffCD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
        //        //    ControlWindow.lblDispCenXMinY.Content = PdiffCD.ToString("+ 0.000;- 0.000;0.000");
        //        //}
        //        //));

        //        int jc = (int)((PointLU.Y - PointLD.Y) + 0.5);
        //        int ic = (int)((PointRU.X - PointLU.X) + 0.5);
        //        byte[,] HC = new byte[jc, ic];

        //        double Yy = PointLU.Y;
        //        double Xx = PointLU.X;
        //        double Zz = 0;
        //        for (int r = 0; r < jc; r++)
        //        {
        //            Xx = PointLU.X;
        //            for (int c = 0; c < ic; c++)
        //            {
        //                Zz = (GetZfromPlane(Xx, Yy) - GetZfromPlane(0, 0)) * 200.0;
        //                if (Zz > 127.0) Zz = 127.0;
        //                if (Zz < -127.0) Zz = -127.0;
        //                HC[r, c] = (byte)(Zz + 127.0);
        //                Xx += 1.0;  // +1 mm;
        //            }
        //            Yy -= 1.0;      // -1 mm;
        //        }

        //        Dispatcher.Invoke(new Action(delegate
        //        {
        //            PlateColoring(HC);
        //        }));


        //        double GetZfromPlane(double x, double y)
        //        {
        //            double pz;
        //            if (retval.NormalDir.Z != 0)
        //                pz = Ds / retval.NormalDir.Z - retval.NormalDir.X / retval.NormalDir.Z * x - retval.NormalDir.Y / retval.NormalDir.Z * y;
        //            else
        //                pz = 0;
        //            return pz;
        //        }

        //        return retval;
        //    }
        //    catch (Exception ex)
        //    {
        //        retval.execResult = ex.HResult;
        //        log = "EXCEPTION. ERROR = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
        //        retval.sErrorMessage = log;
        //        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
        //    }

        //    return retval;
        //} //End of Function


        public async Task<CheckAreaData> Range_Test(string cmd, string vin, PatternValueEx pattern, byte errHeightFlag, byte errClineFlag)   // Plating  by TM SHIN
        {
            string className = "SetControllerWindow3";
            string funcName = "Range_Test";

            CheckAreaData retval = new CheckAreaData();
            distanceSensorData snsdata = new distanceSensorData();
            ITNTResponseArgs respArg = new ITNTResponseArgs();
            HeadValue headValue = new HeadValue();

            int vinLength;
            double totWidth = 0;

            Vector3D SP0 = new Vector3D();
            Vector3D SP1 = new Vector3D();
            Vector3D CP = new Vector3D();

            Vector3D PointLU = new Vector3D();
            Vector3D PointLD = new Vector3D();
            Vector3D PointRU = new Vector3D();

            Vector3D[] vCheckPos = new Vector3D[7];
            double[] HeightVal = new double[7];
            Vector3D vector3 = new Vector3D();

            double HeightCT0 = 0;
            string value = "";
            string log = "";
            byte bHeadType = 0;
            string fName = "";

            List<Vector3D> planePoints = new List<Vector3D>();

            short gMinX = 0;
            short gMaxX = 0;
            short gMinY = 0;
            short gMaxY = 0;
            //short? CenterX = null;
            //short? CenterY = null;
            //short? CenterZ = null;

            //double SpX, SpY, SpZ, Ht, Wd, Pt, Ag;
            //double AZ = 0.0;
            //string AreaPosition = "";

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);

                ReadPatternHeadValue(ref headValue);

                vinLength = vin.Length;
                if (vinLength <= 0)
                {
                    log = "EMPTY VIN (LENGTH <= " + vinLength.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    retval.execResult = -1;
                    retval.errorInfo.sErrorMessage = log;
                    return retval;
                }

                if (cbxPatternList.SelectedIndex >= 0)
                    fName = cbxPatternList.SelectedItem.ToString();
                else
                {
                    log = "SELECT PATTERN";
                    retval.errorInfo.sErrorMessage = log;
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    return retval;
                }


                if (ckbSkipCheckPlane.IsChecked == true)
                {
                    retval.NormalDir.X = 0;
                    retval.NormalDir.Y = 0;
                    retval.NormalDir.Z = 1;

                    retval.bReady = true;
                    retval.execResult = 0;
                    return retval;
                }

#if LASER_OFF
#else
                // Laser Beam ON
                respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                    if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                }
                if (respArg.execResult != 0)
                {
                    log = "CHECK PLATE FAIL - SET BEAM CONTROLL ERROR : " + respArg.execResult.ToString();
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET BEAM CONTROLL ERROR - " + respArg.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    retval.execResult = respArg.execResult;
                    return retval;
                }

                respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                    if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                }
                if (respArg.execResult != 0)
                {
                    log = "CHECK PLATE FAIL - BEAM ON ERROR : " + respArg.execResult.ToString();
                    //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM ON ERROR - " + respArg.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //retval.execResult = respArg.execResult;
                    //return retval;
                }
                else
                    ShowRectangle(AimingLamp, Brushes.Red);
#endif
                //txtAreaPosition.Text = "25.0";
                //Util.GetPrivateProfileValue("PLATE", "AREAPOSITION", "25.0", ref AreaPosition, Constants.PARAMS_INI_FILE);
                //AreaPosition = txtAreaPosition.Text;
                //AZ = double.Parse(AreaPosition);

                totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

                CP = pattern.positionValue.center3DPos;
                //if (AZ < CP.Z) AZ = CP.Z;

                SP0.X = totWidth / 2;
                SP0.Y = pattern.fontValue.height / 2;
                SP0.Z = 0;

                SP1 = CP - SP0; SP1.Z = CP.Z;

                // ABS mm
                double MinX = SP1.X;
                double MaxX = SP1.X + totWidth;
                double MinY = SP1.Y;
                double MaxY = SP1.Y + pattern.fontValue.height;

                //Mode_File.dMinX = MinX;
                //Mode_File.dMaxX = MaxX;
                //Mode_File.dMinY = MinY;
                //Mode_File.dMaxY = MaxY;

                // ABS BLU
                gMinX = (short)(MinX * pattern.headValue.stepLength + 0.5);
                gMaxX = (short)(MaxX * pattern.headValue.stepLength + 0.5);
                gMinY = (short)(MinY * pattern.headValue.stepLength + 0.5);
                gMaxY = (short)(MaxY * pattern.headValue.stepLength + 0.5);

                // ABS mm
                double CX = (MaxX + MinX) / 2.0;
                double CY = (MaxY + MinY) / 2.0;


                // ABS BLU
                short tCX = (short)(CX * pattern.headValue.stepLength + 0.5);
                short tCY = (short)(CY * pattern.headValue.stepLength + 0.5);
                //Mode_File.CenterX = tCX;
                //Mode_File.CenterY = tCY;
                //Mode_File.CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);
                //CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);
                retval.centerPoint.X = CX;
                retval.centerPoint.Y = CY;
                retval.centerPoint.Z = CP.Z;
                retval.centerPointBLU.X = tCX;
                retval.centerPointBLU.Y = tCY;
                retval.centerPointBLU.Z = (short)(CP.Z * pattern.headValue.stepLength + 0.5);
                //CenterZ = (short)(CP.Z * pattern.headValue.stepLength + 0.5);


                respArg = await SendMotorSpeed("RANGE_TEST", (byte)motorSpeedType.MeasureMoving);
                if (respArg.execResult != 0)
                {
                    //return retval;
                    log = "CHECK PLATE FAIL - SET MOTOR SPEED(MEASURE) ERROR = " + respArg.execResult.ToString();
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET MOTOR SPEED(MEASURE) ERROR - " + respArg.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    retval.execResult = respArg.execResult;
                    return retval;
                }

                //m_currCMD = (byte)'M';
                //respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(tCX, tCY, (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5), 0);
                //if (respArg.execResult != 0)
                //{
                //    return retval;
                //}


                //respArg = await SendMotorSpeed("RANGE_TEST", (byte)motorSpeedType.MeasureMoving);
                //if (respArg.execResult != 0)
                //{
                //    return retval;
                //}

                vector3 = new Vector3D(tCX, tCY, (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5));
                snsdata = await GetMeasureLength(vector3, 0, 1);
                if (snsdata.execResult != 0)
                {
                    retval.execResult = snsdata.execResult;
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR 0 - " + retval.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CT) : ERROR = " + snsdata.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                double ShiftCT = snsdata.sensorshift;
                double HeightCT = snsdata.sensoroffset;

                if (Math.Abs(HeightCT) > pattern.positionValue.checkDistanceHeight)      // Z Diff Max. 60mm
                {
                    retval.ErrorDistanceSensor = true;
                    ShowLabelData2(lblDispCenXCenY, HeightCT.ToString("0.000"), Brushes.Red, null);
                    //ShowLabelColor(lblDispCenXCenY, Brushes.Red, null);

                    ShowLabelData(lblDispMinXMaxY, "");
                    ShowLabelData(lblDispMinXMinY, "");
                    ShowLabelData(lblDispMaxXMaxY, "");
                    ShowLabelData(lblDispMaxXMinY, "");
                    ShowLabelData(lblDispCenXMaxY, "");
                    ShowLabelData(lblDispCenXMinY, "");

                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CENTER Z Range is OUT OF RANGE : " + HeightCT.ToString("F3"));
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + HeightCT.ToString("0.0000"), Thread.CurrentThread.ManagedThreadId);
                    if (errHeightFlag == 0)
                    {
                        retval.execResult = -2;
                        return retval;
                    }
                }

                if (pattern.headValue.sensorPosition == 0)      //RIGHT
                {
                    gMinX -= (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
                    if (gMinX < pattern.headValue.stepLength) // 1mm                            // && 7
                        gMinX = pattern.headValue.stepLength;                                   // && 7

                    gMaxX -= (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
                    if (gMaxX > (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength))    // MAX_X - 1mm   // && 7
                        gMaxX = (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength);                     // && 7
                }
                else
                {
                    gMinX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
                    if (gMinX < pattern.headValue.stepLength) // 1mm                            // && 7
                        gMinX = pattern.headValue.stepLength;
                    gMaxX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
                    if (gMaxX > (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength))    // MAX_X - 1mm   // && 7
                        gMaxX = (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength);                     // && 7
                }

                ShowLabelData2(lblDispCenXCenY, HeightCT.ToString("0.000"), Brushes.Black, null);

                ShowLabelData(lblDispMinXMaxY, "");
                ShowLabelData(lblDispMinXMinY, "");
                ShowLabelData(lblDispMaxXMaxY, "");
                ShowLabelData(lblDispMaxXMinY, "");
                ShowLabelData(lblDispCenXMaxY, "");
                ShowLabelData(lblDispCenXMinY, "");

                tCX = (short)((gMaxX + gMinX) / 2.0 + 0.5);
                tCY = (short)((gMaxY + gMinY) / 2.0 + 0.5);

                double[] vCheckPosX = new double[] { gMinX, gMinX, tCX, gMaxX, gMaxX, tCX, tCX };
                double[] vCheckPosY = new double[] { gMaxY, gMinY, gMinY, gMinY, gMaxY, gMaxY, tCY };

                Vector3D[] vAddPos = new Vector3D[7];
                double left = MinX - CP.X;
                double centerX = CX - CP.X;
                double right = MaxX - CP.X;
                double up = MaxY - CP.Y;
                double centerY = CY - CP.Y;
                double down = MinY - CP.Y;

                double[] vAddPosX = new double[] { left, left, centerX, right, right, centerX, centerX };
                double[] vAddPosY = new double[] { up, down, down, down, up, up, centerY };

                Label[] lblValue = new Label[] { lblDispMinXMaxY, lblDispMinXMinY, lblDispCenXMinY, lblDispMaxXMinY, lblDispMaxXMaxY, lblDispCenXMaxY, lblDispCenXCenY };
                for (int i = 0; i < 7; i++)
                {
                    vCheckPos[i].X = vCheckPosX[i];
                    vCheckPos[i].Y = vCheckPosY[i];
                    vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

                    snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
                    if (snsdata.execResult != 0)
                    {
                        retval.execResult = snsdata.execResult;
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (i + 1).ToString() + " - " + retval.execResult.ToString());
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                        return retval;
                    }

                    vAddPos[i].X = vAddPosX[i];
                    vAddPos[i].Y = vAddPosY[i];
                    vAddPos[i].Z = snsdata.sensoroffset;
                    HeightVal[i] = snsdata.sensoroffset;
                    if (Math.Abs(HeightVal[i]) > pattern.positionValue.checkDistanceHeight)
                    {
                        retval.ErrorDistanceSensor = true;
                        retval.errorInfo.sErrorMessage = "";
                    }

                    planePoints.Add(vAddPos[i]);
                    ShowLabelData(HeightVal[i].ToString("0.000"), lblValue[i], Brushes.Blue);
                    HeightCT = HeightVal[i];    // TM SHIN
                }
#if LASER_OFF
#else

                // Laser Aiming Beam OFF
                respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                }

                //if (respArg.execResult != 0)
                //{
                //    log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //    retval.execResult = respArg.execResult;
                //    return retval;
                //}
                //else
                ShowRectangle(AimingLamp, Brushes.Black);
#endif

                if (retval.ErrorDistanceSensor)
                {
                    Vector3D TmpPoint = new Vector3D();
                    planePoints.Clear();

                    HeightCT0 = HeightCT;
                    HeightCT = pattern.positionValue.checkDistanceHeight;

                    TmpPoint.X = MinX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = MinX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = CX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = CX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = CX - CP.X; TmpPoint.Y = CY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);


                    log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    if (errHeightFlag == 0)
                    {
                        retval.execResult = -4;
                        return retval;
                    }
                }


                //double D_0_Gap_Z = CP.Z + pattern.headValue.distance0Position;                                                                     // && 8             // mm

                //CenterZ += (short)(HeightCT * pattern.headValue.stepLength + 0.5);

                //// REL mm at 4 Corners, CD
                PointLU.X = SP1.X - CP.X;
                PointLU.Y = SP1.Y + pattern.fontValue.height - CP.Y;
                PointLD.Y = SP1.Y - CP.Y;
                PointRU.X = SP1.X + totWidth - CP.X;
                ////
                ///
                Vector3D Sum = new Vector3D();
                foreach (var mPoint in planePoints)
                {
                    Sum.X += mPoint.X; Sum.Y += mPoint.Y; Sum.Z += mPoint.Z;
                }

                Vector3D Centroid = new Vector3D();
                Centroid.X = Sum.X / planePoints.Count;
                Centroid.Y = Sum.Y / planePoints.Count;
                Centroid.Z = Sum.Z / planePoints.Count;
                double xx, xy, xz, yy, yz, zz;
                xx = xy = xz = yy = yz = zz = 0.0;
                foreach (var mPoint in planePoints)
                {
                    xx += (mPoint.X - Centroid.X) * (mPoint.X - Centroid.X);
                    xy += (mPoint.X - Centroid.X) * (mPoint.Y - Centroid.Y);
                    xz += (mPoint.X - Centroid.X) * (mPoint.Z - Centroid.Z);
                    yy += (mPoint.Y - Centroid.Y) * (mPoint.Y - Centroid.Y);
                    yz += (mPoint.Y - Centroid.Y) * (mPoint.Z - Centroid.Z);
                    zz += (mPoint.Z - Centroid.Z) * (mPoint.Z - Centroid.Z);
                }
                retval.NormalDir.X = xy * yz - xz * yy;
                retval.NormalDir.Y = xy * xz - yz * xx;
                retval.NormalDir.Z = xx * yy - xy * xy;

                double Ds = retval.NormalDir.X * Centroid.X + retval.NormalDir.Y * Centroid.Y + retval.NormalDir.Z * Centroid.Z;
                ////

                //double diffLU, diffLD, diffRD, diffRU, diffCU, diffCD;
                //diffLU = HeightLU - Mode_File.HeightCT;
                //diffLD = HeightLD - Mode_File.HeightCT;
                //diffRU = Mode_File.HeightRU - Mode_File.HeightCT;
                //diffRD = Mode_File.HeightRD - Mode_File.HeightCT;
                //diffCU = Mode_File.HeightCU - Mode_File.HeightCT;
                //diffCD = Mode_File.HeightCD - Mode_File.HeightCT;
                //double minDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
                //double maxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
                //double diffDiff = Math.Abs(maxDiff - minDiff);

                ////
                double PlaneLU = GetZfromPlane(PointLU.X, PointLU.Y);
                double PlaneLD = GetZfromPlane(PointLU.X, PointLD.Y);
                double PlaneRU = GetZfromPlane(PointRU.X, PointLU.Y);
                double PlaneRD = GetZfromPlane(PointRU.X, PointLD.Y);
                double PlaneCU = GetZfromPlane(0, PointLU.Y);
                double PlaneCD = GetZfromPlane(0, PointLD.Y);
                retval.PlaneCenterZ = GetZfromPlane(0, 0);

                //CenterZ = (short)((CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ) * (double)pattern.headValue.stepLength + 0.5);              // BLU // && 8
                retval.centerPoint.Z = CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ;
                retval.centerPointBLU.Z = (short)((CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ) * (double)pattern.headValue.stepLength + 0.5);

                double PdiffLU, PdiffLD, PdiffRD, PdiffRU, PdiffCU, PdiffCD;
                PdiffLU = PlaneLU - retval.PlaneCenterZ;
                PdiffLD = PlaneLD - retval.PlaneCenterZ;
                PdiffRU = PlaneRU - retval.PlaneCenterZ;
                PdiffRD = PlaneRD - retval.PlaneCenterZ;
                PdiffCU = PlaneCU - retval.PlaneCenterZ;
                PdiffCD = PlaneCD - retval.PlaneCenterZ;
                double PminDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
                double PmaxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
                double PdiffDiff = Math.Abs(PmaxDiff - PminDiff);

                //double dSlope = 0.0d;
                //Util.GetPrivateProfileValue("OPTION", "SLOPE4MANUAL", "4.0", ref value, Constants.MARKING_INI_FILE);
                //double.TryParse(value, out dSlope);

                if (PdiffDiff > headValue.slope4Manual)
                {
                    Debug.WriteLine(string.Format("ERROR =>Plate is inclied too much : {0:F3} mm", PdiffDiff));
                    log = string.Format("ERROR => Too much inclined Plate : {0:F3} mm", PdiffDiff);
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", log, log);

                    // Error handling required!!
                    if (errClineFlag == 0)
                    {
                        retval.execResult = -5;
                        return retval;
                    }
                }

                ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", "NORMALDIR = " + retval.NormalDir.X.ToString("F4") + ", " + retval.NormalDir.Y.ToString("F4") + ", " + retval.NormalDir.Z.ToString("F4") + ", PLANECENTERZ = " + retval.PlaneCenterZ.ToString("F4"));

                ShowLabelData2(lblDispCenXCenY, retval.PlaneCenterZ.ToString("0.000;-0.000;0.000"), Brushes.DarkGreen, null);
                if (PdiffLU > 0)
                    ShowLabelData2(lblDispMinXMaxY, PdiffLU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);
                else
                    ShowLabelData2(lblDispMinXMaxY, PdiffLU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);

                if (PdiffLD > 0)
                    ShowLabelData2(lblDispMinXMinY, PdiffLD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);
                else
                    ShowLabelData2(lblDispMinXMinY, PdiffLD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);

                if (PdiffRU > 0)
                    ShowLabelData2(lblDispMaxXMaxY, PdiffRU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispMaxXMaxY, PdiffRU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);

                if (PdiffRD > 0)
                    ShowLabelData2(lblDispMaxXMinY, PdiffRD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispMaxXMinY, PdiffRD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);

                if (PdiffCU > 0)
                    ShowLabelData2(lblDispCenXMaxY, PdiffCU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispCenXMaxY, PdiffCU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);

                if (PdiffCD > 0)
                    ShowLabelData2(lblDispCenXMinY, PdiffCD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispCenXMinY, PdiffCD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);


                //ShowLabelData(TxtZeroOffset, retval.PlaneCenterZ.ToString("0.000;-0.000;0.000"));
                //Console.WriteLine(String.Format("Normal Vector ({0:F4},{1:F4},{2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ));

                //ControlWindow.Dispatcher.Invoke(new Action(delegate
                //{
                //    var NormalStr = String.Format("Normal Vector ({0:F4}, {1:F4}, {2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ);
                //    ControlWindow.txt_log.AppendText(NormalStr + Environment.NewLine);

                //    ControlWindow.normalX.Content = Mode_File.NormalDir.X.ToString("F4");
                //    ControlWindow.normalY.Content = Mode_File.NormalDir.Y.ToString("F4");
                //    ControlWindow.normalZ.Content = Mode_File.NormalDir.Z.ToString("F4");
                //    ControlWindow.planeZ.Content = Mode_File.PlaneCenterZ.ToString("F4");

                //    ControlWindow.lblDispCenXCenY.Foreground = (Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.DarkGreen;
                //    ControlWindow.lblDispCenXCenY.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

                //    ControlWindow.TxtZeroOffset.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

                //    ControlWindow.lblDispMinXMaxY.Foreground = (PdiffLU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
                //    ControlWindow.lblDispMinXMaxY.Content = PdiffLU.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispMinXMinY.Foreground = (PdiffLD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
                //    ControlWindow.lblDispMinXMinY.Content = PdiffLD.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispMaxXMaxY.Foreground = (PdiffRU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
                //    ControlWindow.lblDispMaxXMaxY.Content = PdiffRU.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispMaxXMinY.Foreground = (PdiffRD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
                //    ControlWindow.lblDispMaxXMinY.Content = PdiffRD.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispCenXMaxY.Foreground = (PdiffCU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
                //    ControlWindow.lblDispCenXMaxY.Content = PdiffCU.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispCenXMinY.Foreground = (PdiffCD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
                //    ControlWindow.lblDispCenXMinY.Content = PdiffCD.ToString("+ 0.000;- 0.000;0.000");
                //}
                //));

                int jc = (int)((PointLU.Y - PointLD.Y) + 0.5);
                int ic = (int)((PointRU.X - PointLU.X) + 0.5);
                byte[,] HC = new byte[jc, ic];

                double Yy = PointLU.Y;
                double Xx = PointLU.X;
                double Zz = 0;
                for (int r = 0; r < jc; r++)
                {
                    Xx = PointLU.X;
                    for (int c = 0; c < ic; c++)
                    {
                        Zz = (GetZfromPlane(Xx, Yy) - GetZfromPlane(0, 0)) * 200.0;
                        if (Zz > 127.0) Zz = 127.0;
                        if (Zz < -127.0) Zz = -127.0;
                        HC[r, c] = (byte)(Zz + 127.0);
                        Xx += 1.0;  // +1 mm;
                    }
                    Yy -= 1.0;      // -1 mm;
                }

                Dispatcher.Invoke(new Action(delegate
                {
                    PlateColoring(HC);
                }));


                double GetZfromPlane(double x, double y)
                {
                    double pz;
                    if (retval.NormalDir.Z != 0)
                        pz = Ds / retval.NormalDir.Z - retval.NormalDir.X / retval.NormalDir.Z * x - retval.NormalDir.Y / retval.NormalDir.Z * y;
                    else
                        pz = 0;
                    return pz;
                }

                return retval;
            }
            catch (Exception ex)
            {
                retval.execResult = ex.HResult;
                log = "EXCEPTION. ERROR = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                retval.errorInfo.sErrorMessage = log;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
            }

            return retval;
            //    SP1.X = CP - SP1;




            //    //double SpX, SpY, SpZ, Ht, Wd, Pt, Ag;
            //    //int NoVin;

            //    //MPOINT SP = new MPOINT();
            //    //MPOINT CP = new MPOINT();

            //    //MPOINT PointLU = new MPOINT();
            //    //MPOINT PointLD = new MPOINT();
            //    //MPOINT PointRU = new MPOINT();
            //    //MPOINT PointRD = new MPOINT();                                                                                  
            //    //MPOINT PointCT = new MPOINT();
            //    //MPOINT PointCU = new MPOINT();
            //    //MPOINT PointCD = new MPOINT();
            //    //MPOINT VectorNormal = new MPOINT();
            //    //MPOINT VectorLuRd = new MPOINT();
            //    //MPOINT VectorRuRd = new MPOINT();
            //    //MPOINT VectorRot = new MPOINT();


            //    //string X_Position = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "X", "0.0", ref X_Position, "Parameter.ini");

            //    //string Y_Position = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "Y", "0.0", ref Y_Position, "Parameter.ini");

            //    //string Z_Position = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "Z", "0.0", ref Z_Position, "Parameter.ini");

            //    //string Height = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "HEIGHT", "0.0", ref Height, "Parameter.ini");
            //    //Ht = double.Parse(Height);

            //    //string Width = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "WIDTH", "0.0", ref Width, "Parameter.ini");
            //    //Wd = double.Parse(Width);

            //    //string Pitch = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "PITCH", "0.0", ref Pitch, "Parameter.ini");
            //    //Pt = double.Parse(Pitch);

            //    //string Angle = "";
            //    //Util.GetPrivateProfileValue("VINDATA", "ANGLE", "0.0", ref Angle, "Parameter.ini");
            //    //Ag = double.Parse(Angle);

            //    //string SensorPosition = "";
            //    //Util.GetPrivateProfileValue("SENSOR", "POSITION", "RIGHT", ref SensorPosition, "Parameter.ini");

            //    ControlWindow.readDisplacementTimer.Interval = TimeSpan.FromMilliseconds(10);

            //    NoVin = (mark6 == true) ? 6 : ManStr.Length;

            //    Mode_File.PlanePoints.Clear();

            //    Mode_File.ErrorDistanceSensor = false;

            //    // Absolute mm of Center Point
            //    CP.X = double.Parse(X_Position);
            //    CP.Y = double.Parse(Y_Position);
            //    CP.Z = double.Parse(Z_Position);
            //    // Relative mm
            //    SP.X = ((double)(NoVin - 1) * Pt + Wd) / 2.0;
            //    SP.Y = Ht / 2.0;
            //    // ABS mm of Start Point
            //    SP.X = CP.X - SP.X; SP.Y = CP.Y - SP.Y; SP.Z = CP.Z;

            //    // ABS mm
            //    double MinX = SP.X;
            //    double MaxX = SP.X + (double)(NoVin - 1) * Pt + Wd;
            //    double MinY = SP.Y;
            //    double MaxY = SP.Y + Ht;

            //    Mode_File.dMinX = MinX;
            //    Mode_File.dMaxX = MaxX;
            //    Mode_File.dMinY = MinY;
            //    Mode_File.dMaxY = MaxY;

            //    // ABS BLU
            //    Mode_File.gMinX = (short)(MinX * Mode_File.Step_Length + 0.5);
            //    Mode_File.gMaxX = (short)(MaxX * Mode_File.Step_Length + 0.5);
            //    Mode_File.gMinY = (short)(MinY * Mode_File.Step_Length + 0.5);
            //    Mode_File.gMaxY = (short)(MaxY * Mode_File.Step_Length + 0.5);

            //    // ABS mm
            //    double CX = (MaxX + MinX) / 2.0;
            //    double CY = (MaxY + MinY) / 2.0;

            //    // ABS BLU
            //    short tCX = (short)(CX * Mode_File.Step_Length + 0.5);
            //    short tCY = (short)(CY * Mode_File.Step_Length + 0.5);
            //    Mode_File.CenterX = tCX;
            //    Mode_File.CenterY = tCY;
            //    Mode_File.CenterZ = (short)(SP.Z * Mode_File.Step_Length + 0.5);

            //    string _Position = ""; Util.GetPrivateProfileValue("PARKING", "PARKING_Z", "110.0", ref _Position, "Parameter.ini");
            //    var Parking_Z = (short)(double.Parse(_Position) * Mode_File.Step_Length);       // LOAD PARKING Z
            //    var Range_CenterXY = tCX.ToString("X4") + tCY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    GoPoint("M", Range_CenterXY);       // CT, 0 with None offset

            //    Mode_File.ShiftCT = 0.0;
            //    Mode_File.SensorShift = null; while (Mode_File.SensorShift == null) ;
            //    Mode_File.SensorShift = null; while (Mode_File.SensorShift == null) ;
            //    Mode_File.HeightCT = (double)Mode_File.SensorOffset;
            //    Mode_File.ShiftCT = (double)Mode_File.SensorShift;

            //    // Sensor Shift compensation
            //    Mode_File.ErrorDistanceSensor = false;

            //    if (Math.Abs(Mode_File.HeightCT) > 40.0)      // Z Diff +- 40mm    // && 7
            //    {
            //        Mode_File.ErrorDistanceSensor = true;

            //        // Error : Z Range over (Z axis unit +-40mm )
            //        ControlWindow.Dispatcher.Invoke(new Action(delegate
            //        {
            //            ControlWindow.txt_log.Text = "OUT OF RANGE Z";
            //            ControlWindow.lblDispCenXCenY.Foreground = (Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.Black;
            //            ControlWindow.lblDispCenXCenY.Content = Mode_File.HeightCT.ToString("0.000");
            //            ControlWindow.lblDispMinXMaxY.Content = "";
            //            ControlWindow.lblDispMinXMinY.Content = "";
            //            ControlWindow.lblDispMaxXMaxY.Content = "";
            //            ControlWindow.lblDispMaxXMinY.Content = "";
            //            ControlWindow.lblDispCenXMaxY.Content = "";
            //            ControlWindow.lblDispCenXMinY.Content = "";
            //        }
            //        ));

            //        return 1;
            //    }

            //    SensorPosition = "LEFT";          // && 7
            //    if (SensorPosition == "RIGHT")
            //    {
            //        Mode_File.gMinX -= (short)(Mode_File.ShiftCT * Mode_File.Step_Length + 0.5);
            //        if (Mode_File.gMinX < (short)Mode_File.Step_Length) // 1mm                            // && 7
            //            Mode_File.gMinX = (short)Mode_File.Step_Length;                                   // && 7
            //        Mode_File.gMaxX -= (short)(Mode_File.ShiftCT * Mode_File.Step_Length + 0.5);
            //        if (Mode_File.gMaxX > (short)(Mode_File.MAX_X - Mode_File.Step_Length))    // MAX_X - 1mm   // && 7
            //            Mode_File.gMaxX = (short)(Mode_File.MAX_X - Mode_File.Step_Length);                     // && 7
            //    }
            //    else
            //    {
            //        Mode_File.gMinX += (short)(Mode_File.ShiftCT * Mode_File.Step_Length + 0.5);
            //        if (Mode_File.gMinX < (short)Mode_File.Step_Length) // 1mm                            // && 7
            //            Mode_File.gMinX = (short)Mode_File.Step_Length;
            //        Mode_File.gMaxX += (short)(Mode_File.ShiftCT * Mode_File.Step_Length + 0.5);
            //        if (Mode_File.gMaxX > (short)(Mode_File.MAX_X - Mode_File.Step_Length))    // MAX_X - 1mm   // && 7
            //            Mode_File.gMaxX = (short)(Mode_File.MAX_X - Mode_File.Step_Length);                     // && 7
            //    }

            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispCenXCenY.Foreground = (Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.Black;
            //        ControlWindow.lblDispCenXCenY.Content = Mode_File.HeightCT.ToString("0.000");
            //        ControlWindow.lblDispMinXMaxY.Content = "";
            //        ControlWindow.lblDispMinXMinY.Content = "";
            //        ControlWindow.lblDispMaxXMaxY.Content = "";
            //        ControlWindow.lblDispMaxXMinY.Content = "";
            //        ControlWindow.lblDispCenXMaxY.Content = "";
            //        ControlWindow.lblDispCenXMinY.Content = "";
            //    }
            //    ));

            //    //
            //    //
            //    tCX = (short)(((double)Mode_File.gMaxX + (double)Mode_File.gMinX) / 2.0 + 0.5);
            //    tCY = (short)(((double)Mode_File.gMaxY + (double)Mode_File.gMinY) / 2.0 + 0.5);

            //    var Range_MinXMinY = Mode_File.gMinX.ToString("X4") + Mode_File.gMinY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    var Range_MinXMaxY = Mode_File.gMinX.ToString("X4") + Mode_File.gMaxY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    var Range_MaxXMaxY = Mode_File.gMaxX.ToString("X4") + Mode_File.gMaxY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    var Range_MaxXMinY = Mode_File.gMaxX.ToString("X4") + Mode_File.gMinY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    var Range_CenXMinY = tCX.ToString("X4") + Mode_File.gMinY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    var Range_CenXMaxY = tCX.ToString("X4") + Mode_File.gMaxY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
            //    Range_CenterXY = tCX.ToString("X4") + tCY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");

            //    GoPoint("M", Range_MinXMaxY);       // LU, 1
            //    Mode_File.HeightLU = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightLU = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightLU) > 40.0)  // && 7
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    MPOINT TmpPoint = new MPOINT();
            //    TmpPoint.X = MinX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = Mode_File.HeightLU; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispMinXMaxY.Content = Mode_File.HeightLU.ToString("0.000");
            //    }
            //    ));

            //    GoPoint("M", Range_MinXMinY);       // LD, 2
            //    Mode_File.HeightLD = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightLD = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightLD) > 40.0) // && 7      
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    TmpPoint.X = MinX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = Mode_File.HeightLD; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispMinXMinY.Content = Mode_File.HeightLD.ToString("0.000");
            //    }
            //    ));

            //    GoPoint("M", Range_CenXMinY);       // CD, 3
            //    Mode_File.HeightCD = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightCD = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightCD) > 40.0) // && 7     
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    TmpPoint.X = CX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = Mode_File.HeightCD; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispCenXMinY.Content = Mode_File.HeightCD.ToString("0.000");
            //    }
            //    ));

            //    GoPoint("M", Range_MaxXMinY);       // RD, 4
            //    Mode_File.HeightRD = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightRD = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightRD) > 40.0) // && 7      
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = Mode_File.HeightRD; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispMaxXMinY.Content = Mode_File.HeightRD.ToString("0.000");
            //    }
            //    ));

            //    GoPoint("M", Range_MaxXMaxY);       // RU, 5
            //    Mode_File.HeightRU = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightRU = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightRU) > 40.0) // && 7    
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = Mode_File.HeightRU; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispMaxXMaxY.Content = Mode_File.HeightRU.ToString("0.000");
            //    }
            //    ));

            //    GoPoint("M", Range_CenXMaxY);       // CU, 6
            //    Mode_File.HeightCU = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightCU = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightCU) > 40.0) // && 7    
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    TmpPoint.X = CX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = Mode_File.HeightCU; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispCenXMaxY.Content = Mode_File.HeightCU.ToString("0.000");
            //    }
            //    ));

            //    GoPoint("M", Range_CenterXY);       // CT, 7 point
            //    Mode_File.HeightCT = 0.0;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
            //    Mode_File.HeightCT = (double)Mode_File.SensorOffset;
            //    if (Math.Abs(Mode_File.HeightCT) > 40.0) // && 7      
            //    {
            //        Mode_File.ErrorDistanceSensor = true;
            //    }
            //    TmpPoint.X = CX - CP.X; TmpPoint.Y = CY - CP.Y; TmpPoint.Z = Mode_File.HeightCT; Mode_File.PlanePoints.Add(TmpPoint);
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.lblDispCenXCenY.Foreground = Brushes.Red;
            //        ControlWindow.lblDispCenXCenY.Content = Mode_File.HeightCT.ToString("0.000");
            //    }
            //    ));

            //    ControlWindow.readDisplacementTimer.Interval = TimeSpan.FromMilliseconds(500);

            //    if (Mode_File.ErrorDistanceSensor)
            //    {
            //        Mode_File.PlanePoints.Clear();

            //        Mode_File.HeightCT0 = Mode_File.HeightCT;
            //        Mode_File.HeightCT = 40.0;              // && 7

            //        TmpPoint.X = MinX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint); // && 7
            //        TmpPoint.X = MinX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint);
            //        TmpPoint.X = CX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint);
            //        TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint);
            //        TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint);
            //        TmpPoint.X = CX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint);
            //        TmpPoint.X = CX - CP.X; TmpPoint.Y = CY - CP.Y; TmpPoint.Z = 40.0; Mode_File.PlanePoints.Add(TmpPoint); // && 7

            //        return 2;
            //    }

            //    Mode_File.CenterZ += (short)(Mode_File.HeightCT * Mode_File.Step_Length + 0.5);

            //    //// REL mm at 4 Corners, CD
            //    PointLU.X = SP.X - CP.X;
            //    PointLU.Y = SP.Y + Ht - CP.Y;
            //    PointLD.Y = SP.Y - CP.Y;
            //    PointRU.X = SP.X + Pt * (NoVin - 1) + Wd - CP.X;
            //    ////
            //    MPOINT Sum = new MPOINT();
            //    foreach (var mPoint in Mode_File.PlanePoints)
            //    {
            //        Sum.X += mPoint.X; Sum.Y += mPoint.Y; Sum.Z += mPoint.Z;
            //    }
            //    MPOINT Centroid = new MPOINT();
            //    Centroid.X = Sum.X / Mode_File.PlanePoints.Count;
            //    Centroid.Y = Sum.Y / Mode_File.PlanePoints.Count;
            //    Centroid.Z = Sum.Z / Mode_File.PlanePoints.Count;
            //    double xx, xy, xz, yy, yz, zz;
            //    xx = xy = xz = yy = yz = zz = 0.0;
            //    foreach (var mPoint in Mode_File.PlanePoints)
            //    {
            //        xx += (mPoint.X - Centroid.X) * (mPoint.X - Centroid.X);
            //        xy += (mPoint.X - Centroid.X) * (mPoint.Y - Centroid.Y);
            //        xz += (mPoint.X - Centroid.X) * (mPoint.Z - Centroid.Z);
            //        yy += (mPoint.Y - Centroid.Y) * (mPoint.Y - Centroid.Y);
            //        yz += (mPoint.Y - Centroid.Y) * (mPoint.Z - Centroid.Z);
            //        zz += (mPoint.Z - Centroid.Z) * (mPoint.Z - Centroid.Z);
            //    }
            //    Mode_File.NormalDir.X = xy * yz - xz * yy;
            //    Mode_File.NormalDir.Y = xy * xz - yz * xx;
            //    Mode_File.NormalDir.Z = xx * yy - xy * xy;

            //    double Ds = Mode_File.NormalDir.X * Centroid.X + Mode_File.NormalDir.Y * Centroid.Y + Mode_File.NormalDir.Z * Centroid.Z;
            //    ////

            //    double diffLU, diffLD, diffRD, diffRU, diffCU, diffCD;
            //    diffLU = Mode_File.HeightLU - Mode_File.HeightCT;
            //    diffLD = Mode_File.HeightLD - Mode_File.HeightCT;
            //    diffRU = Mode_File.HeightRU - Mode_File.HeightCT;
            //    diffRD = Mode_File.HeightRD - Mode_File.HeightCT;
            //    diffCU = Mode_File.HeightCU - Mode_File.HeightCT;
            //    diffCD = Mode_File.HeightCD - Mode_File.HeightCT;
            //    double minDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
            //    double maxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
            //    double diffDiff = Math.Abs(maxDiff - minDiff);

            //    ////
            //    double PlaneLU = GetZfromPlane(PointLU.X, PointLU.Y);
            //    double PlaneLD = GetZfromPlane(PointLU.X, PointLD.Y);
            //    double PlaneRU = GetZfromPlane(PointRU.X, PointLU.Y);
            //    double PlaneRD = GetZfromPlane(PointRU.X, PointLD.Y);
            //    double PlaneCU = GetZfromPlane(0, PointLU.Y);
            //    double PlaneCD = GetZfromPlane(0, PointLD.Y);
            //    Mode_File.PlaneCenterZ = GetZfromPlane(0, 0);

            //    double PdiffLU, PdiffLD, PdiffRD, PdiffRU, PdiffCU, PdiffCD;
            //    PdiffLU = PlaneLU - Mode_File.PlaneCenterZ;
            //    PdiffLD = PlaneLD - Mode_File.PlaneCenterZ;
            //    PdiffRU = PlaneRU - Mode_File.PlaneCenterZ;
            //    PdiffRD = PlaneRD - Mode_File.PlaneCenterZ;
            //    PdiffCU = PlaneCU - Mode_File.PlaneCenterZ;
            //    PdiffCD = PlaneCD - Mode_File.PlaneCenterZ;
            //    double PminDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
            //    double PmaxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
            //    double PdiffDiff = Math.Abs(PmaxDiff - PminDiff);

            //    if (PdiffDiff > 1.0)
            //    {
            //        Debug.WriteLine(string.Format("ERROR => Too much inclined Plate : {0:F3} mm", PdiffDiff));
            //        // Error handling required!!
            //        return 3;
            //    }

            //    Console.WriteLine(String.Format("Normal Vector ({0:F4},{1:F4},{2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ));

            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        var NormalStr = String.Format("Normal Vector ({0:F4}, {1:F4}, {2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ);
            //        ControlWindow.txt_log.AppendText(NormalStr + Environment.NewLine);

            //        ControlWindow.normalX.Content = Mode_File.NormalDir.X.ToString("F4");
            //        ControlWindow.normalY.Content = Mode_File.NormalDir.Y.ToString("F4");
            //        ControlWindow.normalZ.Content = Mode_File.NormalDir.Z.ToString("F4");
            //        ControlWindow.planeZ.Content = Mode_File.PlaneCenterZ.ToString("F4");

            //        ControlWindow.lblDispCenXCenY.Foreground = (Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.DarkGreen;
            //        ControlWindow.lblDispCenXCenY.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

            //        ControlWindow.TxtZeroOffset.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

            //        ControlWindow.lblDispMinXMaxY.Foreground = (PdiffLU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
            //        ControlWindow.lblDispMinXMaxY.Content = PdiffLU.ToString("+ 0.000;- 0.000;0.000");

            //        ControlWindow.lblDispMinXMinY.Foreground = (PdiffLD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
            //        ControlWindow.lblDispMinXMinY.Content = PdiffLD.ToString("+ 0.000;- 0.000;0.000");

            //        ControlWindow.lblDispMaxXMaxY.Foreground = (PdiffRU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
            //        ControlWindow.lblDispMaxXMaxY.Content = PdiffRU.ToString("+ 0.000;- 0.000;0.000");

            //        ControlWindow.lblDispMaxXMinY.Foreground = (PdiffRD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
            //        ControlWindow.lblDispMaxXMinY.Content = PdiffRD.ToString("+ 0.000;- 0.000;0.000");

            //        ControlWindow.lblDispCenXMaxY.Foreground = (PdiffCU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
            //        ControlWindow.lblDispCenXMaxY.Content = PdiffCU.ToString("+ 0.000;- 0.000;0.000");

            //        ControlWindow.lblDispCenXMinY.Foreground = (PdiffCD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
            //        ControlWindow.lblDispCenXMinY.Content = PdiffCD.ToString("+ 0.000;- 0.000;0.000");
            //    }
            //    ));

            //    int jc = (int)((PointLU.Y - PointLD.Y) + 0.5);
            //    int ic = (int)((PointRU.X - PointLU.X) + 0.5);
            //    byte[,] HC = new byte[jc, ic];

            //    double Yy = PointLU.Y;
            //    double Xx = PointLU.X;
            //    double Zz = 0;
            //    for (int r = 0; r < jc; r++)
            //    {
            //        Xx = PointLU.X;
            //        for (int c = 0; c < ic; c++)
            //        {
            //            Zz = (GetZfromPlane(Xx, Yy) - GetZfromPlane(0, 0)) * 200.0;
            //            if (Zz > 127.0) Zz = 127.0;
            //            if (Zz < -127.0) Zz = -127.0;
            //            HC[r, c] = (byte)(Zz + 127.0);
            //            Xx += 1.0;  // +1 mm;
            //        }
            //        Yy -= 1.0;      // -1 mm;
            //    }
            //    ControlWindow.Dispatcher.Invoke(new Action(delegate
            //    {
            //        ControlWindow.PlateColoring(HC);
            //    }));


            //    double GetZfromPlane(double x, double y)
            //    {
            //        double pz;

            //        pz = Ds / Mode_File.NormalDir.Z - Mode_File.NormalDir.X / Mode_File.NormalDir.Z * x - Mode_File.NormalDir.Y / Mode_File.NormalDir.Z * y;

            //        return pz;
            //    }

            //}
            //catch (Exception)
            //{
            //    MessageBox.Show("Range_Test() error", "Error", MessageBoxButton.OK);
            //}
            //return 0;
        } //End of Function

        public async Task<CheckAreaData> Range_Test2(string cmd, string vin, PatternValueEx pattern, byte errHeightFlag, byte errClineFlag)   // Plating  by TM SHIN
        {
            string className = "SetControllerWindow3";
            string funcName = "Range_Test2";

            CheckAreaData retval = new CheckAreaData();
            distanceSensorData snsdata = new distanceSensorData();
            ITNTResponseArgs respArg = new ITNTResponseArgs();
            HeadValue headValue = new HeadValue();

            int vinLength;
            double totWidth = 0;

            //Vector3D SP0 = new Vector3D();
            Vector3D SP1 = new Vector3D();
            Vector3D CP = new Vector3D();

            Vector3D PointLU = new Vector3D();
            Vector3D PointLD = new Vector3D();
            Vector3D PointRU = new Vector3D();

            Vector3D[] vCheckPos = new Vector3D[7];
            double[] HeightVal = new double[7];
            Vector3D vector3 = new Vector3D();

            double HeightCT0 = 0;
            string value = "";
            string log = "";
            byte bHeadType = 0;
            string fName = "";
            double Shift = 0;
            double Height = 0;

            List<Vector3D> planePoints = new List<Vector3D>();

            short gMinX = 0;
            short gMaxX = 0;
            short gMinY = 0;
            short gMaxY = 0;

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);

                ReadPatternHeadValue(ref headValue);

                vinLength = vin.Length;
                if (vinLength <= 0)
                {
                    log = "EMPTY VIN (LENGTH <= " + vinLength.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    retval.execResult = -1;
                    retval.errorInfo.sErrorMessage = log;
                    return retval;
                }

                if (cbxPatternList.SelectedIndex >= 0)
                    fName = cbxPatternList.SelectedItem.ToString();
                else
                {
                    log = "SELECT PATTERN";
                    retval.errorInfo.sErrorMessage = log;
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    return retval;
                }

                if (ckbSkipCheckPlane.IsChecked == true)
                {
                    retval.NormalDir.X = 0;
                    retval.NormalDir.Y = 0;
                    retval.NormalDir.Z = 1;

                    retval.bReady = true;
                    retval.execResult = 0;
                    return retval;
                }

#if LASER_OFF
#else
                // Laser Beam ON
                respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                    if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetExternalAimingBeamControll(0);
                    }
                }
                if (respArg.execResult != 0)
                {
                    log = "CHECK PLATE FAIL - SET BEAM CONTROLL ERROR : " + respArg.execResult.ToString();
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET BEAM CONTROLL ERROR - " + respArg.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    retval.execResult = respArg.execResult;
                    return retval;
                }

                respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                    if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                    }
                }
                if (respArg.execResult != 0)
                {
                    log = "CHECK PLATE FAIL - BEAM ON ERROR : " + respArg.execResult.ToString();
                    //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM ON ERROR - " + respArg.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //retval.execResult = respArg.execResult;
                    //return retval;
                }

                ShowRectangle(AimingLamp, Brushes.Red);
#endif
                //txtAreaPosition.Text = "25.0";
                //Util.GetPrivateProfileValue("PLATE", "AREAPOSITION", "25.0", ref AreaPosition, Constants.PARAMS_INI_FILE);
                //AreaPosition = txtAreaPosition.Text;
                //AZ = double.Parse(AreaPosition);

                totWidth = (vinLength - 1) * pattern.fontValue.pitch + pattern.fontValue.width;

                CP = pattern.positionValue.center3DPos;
                //if (AZ < CP.Z) AZ = CP.Z;

                //SP0.X = totWidth / 2;
                //SP0.Y = pattern.fontValue.height / 2;
                //SP0.Z = 0;

                //SP1 = CP - SP0; SP1.Z = CP.Z;

                SP1.X = CP.X - totWidth / 2;
                SP1.Y = CP.Y - pattern.fontValue.height / 2;
                SP1.Z = CP.Z;

                // ABS mm
                double MinX = SP1.X;
                double MaxX = SP1.X + totWidth;
                double MinY = SP1.Y;
                double MaxY = SP1.Y + pattern.fontValue.height;

                //Mode_File.dMinX = MinX;
                //Mode_File.dMaxX = MaxX;
                //Mode_File.dMinY = MinY;
                //Mode_File.dMaxY = MaxY;

                // ABS BLU
                gMinX = (short)(MinX * pattern.headValue.stepLength + 0.5);
                gMaxX = (short)(MaxX * pattern.headValue.stepLength + 0.5);
                gMinY = (short)(MinY * pattern.headValue.stepLength + 0.5);
                gMaxY = (short)(MaxY * pattern.headValue.stepLength + 0.5);

                // ABS mm
                double CX = (MaxX + MinX) / 2.0;
                double CY = (MaxY + MinY) / 2.0;

                // ABS BLU
                short tCX = (short)(CX * pattern.headValue.stepLength + 0.5);
                short tCY = (short)(CY * pattern.headValue.stepLength + 0.5);
                //Mode_File.CenterX = tCX;
                //Mode_File.CenterY = tCY;
                //Mode_File.CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);
                //CenterZ = (short)(SP1.Z * pattern.headValue.stepLength + 0.5);
                retval.centerPoint.X = CX;
                retval.centerPoint.Y = CY;
                retval.centerPoint.Z = CP.Z;
                retval.centerPointBLU.X = tCX;
                retval.centerPointBLU.Y = tCY;
                retval.centerPointBLU.Z = (short)(CP.Z * pattern.headValue.stepLength + 0.5);
                //CenterZ = (short)(CP.Z * pattern.headValue.stepLength + 0.5);

                respArg = await SendMotorSpeed("RANGE_TEST", (byte)motorSpeedType.MeasureMoving);
                if (respArg.execResult != 0)
                {
                    //return retval;
                    log = "CHECK PLATE FAIL - SET MOTOR SPEED(MEASURE) ERROR = " + respArg.execResult.ToString();
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET MOTOR SPEED(MEASURE) ERROR - " + respArg.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    retval.execResult = respArg.execResult;
                    return retval;
                }

                vector3 = new Vector3D(tCX, tCY, (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5));
                snsdata = await GetMeasureLength(vector3, 0, 1);
                if (snsdata.execResult != 0)
                {
                    retval.execResult = snsdata.execResult;
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR 0 - " + retval.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CT) : ERROR = " + snsdata.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                    return retval;
                }

                Shift = snsdata.sensorshift;
                Height = snsdata.sensoroffset;

                if (Math.Abs(Height) > pattern.positionValue.checkDistanceHeight)      // Z Diff Max. 60mm
                {
                    retval.ErrorDistanceSensor = true;
                    ShowLabelData2(lblDispCenXCenY, Height.ToString("0.000"), Brushes.Red, null);
                    //ShowLabelColor(lblDispCenXCenY, Brushes.Red, null);

                    ShowLabelData(lblDispMinXMaxY, "");
                    ShowLabelData(lblDispMinXMinY, "");
                    ShowLabelData(lblDispMaxXMaxY, "");
                    ShowLabelData(lblDispMaxXMinY, "");
                    ShowLabelData(lblDispCenXMaxY, "");
                    ShowLabelData(lblDispCenXMinY, "");

                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CENTER Z Range is OUT OF RANGE : " + Height.ToString("F3"));
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + Height.ToString("0.0000"), Thread.CurrentThread.ManagedThreadId);
                    if (errHeightFlag == 0)
                    {
                        retval.execResult = -2;
                        return retval;
                    }
                }

                if (pattern.headValue.sensorPosition == 0)      //RIGHT
                {
                    gMinX -= (short)(Shift * pattern.headValue.stepLength + 0.5);
                    if (gMinX < pattern.headValue.stepLength) // 1mm                            // && 7
                        gMinX = pattern.headValue.stepLength;                                   // && 7

                    gMaxX -= (short)(Shift * pattern.headValue.stepLength + 0.5);
                    if (gMaxX > (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength))    // MAX_X - 1mm   // && 7
                        gMaxX = (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength);                     // && 7
                }
                else
                {
                    gMinX += (short)(Shift * pattern.headValue.stepLength + 0.5);
                    if (gMinX < pattern.headValue.stepLength) // 1mm                            // && 7
                        gMinX = pattern.headValue.stepLength;
                    gMaxX += (short)(Shift * pattern.headValue.stepLength + 0.5);
                    if (gMaxX > (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength))    // MAX_X - 1mm   // && 7
                        gMaxX = (short)(pattern.headValue.max_X * pattern.headValue.stepLength - pattern.headValue.stepLength);                     // && 7
                }

                ShowLabelData2(lblDispCenXCenY, Height.ToString("0.000"), Brushes.Black, null);

                ShowLabelData(lblDispMinXMaxY, "");
                ShowLabelData(lblDispMinXMinY, "");
                ShowLabelData(lblDispMaxXMaxY, "");
                ShowLabelData(lblDispMaxXMinY, "");
                ShowLabelData(lblDispCenXMaxY, "");
                ShowLabelData(lblDispCenXMinY, "");

                tCX = (short)((gMaxX + gMinX) / 2.0 + 0.5);
                tCY = (short)((gMaxY + gMinY) / 2.0 + 0.5);

                Vector3D[] vAddPos = new Vector3D[7];
                //double left = MinX - CP.X;
                //double centerX = CX - CP.X;
                //double right = MaxX - CP.X;
                //double up = MaxY - CP.Y;
                //double centerY = CY - CP.Y;
                //double down = MinY - CP.Y;


                if (pattern.positionValue.plateMode == 0)
                {
                    Height = 0.0;              // && 7

                    vAddPos[0].X = MinX - CP.X; vAddPos[0].Y = MaxY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]); // && 7
                    vAddPos[0].X = MinX - CP.X; vAddPos[0].Y = MinY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]);
                    vAddPos[0].X = CX - CP.X; vAddPos[0].Y = MinY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]);
                    vAddPos[0].X = MaxX - CP.X; vAddPos[0].Y = MinY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]);
                    vAddPos[0].X = MaxX - CP.X; vAddPos[0].Y = MaxY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]);
                    vAddPos[0].X = CX - CP.X; vAddPos[0].Y = MaxY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]);
                    vAddPos[0].X = CX - CP.X; vAddPos[0].Y = CY - CP.Y; vAddPos[0].Z = 0.0; planePoints.Add(vAddPos[0]); // && 7

                }
                else if (pattern.positionValue.plateMode == 1)
                {
                    Vector3D v3d = new Vector3D();
                    v3d.X = tCX; v3d.Y = tCY; v3d.Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

                    snsdata = await GetMeasureLength(v3d, 0, 1);
                    if (snsdata.execResult != 0)
                    {
                        retval.execResult = snsdata.execResult;
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (1).ToString() + " - " + retval.execResult.ToString());
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                        return retval;
                    }

                    Height = snsdata.sensoroffset;
                    if (Math.Abs(Height) > pattern.positionValue.checkDistanceHeight)
                    {
                        retval.ErrorDistanceSensor = true;
                        retval.errorInfo.sErrorMessage = "";
                    }

                    vAddPos[0].X = 0; vAddPos[0].Y = 0; vAddPos[0].Z = Height;
                    planePoints.Add(vAddPos[0]);

                    ShowLabelData(Height.ToString("F3"), lblDispCenXCenY, Brushes.Blue);

                    vAddPos[1].X = MinX - CP.X; vAddPos[1].Y = MaxY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]); // && 7
                    vAddPos[1].X = MinX - CP.X; vAddPos[1].Y = MinY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]);
                    vAddPos[1].X = CX - CP.X; vAddPos[1].Y = MinY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]);
                    vAddPos[1].X = MaxX - CP.X; vAddPos[1].Y = MinY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]);
                    vAddPos[1].X = MaxX - CP.X; vAddPos[1].Y = MaxY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]);
                    vAddPos[1].X = CX - CP.X; vAddPos[1].Y = MaxY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]);
                    vAddPos[1].X = CX - CP.X; vAddPos[1].Y = CY - CP.Y; vAddPos[1].Z = 0.0; planePoints.Add(vAddPos[1]); // && 7

                }
                else if (pattern.positionValue.plateMode == 3)
                {
                    double[] vCheckPosX = new double[] { tCX, gMinX, gMaxX };
                    double[] vCheckPosY = new double[] { gMinY, gMaxY, gMaxY };

                    Height = 0;
                    double[] vAddPosX = new double[] { CX - CP.X, MinX - CP.X, MaxX - CP.X };
                    double[] vAddPosY = new double[] { MinY - CP.Y, MaxY - CP.Y, MaxY - CP.Y };
                    string[] sPosition = new string[] { "CD", "LU", "RU" };
                    Label[] lblValue = new Label[] { lblDispCenXMinY, lblDispMinXMaxY, lblDispMaxXMaxY };

                    for (int i = 0; i < 3; i++)
                    {
                        vCheckPos[i].X = vCheckPosX[i];
                        vCheckPos[i].Y = vCheckPosY[i];
                        vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

                        snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
                        if (snsdata.execResult != 0)
                        {
                            //retval.execResult = snsdata.execResult;
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(" + sPosition[i] + ") : ERROR = " + snsdata.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);

                            retval.execResult = snsdata.execResult;
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR (" + i.ToString() + ") - " + retval.execResult.ToString());
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(" + i.ToString() + ") : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                            return retval;
                        }

                        HeightVal[i] = snsdata.sensoroffset;
                        if (Math.Abs(HeightVal[i]) > pattern.positionValue.checkDistanceHeight)
                        {
                            retval.ErrorDistanceSensor = true;
                            //retval.sErrorMessage = "";
                        }

                        vAddPos[i].X = vAddPosX[i]; vAddPos[i].Y = vAddPosY[i]; vAddPos[i].Z = HeightVal[i]; planePoints.Add(vAddPos[i]);
                        ShowLabelData(HeightVal[i].ToString("0.000"), lblValue[i], Brushes.Blue);
                    }
                }
                else if (pattern.positionValue.plateMode == 5)
                {
                    double[] vCheckPosX = new double[] { gMinX, gMinX, gMaxX, gMaxX, tCX };
                    double[] vCheckPosY = new double[] { gMaxY, gMinY, gMinY, gMaxY, tCY };


                    double[] vAddPosX = new double[] { MinX - CP.X, MinX - CP.X, MaxX - CP.X, MaxX - CP.X, CX - CP.X};
                    double[] vAddPosY = new double[] { MaxY - CP.Y, MinY - CP.Y, MinY - CP.Y, MaxY - CP.Y, CY - CP.Y};

                    Label[] lblValue = new Label[] { lblDispMinXMaxY, lblDispMinXMinY, lblDispMaxXMinY, lblDispMaxXMaxY, lblDispCenXCenY };
                    for (int i = 0; i < 5; i++)
                    {
                        vCheckPos[i].X = vCheckPosX[i];
                        vCheckPos[i].Y = vCheckPosY[i];
                        vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

                        snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
                        if (snsdata.execResult != 0)
                        {
                            retval.execResult = snsdata.execResult;
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (i + 1).ToString() + " - " + retval.execResult.ToString());
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                            return retval;
                        }

                        HeightVal[i] = snsdata.sensoroffset;
                        if (Math.Abs(HeightVal[i]) > pattern.positionValue.checkDistanceHeight)
                        {
                            retval.ErrorDistanceSensor = true;
                            retval.errorInfo.sErrorMessage = "";
                        }

                        vAddPos[i].X = vAddPosX[i]; vAddPos[i].Y = vAddPosY[i]; vAddPos[i].Z = snsdata.sensoroffset; planePoints.Add(vAddPos[i]);
                        ShowLabelData(HeightVal[i].ToString("0.000"), lblValue[i], Brushes.Blue);
                        Height = HeightVal[i];    // TM SHIN
                    }
                }
                else if (pattern.positionValue.plateMode == 7)
                {
                    double[] vCheckPosX = new double[] { gMinX, gMinX, tCX, gMaxX, gMaxX, tCX, tCX };
                    double[] vCheckPosY = new double[] { gMaxY, gMinY, gMinY, gMinY, gMaxY, gMaxY, tCY };

                    double[] vAddPosX = new double[] { MinX - CP.X, MinX - CP.X, CX - CP.X, MaxX - CP.X, MaxX - CP.X, CX - CP.X, CX - CP.X };
                    double[] vAddPosY = new double[] { MaxY - CP.Y, MinY - CP.Y, MinY - CP.Y, MinY - CP.Y, MaxY - CP.Y, MaxY - CP.Y, CY - CP.Y };

                    Label[] lblValue = new Label[] { lblDispMinXMaxY, lblDispMinXMinY, lblDispCenXMinY, lblDispMaxXMinY, lblDispMaxXMaxY, lblDispCenXMaxY, lblDispCenXCenY };
                    for (int i = 0; i < 7; i++)
                    {
                        vCheckPos[i].X = vCheckPosX[i];
                        vCheckPos[i].Y = vCheckPosY[i];
                        vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

                        snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
                        if (snsdata.execResult != 0)
                        {
                            retval.execResult = snsdata.execResult;
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (i + 1).ToString() + " - " + retval.execResult.ToString());
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                            return retval;
                        }

                        vAddPos[i].X = vAddPosX[i];
                        vAddPos[i].Y = vAddPosY[i];
                        vAddPos[i].Z = snsdata.sensoroffset;
                        HeightVal[i] = snsdata.sensoroffset;
                        if (Math.Abs(HeightVal[i]) > pattern.positionValue.checkDistanceHeight)
                        {
                            retval.ErrorDistanceSensor = true;
                            retval.errorInfo.sErrorMessage = "";
                        }

                        planePoints.Add(vAddPos[i]);
                        ShowLabelData(HeightVal[i].ToString("0.000"), lblValue[i], Brushes.Blue);
                        Height = HeightVal[i];    // TM SHIN
                    }
                }
                else
                {
                    double[] vCheckPosX = new double[] { gMinX, gMinX, tCX, gMaxX, gMaxX, tCX, tCX };
                    double[] vCheckPosY = new double[] { gMaxY, gMinY, gMinY, gMinY, gMaxY, gMaxY, tCY };

                    double[] vAddPosX = new double[] { MinX - CP.X, MinX - CP.X, CX - CP.X, MaxX - CP.X, MaxX - CP.X, CX - CP.X, CX - CP.X };
                    double[] vAddPosY = new double[] { MaxY - CP.Y, MinY - CP.Y, MinY - CP.Y, MinY - CP.Y, MaxY - CP.Y, MaxY - CP.Y, CY - CP.Y };

                    Label[] lblValue = new Label[] { lblDispMinXMaxY, lblDispMinXMinY, lblDispCenXMinY, lblDispMaxXMinY, lblDispMaxXMaxY, lblDispCenXMaxY, lblDispCenXCenY };
                    for (int i = 0; i < 7; i++)
                    {
                        vCheckPos[i].X = vCheckPosX[i];
                        vCheckPos[i].Y = vCheckPosY[i];
                        vCheckPos[i].Z = pattern.headValue.park3DPos.Z * pattern.headValue.stepLength;

                        snsdata = await GetMeasureLength(vCheckPos[i], 0, 1);
                        if (snsdata.execResult != 0)
                        {
                            retval.execResult = snsdata.execResult;
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR " + (i + 1).ToString() + " - " + retval.execResult.ToString());
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(LU) : ERROR = " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                            return retval;
                        }

                        vAddPos[i].X = vAddPosX[i];
                        vAddPos[i].Y = vAddPosY[i];
                        vAddPos[i].Z = snsdata.sensoroffset;
                        HeightVal[i] = snsdata.sensoroffset;
                        if (Math.Abs(HeightVal[i]) > pattern.positionValue.checkDistanceHeight)
                        {
                            retval.ErrorDistanceSensor = true;
                            retval.errorInfo.sErrorMessage = "";
                        }

                        planePoints.Add(vAddPos[i]);
                        ShowLabelData(HeightVal[i].ToString("0.000"), lblValue[i], Brushes.Blue);
                        Height = HeightVal[i];    // TM SHIN
                    }
                }

#if LASER_OFF
#else

                // Laser Aiming Beam OFF
                respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((respArg.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (respArg.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        respArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                }

                //if (respArg.execResult != 0)
                //{
                //    log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //    retval.execResult = respArg.execResult;
                //    return retval;
                //}
                //else
                ShowRectangle(AimingLamp, Brushes.Black);
#endif

                if (retval.ErrorDistanceSensor)
                {
                    Vector3D TmpPoint = new Vector3D();
                    planePoints.Clear();

                    HeightCT0 = Height;
                    Height = pattern.positionValue.checkDistanceHeight;

                    TmpPoint.X = MinX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = MinX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = CX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MinY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = MaxX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = CX - CP.X; TmpPoint.Y = MaxY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);
                    TmpPoint.X = CX - CP.X; TmpPoint.Y = CY - CP.Y; TmpPoint.Z = pattern.positionValue.checkDistanceHeight; planePoints.Add(TmpPoint);


                    log = "CHECK PLATE FAIL - BEAM OFF ERROR : " + retval.execResult.ToString();
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "BEAM OFF ERROR - " + retval.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    if (errHeightFlag == 0)
                    {
                        retval.execResult = -4;
                        return retval;
                    }
                }


                //double D_0_Gap_Z = CP.Z + pattern.headValue.distance0Position;                                                                     // && 8             // mm

                //CenterZ += (short)(HeightCT * pattern.headValue.stepLength + 0.5);

                //// REL mm at 4 Corners, CD
                PointLU.X = SP1.X - CP.X;
                PointLU.Y = SP1.Y + pattern.fontValue.height - CP.Y;
                PointLD.Y = SP1.Y - CP.Y;
                PointRU.X = SP1.X + totWidth - CP.X;
                ////
                ///
                Vector3D Sum = new Vector3D();
                foreach (var mPoint in planePoints)
                {
                    Sum.X += mPoint.X; Sum.Y += mPoint.Y; Sum.Z += mPoint.Z;
                }

                Vector3D Centroid = new Vector3D();
                Centroid.X = Sum.X / planePoints.Count;
                Centroid.Y = Sum.Y / planePoints.Count;
                Centroid.Z = Sum.Z / planePoints.Count;
                double xx, xy, xz, yy, yz, zz;
                xx = xy = xz = yy = yz = zz = 0.0;
                foreach (var mPoint in planePoints)
                {
                    xx += (mPoint.X - Centroid.X) * (mPoint.X - Centroid.X);
                    xy += (mPoint.X - Centroid.X) * (mPoint.Y - Centroid.Y);
                    xz += (mPoint.X - Centroid.X) * (mPoint.Z - Centroid.Z);
                    yy += (mPoint.Y - Centroid.Y) * (mPoint.Y - Centroid.Y);
                    yz += (mPoint.Y - Centroid.Y) * (mPoint.Z - Centroid.Z);
                    zz += (mPoint.Z - Centroid.Z) * (mPoint.Z - Centroid.Z);
                }
                retval.NormalDir.X = xy * yz - xz * yy;
                retval.NormalDir.Y = xy * xz - yz * xx;
                retval.NormalDir.Z = xx * yy - xy * xy;

                double Ds = retval.NormalDir.X * Centroid.X + retval.NormalDir.Y * Centroid.Y + retval.NormalDir.Z * Centroid.Z;
                ////

                //double diffLU, diffLD, diffRD, diffRU, diffCU, diffCD;
                //diffLU = HeightLU - Mode_File.HeightCT;
                //diffLD = HeightLD - Mode_File.HeightCT;
                //diffRU = Mode_File.HeightRU - Mode_File.HeightCT;
                //diffRD = Mode_File.HeightRD - Mode_File.HeightCT;
                //diffCU = Mode_File.HeightCU - Mode_File.HeightCT;
                //diffCD = Mode_File.HeightCD - Mode_File.HeightCT;
                //double minDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
                //double maxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(diffLU, diffLD), diffRU), diffRD), diffCU), diffCD);
                //double diffDiff = Math.Abs(maxDiff - minDiff);

                ////
                double PlaneLU = GetZfromPlane(PointLU.X, PointLU.Y);
                double PlaneLD = GetZfromPlane(PointLU.X, PointLD.Y);
                double PlaneRU = GetZfromPlane(PointRU.X, PointLU.Y);
                double PlaneRD = GetZfromPlane(PointRU.X, PointLD.Y);
                double PlaneCU = GetZfromPlane(0, PointLU.Y);
                double PlaneCD = GetZfromPlane(0, PointLD.Y);
                retval.PlaneCenterZ = GetZfromPlane(0, 0);

                //CenterZ = (short)((CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ) * (double)pattern.headValue.stepLength + 0.5);              // BLU // && 8
                retval.centerPoint.Z = CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ;
                retval.centerPointBLU.Z = (short)((CP.Z + pattern.headValue.distance0Position + retval.PlaneCenterZ) * (double)pattern.headValue.stepLength + 0.5);

                double PdiffLU, PdiffLD, PdiffRD, PdiffRU, PdiffCU, PdiffCD;
                PdiffLU = PlaneLU - retval.PlaneCenterZ;
                PdiffLD = PlaneLD - retval.PlaneCenterZ;
                PdiffRU = PlaneRU - retval.PlaneCenterZ;
                PdiffRD = PlaneRD - retval.PlaneCenterZ;
                PdiffCU = PlaneCU - retval.PlaneCenterZ;
                PdiffCD = PlaneCD - retval.PlaneCenterZ;
                double PminDiff = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
                double PmaxDiff = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(PdiffLU, PdiffLD), PdiffRU), PdiffRD), PdiffCU), PdiffCD);
                double PdiffDiff = Math.Abs(PmaxDiff - PminDiff);

                //double dSlope = 0.0d;
                //Util.GetPrivateProfileValue("OPTION", "SLOPE4MANUAL", "4.0", ref value, Constants.MARKING_INI_FILE);
                //double.TryParse(value, out dSlope);

                if (PdiffDiff > headValue.slope4Manual)
                {
                    Debug.WriteLine(string.Format("ERROR =>Plate is inclied too much : {0:F3} mm", PdiffDiff));
                    log = string.Format("ERROR => Too much inclined Plate : {0:F3} mm", PdiffDiff);
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", log, log);

                    // Error handling required!!
                    if (errClineFlag == 0)
                    {
                        retval.execResult = -5;
                        return retval;
                    }
                }

                ShowLog((byte)LOGTYPE.LOG_NORMAL, "RANGETEST", "NORMALDIR = " + retval.NormalDir.X.ToString("F4") + ", " + retval.NormalDir.Y.ToString("F4") + ", " + retval.NormalDir.Z.ToString("F4") + ", PLANECENTERZ = " + retval.PlaneCenterZ.ToString("F4"));

                ShowLabelData2(lblDispCenXCenY, retval.PlaneCenterZ.ToString("0.000;-0.000;0.000"), Brushes.DarkGreen, null);
                if (PdiffLU > 0)
                    ShowLabelData2(lblDispMinXMaxY, PdiffLU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);
                else
                    ShowLabelData2(lblDispMinXMaxY, PdiffLU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);

                if (PdiffLD > 0)
                    ShowLabelData2(lblDispMinXMinY, PdiffLD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);
                else
                    ShowLabelData2(lblDispMinXMinY, PdiffLD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);

                if (PdiffRU > 0)
                    ShowLabelData2(lblDispMaxXMaxY, PdiffRU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispMaxXMaxY, PdiffRU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);

                if (PdiffRD > 0)
                    ShowLabelData2(lblDispMaxXMinY, PdiffRD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispMaxXMinY, PdiffRD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);

                if (PdiffCU > 0)
                    ShowLabelData2(lblDispCenXMaxY, PdiffCU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispCenXMaxY, PdiffCU.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);

                if (PdiffCD > 0)
                    ShowLabelData2(lblDispCenXMinY, PdiffCD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Red, null);
                else
                    ShowLabelData2(lblDispCenXMinY, PdiffCD.ToString("+ 0.000;- 0.000;0.000"), Brushes.Blue, null);


                //ShowLabelData(TxtZeroOffset, retval.PlaneCenterZ.ToString("0.000;-0.000;0.000"));
                //Console.WriteLine(String.Format("Normal Vector ({0:F4},{1:F4},{2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ));

                //ControlWindow.Dispatcher.Invoke(new Action(delegate
                //{
                //    var NormalStr = String.Format("Normal Vector ({0:F4}, {1:F4}, {2:F4}) / CenterZ {3:F4}", Mode_File.NormalDir.X, Mode_File.NormalDir.Y, Mode_File.NormalDir.Z, Mode_File.PlaneCenterZ);
                //    ControlWindow.txt_log.AppendText(NormalStr + Environment.NewLine);

                //    ControlWindow.normalX.Content = Mode_File.NormalDir.X.ToString("F4");
                //    ControlWindow.normalY.Content = Mode_File.NormalDir.Y.ToString("F4");
                //    ControlWindow.normalZ.Content = Mode_File.NormalDir.Z.ToString("F4");
                //    ControlWindow.planeZ.Content = Mode_File.PlaneCenterZ.ToString("F4");

                //    ControlWindow.lblDispCenXCenY.Foreground = (Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.DarkGreen;
                //    ControlWindow.lblDispCenXCenY.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

                //    ControlWindow.TxtZeroOffset.Content = Mode_File.PlaneCenterZ.ToString("0.000;-0.000;0.000");

                //    ControlWindow.lblDispMinXMaxY.Foreground = (PdiffLU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
                //    ControlWindow.lblDispMinXMaxY.Content = PdiffLU.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispMinXMinY.Foreground = (PdiffLD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
                //    ControlWindow.lblDispMinXMinY.Content = PdiffLD.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispMaxXMaxY.Foreground = (PdiffRU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue;
                //    ControlWindow.lblDispMaxXMaxY.Content = PdiffRU.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispMaxXMinY.Foreground = (PdiffRD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
                //    ControlWindow.lblDispMaxXMinY.Content = PdiffRD.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispCenXMaxY.Foreground = (PdiffCU > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
                //    ControlWindow.lblDispCenXMaxY.Content = PdiffCU.ToString("+ 0.000;- 0.000;0.000");

                //    ControlWindow.lblDispCenXMinY.Foreground = (PdiffCD > 0 || Mode_File.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue; ;
                //    ControlWindow.lblDispCenXMinY.Content = PdiffCD.ToString("+ 0.000;- 0.000;0.000");
                //}
                //));

                int jc = (int)((PointLU.Y - PointLD.Y) + 0.5);
                int ic = (int)((PointRU.X - PointLU.X) + 0.5);
                byte[,] HC = new byte[jc, ic];

                double Yy = PointLU.Y;
                double Xx = PointLU.X;
                double Zz = 0;
                for (int r = 0; r < jc; r++)
                {
                    Xx = PointLU.X;
                    for (int c = 0; c < ic; c++)
                    {
                        Zz = (GetZfromPlane(Xx, Yy) - GetZfromPlane(0, 0)) * 200.0;
                        if (Zz > 127.0) Zz = 127.0;
                        if (Zz < -127.0) Zz = -127.0;
                        HC[r, c] = (byte)(Zz + 127.0);
                        Xx += 1.0;  // +1 mm;
                    }
                    Yy -= 1.0;      // -1 mm;
                }

                Dispatcher.Invoke(new Action(delegate
                {
                    PlateColoring(HC);
                }));


                double GetZfromPlane(double x, double y)
                {
                    double pz;
                    if (retval.NormalDir.Z != 0)
                        pz = Ds / retval.NormalDir.Z - retval.NormalDir.X / retval.NormalDir.Z * x - retval.NormalDir.Y / retval.NormalDir.Z * y;
                    else
                        pz = 0;
                    return pz;
                }

                return retval;
            }
            catch (Exception ex)
            {
                retval.execResult = ex.HResult;
                log = "EXCEPTION. ERROR = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                retval.errorInfo.sErrorMessage = log;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
            }

            return retval;
        } //End of Function

        public int ReadPatternValue(ref PatternValueEx pattern)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternValue";
            int retval = 0;
            string fName = "";
            double density = 0;
            try
            {
                if (cbxPatternList.SelectedIndex >= 0)
                    fName = cbxPatternList.SelectedItem.ToString();
                else
                    fName = "Pattern_DEFAULT";

                double.TryParse(txtDensity.Text, out density);

                pattern.name = fName;
                ReadPatternFontValue(ref pattern.fontValue);
                ReadPatternLaserValue(ref pattern.laserValue);
                ReadPatternSpeedValue(density, ref pattern.speedValue);
                ReadPatternHeadValue(ref pattern.headValue);
                ReadPatternPositionValue(ref pattern.positionValue);
                ReadPatternScanValue(ref pattern.scanValue);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }

            return retval;
        }


        /// <summary>
        /// //
        /// </summary>
        /// <param name="fontValue"></param>
        public int ReadPatternFontValue(ref FontValue fontValue)
        {
            //string patternfile = Constants.PATTERN_PATH + name + ".ini";
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternFontValue";

            try
            {
                //fontValue = (FontValue)orgPattern.fontValue.Clone();

                if (cbxFontName.SelectedIndex >= 0)
                    fontValue.fontName = cbxFontName.SelectedItem.ToString();
                else
                    return -1;

                double.TryParse(txtHeight.Text, out fontValue.height);
                double.TryParse(txtWidth.Text, out fontValue.width);
                double.TryParse(txtPitch.Text, out fontValue.pitch);
                double.TryParse(txtAngle.Text, out fontValue.rotateAngle);
                double.TryParse(txtThickness.Text, out fontValue.thickness);
                return 0;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                return ex.HResult;
            }
        }

        /// <summary>
        /// //
        /// </summary>
        /// <param name="headValue"></param>
        public void ReadPatternHeadValue(ref HeadValue headValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternHeadValue";
            short svalue = 0;
            double dbvalue = 0.0;

            try
            {
                headValue = (HeadValue)orgPattern.headValue.Clone();
                short.TryParse(lblMAX_X.Content.ToString(), out svalue); headValue.max_X = svalue;
                short.TryParse(lblMAX_Y.Content.ToString(), out svalue); headValue.max_Y = svalue;
                short.TryParse(lblMAX_Z.Content.ToString(), out svalue); headValue.max_Z = svalue;

                short.TryParse(lblStepLength.Content.ToString(), out headValue.stepLength);

                double.TryParse(txtSensorAngle.Text, out headValue.angleDegree);
                short.TryParse(txtOpmode.Text, out headValue.opmode);

                if (rdbtnSensorPosLeft.IsChecked == true)
                    headValue.sensorPosition = 1;
                else
                    headValue.sensorPosition = 0;

                if (rdbtnSpatterPosDown.IsChecked == true)
                    headValue.spatterType = 1;
                else
                    headValue.spatterType = 0;

                double.TryParse(txtPark_X.Text, out dbvalue); headValue.park3DPos.X = dbvalue;
                double.TryParse(txtPark_Y.Text, out dbvalue); headValue.park3DPos.Y = dbvalue;
                double.TryParse(txtPark_Z.Text, out dbvalue); headValue.park3DPos.Z = dbvalue;

                double.TryParse(txtHome_X.Text, out dbvalue); headValue.home3DPos.X = dbvalue;
                double.TryParse(txtHome_Y.Text, out dbvalue); headValue.home3DPos.Y = dbvalue;
                double.TryParse(txtHome_Z.Text, out dbvalue); headValue.home3DPos.Z = dbvalue;

                double.TryParse(txtRasterStartPoint.Text, out headValue.rasterSP);
                double.TryParse(txtRasterEndPoint.Text, out headValue.rasterEP);

                double.TryParse(txtDistance0Pos.Text, out headValue.distance0Position);

                short.TryParse(txtMarkDelayTime1.Text, out headValue.markDelayTime1);
                short.TryParse(txtMarkDelayTime2.Text, out headValue.markDelayTime2);

                if (rdbtnUseSensorYes.IsChecked == true)
                    headValue.bySkipPlateCheck = 0;
                else
                    headValue.bySkipPlateCheck = 1;

                double.TryParse(txtSlopeValue.Text, out headValue.slope);
                double.TryParse(txtSlope4Manual.Text, out headValue.slope4Manual);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        /// <summary>
        /// //
        /// </summary>
        /// <param name="positionValue"></param>
        public void ReadPatternPositionValue(ref PositionValue positionValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternPositionValue";
            double dbvalue = 0;
            string value = "";

            try
            {
                positionValue = (PositionValue)orgPattern.positionValue.Clone();

                double.TryParse(txtCenter_X.Text, out dbvalue); positionValue.center3DPos.X = dbvalue;
                double.TryParse(txtCenter_Y.Text, out dbvalue); positionValue.center3DPos.Y = dbvalue;
                double.TryParse(txtCenter_Z.Text, out dbvalue); positionValue.center3DPos.Z = dbvalue;

                double.TryParse(txtCheckHeight.Text, out dbvalue); positionValue.checkDistanceHeight = dbvalue;
                double.TryParse(txtTeachingZPos.Text, out dbvalue); positionValue.teachingZHeight = dbvalue;
                //double.TryParse(txtCleaningZPos.Text, out dbvalue); positionValue.cleaningHeight = dbvalue;
                value = cbxPlateMode.SelectedItem.ToString();
                byte.TryParse(value, out positionValue.plateMode);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        /// <summary>
        /// //
        /// </summary>
        /// <param name="laserValue"></param>
        public void ReadPatternLaserValue(ref LaserValue laserValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternLaserValue";

            try
            {
                laserValue = (LaserValue)orgPattern.laserValue.Clone();
                laserValue.markPower = txtMarkPower.Text;
                laserValue.markWidth = txtMarkWidth.Text;

                laserValue.cleanPower = txtCleanPower.Text;
                laserValue.cleanWidth = txtCleanWidth.Text;

                laserValue.platePower = txtMeasurePower.Text;
                laserValue.plateWidth = txtMeasureWidth.Text;

                laserValue.spotPower = txtSpotPower.Text;
                laserValue.spotWidth = txtSpotWidth.Text;

                laserValue.sPhaseComp = txtPhaseComp.Text;

                double.TryParse(txtCleaningZPos.Text, out laserValue.cleanPosition);

                //laserValue = (LaserValue)orgPattern.laserValue.Clone();
                //short.TryParse(txtProfileNum.Text, out laserValue.waveformNum);
                //short.TryParse(txtCleanProfileNum.Text, out laserValue.waveformClean);
                //double.TryParse(txtCleanPosition.Text, out laserValue.cleanPosition);
                //double.TryParse(txtCleanDelta.Text, out laserValue.cleanDelta);
                ////if (rdbtnUseCleaningYes.IsChecked == true)
                if (rdbtnUseCleanYes.IsChecked == true)
                    laserValue.useCleaning = 1;
                else
                    laserValue.useCleaning = 0;
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        /// <summary>
        /// //
        /// </summary>
        /// <param name="density"></param>
        /// <param name="speedValue"></param>
        public void ReadPatternSpeedValue(double density, ref SpeedValue speedValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternSpeedValue";

            try
            {
                speedValue = (SpeedValue)orgPattern.speedValue.Clone();
                if (density != 1)
                {
                    short.TryParse(txbSpeedMarkInitialValue.Text, out speedValue.initSpeed4MarkV);
                    short.TryParse(txbSpeedMarkTargetValue.Text, out speedValue.targetSpeed4MarkV);
                    short.TryParse(txbSpeedMarkAccelValue.Text, out speedValue.accelSpeed4MarkV);
                    short.TryParse(txbSpeedMarkDecelValue.Text, out speedValue.decelSpeed4MarkV);
                }
                else
                {
                    short.TryParse(txbSpeedMarkInitialValue.Text, out speedValue.initSpeed4MarkR);
                    short.TryParse(txbSpeedMarkTargetValue.Text, out speedValue.targetSpeed4MarkR);
                    short.TryParse(txbSpeedMarkAccelValue.Text, out speedValue.accelSpeed4MarkR);
                    short.TryParse(txbSpeedMarkDecelValue.Text, out speedValue.decelSpeed4MarkR);
                }

                //
                short.TryParse(txbSpeedFastInitialValue.Text, out speedValue.initSpeed4Fast);
                short.TryParse(txbSpeedFastTargetValue.Text, out speedValue.targetSpeed4Fast);
                short.TryParse(txbSpeedFastAccelValue.Text, out speedValue.accelSpeed4Fast);
                short.TryParse(txbSpeedFastDecelValue.Text, out speedValue.decelSpeed4Fast);

                short.TryParse(txbSpeedHomeInitialValue.Text, out speedValue.initSpeed4Home);
                short.TryParse(txbSpeedHomeTargetValue.Text, out speedValue.targetSpeed4Home);
                short.TryParse(txbSpeedHomeAccelValue.Text, out speedValue.accelSpeed4Home);
                short.TryParse(txbSpeedHomeDecelValue.Text, out speedValue.decelSpeed4Home);

                short.TryParse(txbSpeedMeasureInitialValue.Text, out speedValue.initSpeed4Measure);
                short.TryParse(txbSpeedMeasureTargetValue.Text, out speedValue.targetSpeed4Measure);
                short.TryParse(txbSpeedMeasureAccelValue.Text, out speedValue.accelSpeed4Measure);
                short.TryParse(txbSpeedMeasureDecelValue.Text, out speedValue.decelSpeed4Measure);

                short.TryParse(txbSpeedCleanInitialValue.Text, out speedValue.initSpeed4Clean);
                short.TryParse(txbSpeedCleanTargetValue.Text, out speedValue.targetSpeed4Clean);
                short.TryParse(txbSpeedCleanAccelValue.Text, out speedValue.accelSpeed4Clean);
                short.TryParse(txbSpeedCleanDecelValue.Text, out speedValue.decelSpeed4Clean);

                short.TryParse(txtSolOnTime.Text, out speedValue.solOnTime);
                short.TryParse(txtSolOffTime.Text, out speedValue.solOffTime);
                short.TryParse(txtDWellTime.Text, out speedValue.dwellTime);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        /// <summary>
        /// //
        /// </summary>
        /// <param name="scanvalue"></param>
        public void ReadPatternScanValue(ref ScanValue scanvalue)
        {
            string className = "SetControllerWindow3";
            string funcName = "ReadPatternScanValue";

            try
            {
                double.TryParse(txtVisionStartPos.Text, out scanvalue.startU);
                double.TryParse(txtVisionScanLength.Text, out scanvalue.scanLen);
                double.TryParse(txtVisionParkPos.Text, out scanvalue.parkingU);
                double.TryParse(txtVisionHomePos.Text, out scanvalue.home_U);
                double.TryParse(txtVisionLinkPos.Text, out scanvalue.linkPos);
                short.TryParse(lblVisionMaxLength.Content.ToString(), out scanvalue.max_U);
                short.TryParse(lblVisionStepLength.Content.ToString(), out scanvalue.stepLength_U);

                short.TryParse(txbSpeedScanInitialValue.Text, out scanvalue.initSpeed4Scan);
                short.TryParse(txbSpeedScanTargetValue.Text, out scanvalue.targetSpeed4Scan);
                short.TryParse(txbSpeedScanAccelValue.Text, out scanvalue.accelSpeed4Scan);
                short.TryParse(txbSpeedScanDecelValue.Text, out scanvalue.decelSpeed4Scan);
                short.TryParse(txbSpeedScanFastInitialValue.Text, out scanvalue.initSpeed4ScanFree);
                short.TryParse(txbSpeedScanFastTargetValue.Text, out scanvalue.targetSpeed4ScanFree);
                short.TryParse(txbSpeedScanFastAccelValue.Text, out scanvalue.accelSpeed4ScanFree);
                short.TryParse(txbSpeedScanFastDecelValue.Text, out scanvalue.decelSpeed4ScanFree);

                if (rdbtnVisionLeft.IsChecked == true) scanvalue.reverseScan = 1;
                if (rdbtnVisionRight.IsChecked == true) scanvalue.reverseScan = 0;

            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }


        //public int ReadPatternFontValue(ref FontValue fontvalue)
        //{
        //    int retval = 0;

        //    return retval;
        //}


        //public int ReadPatternPositionValue(ref PositionValue posvalue)
        //{
        //    int retval = 0;

        //    return retval;
        //}


        //public int ReadatternSpeedValue(ref SpeedValue speedvalue)
        //{
        //    int retval = 0;

        //    return retval;
        //}

        //public int ReadPatternHeadValue(ref HeadValue headvalue)
        //{
        //    int retval = 0;

        //    return retval;
        //}

        //public int ReadPatternLaserValue(ref LaserValue laservalue)
        //{
        //    int retval = 0;

        //    return retval;
        //}

        //public int ReadPatternScanValue(ref ScanValue scanvalue)
        //{
        //    int retval = 0;

        //    return retval;
        //}


        public void DisplayPatternValue(byte byheadType, PatternValueEx pattern)
        {
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternValue";

            try
            {
                if (cbxPatternList.Items.Contains(pattern.name) == true)
                    cbxPatternList.SelectedItem = pattern.name;
                else
                    cbxPatternList.SelectedIndex = 0;

                DisplayPatternFontValue(byheadType, pattern.fontValue);
                DisplayPatternHeadValue(byheadType, pattern.headValue);
                DisplayPatternLaserValue(byheadType, pattern.laserValue);
                DisplayPatternPositionValue(byheadType, pattern.positionValue);
                DisplayPatternScanValue(byheadType, pattern.scanValue);
                DisplayPatternSpeedValue(byheadType, pattern.laserValue.density, pattern.speedValue);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        public void DisplayPatternFontValue(byte byheadType, FontValue fontValue)
        {
            //string patternfile = Constants.PATTERN_PATH + name + ".ini";
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternFontValue";

            try
            {
                if (cbxFontName.Items.Contains(fontValue.fontName) == true)
                    cbxFontName.SelectedItem = fontValue.fontName;
                else
                    cbxFontName.SelectedIndex = 0;

                txtHeight.Text = fontValue.height.ToString("F2");
                txtWidth.Text = fontValue.width.ToString("F2");
                txtPitch.Text = fontValue.pitch.ToString("F2");
                txtAngle.Text = fontValue.rotateAngle.ToString("F2");
                txtThickness.Text = fontValue.thickness.ToString("F2");
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        public void DisplayPatternHeadValue(byte byheadType, HeadValue headValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternHeadValue";
            //public short opmode;
            //public short stepLength;
            //public double angleDegree;
            //public byte sensorPosition;
            //public byte spatterType;

            try
            {
                lblMAX_X.Content = headValue.max_X.ToString();
                lblMAX_Y.Content = headValue.max_Y.ToString();
                lblMAX_Z.Content = headValue.max_Z.ToString();

                lblStepLength.Content = headValue.stepLength.ToString();
                txtSensorAngle.Text = headValue.angleDegree.ToString("F4");
                txtOpmode.Text = headValue.opmode.ToString();

                if (headValue.sensorPosition == 0)
                {
                    rdbtnSensorPosLeft.IsChecked = false;
                    rdbtnSensorPosRight.IsChecked = true;
                }
                else
                {
                    rdbtnSensorPosLeft.IsChecked = true;
                    rdbtnSensorPosRight.IsChecked = false;
                }

                if (headValue.spatterType == 0)
                {
                    rdbtnSpatterPosDown.IsChecked = false;
                    rdbtnSpatterPosUp.IsChecked = true;
                }
                else
                {
                    rdbtnSpatterPosDown.IsChecked = true;
                    rdbtnSpatterPosUp.IsChecked = false;
                }

                txtPark_X.Text = headValue.park3DPos.X.ToString("F2");
                txtPark_Y.Text = headValue.park3DPos.Y.ToString("F2");
                txtPark_Z.Text = headValue.park3DPos.Z.ToString("F2");

                txtHome_X.Text = headValue.home3DPos.X.ToString("F2");
                txtHome_Y.Text = headValue.home3DPos.Y.ToString("F2");
                txtHome_Z.Text = headValue.home3DPos.Z.ToString("F2");

                txtRasterStartPoint.Text = headValue.rasterSP.ToString("F2");
                txtRasterEndPoint.Text = headValue.rasterEP.ToString("F2");

                txtDistance0Pos.Text = headValue.distance0Position.ToString("F2");

                txtMarkDelayTime1.Text = headValue.markDelayTime1.ToString();
                txtMarkDelayTime2.Text = headValue.markDelayTime2.ToString();

                if(headValue.bySkipPlateCheck == 0)
                {
                    rdbtnUseSensorYes.IsChecked = true;
                    rdbtnUseSensorNo.IsChecked = false;
                }
                else
                {
                    rdbtnUseSensorYes.IsChecked = false;
                    rdbtnUseSensorNo.IsChecked = true;
                }

                txtSlopeValue.Text = headValue.slope.ToString("F2");
                txtSlope4Manual.Text = headValue.slope4Manual.ToString("F2");

            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        public void DisplayPatternPositionValue(byte byheadType, PositionValue positionValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternPositionValue";

            try
            {
                txtCenter_X.Text = positionValue.center3DPos.X.ToString("F2");
                txtCenter_Y.Text = positionValue.center3DPos.Y.ToString("F2");
                txtCenter_Z.Text = positionValue.center3DPos.Z.ToString("F2");

                txtCheckHeight.Text = positionValue.checkDistanceHeight.ToString("F2");

                txtTeachingZPos.Text = positionValue.teachingZHeight.ToString("F2");
                //txtCleaningZPos.Text = positionValue.cleaningHeight.ToString("F2");
                cbxPlateMode.SelectedItem = positionValue.plateMode.ToString();
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        public void DisplayPatternLaserValue(byte byheadType, LaserValue laserValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternLaserValue";

            try
            {
                txtMarkPower.Text = laserValue.markPower;
                txtMarkWidth.Text = laserValue.markWidth;

                txtCleanPower.Text = laserValue.cleanPower;
                txtCleanWidth.Text = laserValue.cleanWidth;

                txtMeasurePower.Text = laserValue.platePower;
                txtMeasureWidth.Text = laserValue.plateWidth;

                txtSpotPower.Text = laserValue.spotPower;
                txtSpotWidth.Text = laserValue.spotWidth;

                //txtProfileNum.Text = laserValue.waveformNum.ToString();
                //txtCleanProfileNum.Text = laserValue.waveformClean.ToString();
                //txtCleanPosition.Text = laserValue.cleanPosition.ToString("F2");
                //txtCleanDelta.Text = laserValue.cleanDelta.ToString("F2");
                txtDensity.Text = laserValue.density.ToString("F2");
                txtPhaseComp.Text = laserValue.sPhaseComp;

                if (laserValue.useCleaning != 0)
                {
                    rdbtnUseCleanYes.IsChecked = true;
                    rdbtnUseCleanNo.IsChecked = false;
                }
                else
                {
                    rdbtnUseCleanYes.IsChecked = false;
                    rdbtnUseCleanNo.IsChecked = true;
                }

                txtCleaningZPos.Text = laserValue.cleanPosition.ToString("F2");
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        /// <summary>
        /// //
        /// </summary>
        /// <param name="byheadType"></param>
        /// <param name="density"></param>
        /// <param name="speedValue"></param>
        public void DisplayPatternSpeedValue(byte byheadType, double density, SpeedValue speedValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternSpeedValue";

            try
            {
                if (density != 1)
                {
                    txbSpeedMarkInitialValue.Text = speedValue.initSpeed4MarkV.ToString();
                    txbSpeedMarkTargetValue.Text = speedValue.targetSpeed4MarkV.ToString();
                    txbSpeedMarkAccelValue.Text = speedValue.accelSpeed4MarkV.ToString();
                    txbSpeedMarkDecelValue.Text = speedValue.decelSpeed4MarkV.ToString();
                }
                else
                {
                    txbSpeedMarkInitialValue.Text = speedValue.initSpeed4MarkR.ToString();
                    txbSpeedMarkTargetValue.Text = speedValue.targetSpeed4MarkR.ToString();
                    txbSpeedMarkAccelValue.Text = speedValue.accelSpeed4MarkR.ToString();
                    txbSpeedMarkDecelValue.Text = speedValue.decelSpeed4MarkR.ToString();
                }

                //
                txbSpeedFastInitialValue.Text = speedValue.initSpeed4Fast.ToString();
                txbSpeedFastTargetValue.Text = speedValue.targetSpeed4Fast.ToString();
                txbSpeedFastAccelValue.Text = speedValue.accelSpeed4Fast.ToString();
                txbSpeedFastDecelValue.Text = speedValue.decelSpeed4Fast.ToString();

                txbSpeedHomeInitialValue.Text = speedValue.initSpeed4Home.ToString();
                txbSpeedHomeTargetValue.Text = speedValue.targetSpeed4Home.ToString();
                txbSpeedHomeAccelValue.Text = speedValue.accelSpeed4Home.ToString();
                txbSpeedHomeDecelValue.Text = speedValue.decelSpeed4Home.ToString();

                txbSpeedMeasureInitialValue.Text = speedValue.initSpeed4Measure.ToString();
                txbSpeedMeasureTargetValue.Text = speedValue.targetSpeed4Measure.ToString();
                txbSpeedMeasureAccelValue.Text = speedValue.accelSpeed4Measure.ToString();
                txbSpeedMeasureDecelValue.Text = speedValue.decelSpeed4Measure.ToString();

                txbSpeedCleanInitialValue.Text = speedValue.initSpeed4Clean.ToString();
                txbSpeedCleanTargetValue.Text = speedValue.targetSpeed4Clean.ToString();
                txbSpeedCleanAccelValue.Text = speedValue.accelSpeed4Clean.ToString();
                txbSpeedCleanDecelValue.Text = speedValue.decelSpeed4Clean.ToString();

                txtSolOnTime.Text = speedValue.solOnTime.ToString();
                txtSolOffTime.Text = speedValue.solOffTime.ToString();
                txtDWellTime.Text = speedValue.dwellTime.ToString();
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }


        public void DisplayPatternScanValue(byte byheadType, ScanValue scanValue)
        {
            string className = "SetControllerWindow3";
            string funcName = "DisplayPatternScanValue";

            try
            {
                txtVisionStartPos.Text = scanValue.startU.ToString("F2");
                txtVisionScanLength.Text = scanValue.scanLen.ToString("F2");
                txtVisionParkPos.Text = scanValue.parkingU.ToString("F2");
                txtVisionHomePos.Text = scanValue.home_U.ToString("F2");
                txtVisionLinkPos.Text = scanValue.linkPos.ToString("F2");
                lblVisionMaxLength.Content = scanValue.max_U.ToString();
                lblVisionStepLength.Content = scanValue.stepLength_U.ToString();

                txbSpeedScanInitialValue.Text = scanValue.initSpeed4Scan.ToString();
                txbSpeedScanTargetValue.Text = scanValue.targetSpeed4Scan.ToString();
                txbSpeedScanAccelValue.Text = scanValue.accelSpeed4Scan.ToString();
                txbSpeedScanDecelValue.Text = scanValue.decelSpeed4Scan.ToString();
                txbSpeedScanFastInitialValue.Text = scanValue.initSpeed4ScanFree.ToString();
                txbSpeedScanFastTargetValue.Text = scanValue.targetSpeed4ScanFree.ToString();
                txbSpeedScanFastAccelValue.Text = scanValue.accelSpeed4ScanFree.ToString();
                txbSpeedScanFastDecelValue.Text = scanValue.decelSpeed4ScanFree.ToString();

                if (scanValue.reverseScan == 0)
                {
                    rdbtnVisionLeft.IsChecked = false;
                    rdbtnVisionRight.IsChecked = true;
                }
                else
                {
                    rdbtnVisionLeft.IsChecked = true;
                    rdbtnVisionRight.IsChecked = false;
                }
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private string GetString4Textbox(TextBox tbox)
        {
            string retval = "";

            if (tbox.CheckAccess())
                retval = tbox.Text;
            else
            {
                retval = tbox.Dispatcher.Invoke(new Func<string>(delegate
                {
                    return tbox.Text;
                }));
            }

            return retval;
        }

        private void btnSavePattern_Click(object sender, RoutedEventArgs e)
        {
            //string patName = "";
            string className = "SetControllerWindow3";
            string funcName = "btnSavePattern_Click";

            byte bHeadType = 0;
            string value = "";
            bool bret = false;
            PatternValueEx pattern = new PatternValueEx();
            string cmd = "SAVE PATTERN FILE";
            string patName = "";
            int retval = 0;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                if (cbxPatternList.SelectedIndex < 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "PLEASE SELECT PATTERN");
                    return;
                }

                patName = cbxPatternList.SelectedItem.ToString();

                bret = CheckSavePatternData(patName);
                if (bret == false)
                    return;

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);

                ReadPatternValue(ref pattern);
                retval = ImageProcessManager.SetPatternValue(pattern.name, bHeadType, pattern, 0);
                if (retval != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "");
                    return;
                }
                orgPattern = (PatternValueEx)pattern.Clone();
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void btnSaveAsPattern_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnSaveAsPattern_Click";

            string patName = "";
            byte bHeadType = 0;
            string value = "";
            //bool bret = false;
            //string filename = "";
            PatternValueEx pattern = new PatternValueEx();
            List<string> names = new List<string>();
            SaveFileDialog savedialog = new SaveFileDialog();
            string cmd = "SAVE AS PATTERN FILE";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");
                //ShowLog("START [SAVE AS PATTERN FILE]");

                if (cbxPatternList.SelectedIndex < 0)
                {
                    //ShowLog("[SAVE AS PATTERN FILE] ERROR - SELECT PATTERN");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "PATTERN NOT SELECTED");
                    return;
                }

                savedialog.InitialDirectory = AppDomain.CurrentDomain.BaseDirectory + Constants.PATTERN_PATH;
                savedialog.FileName = cbxPatternList.SelectedValue.ToString() + ".ini";
                savedialog.Filter = "INI Files (*.ini)|*.ini|All Files (*.*)|*.*";
                if (savedialog.ShowDialog() == false)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "USER CANCEL");
                    return;
                }

                patName = System.IO.Path.GetFileNameWithoutExtension(savedialog.FileName);
                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out bHeadType);

                ReadPatternValue(ref pattern);
                pattern.name = patName;
                ImageProcessManager.SetPatternValue(pattern.name, bHeadType, pattern, 0);

                //string patternfile = AppDomain.CurrentDomain.BaseDirectory + Constants.PATTERN_PATH;
                //names = DirFileSearch(patternfile, "*.ini").Result;
                //cbxPatternList.Items.Clear();
                //for (int i = 0; i < names.Count; i++)
                //{
                //    if (cbxPatternList.Items.Contains(Name[i]) == false)
                //        cbxPatternList.Items.Add(names[i]);
                //}
                int index = cbxPatternList.Items.IndexOf(patName);
                if (index < 0)
                    cbxPatternList.Items.Add(patName);

                if (cbxPatternList.Items.Count > 0)
                {
                    cbxPatternList.SelectedItem = patName;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE : {0}, MSG : {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnLaserReset_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnLaserReset_Click";// MethodBase.GetCurrentMethod().Name;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            //string value = "";
            string cmd = "레이저 에러 초기화";
            string log = "";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ResetErrors();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ResetErrors();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ResetErrors();
                }
                if (retval.execResult != 0)
                {
                    log = "에러 리셋 실패 (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_END, cmd, "", "");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("GET LASER STATUS - EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnGetLinkStatus_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnGetLinkStatus_Click";
            string log = "";
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "GET LINK STATUS";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                if (retval.execResult != 0)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "STATUS: " + retval.recvString);
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);
                //ShowLog("END [GET LINK STATUS]");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnSetLinkOn_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnSetLinkStatus_Click";
            string log = "";
            //byte link = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "SET LINK STATUS";
            Stopwatch sw1 = new Stopwatch();
            Stopwatch swLink = new Stopwatch();
            bool bOK = false;
            double headPos = 0.0;
            double linkPos = 0.0;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                if(txtCurrentPosX.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - UNKNOWN POSITION");
                    return;
                }

                double.TryParse(txtCurrentPosX.Text, out headPos);
                double.TryParse(txtVisionLinkPos.Text, out linkPos);
                if(headPos <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INVALID POSITION");
                    return;
                }

                if(headPos != linkPos)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INCORECT POSITION");
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }

                swLink.Start();
                while (swLink.ElapsedMilliseconds < 1000)
                {
                    await Task.Delay(50);
                }
                swLink.Stop();

                sw1.Start();
                while (sw1.Elapsed < TimeSpan.FromMilliseconds(1000))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                    if (retval.execResult != 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "PLC COMMUNICATION ERROR", retval.execResult.ToString());
                        //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("GetLinkAsync ERROR : {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    if (retval.recvString.Length < 8)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "PLC DATA INVALID", retval.execResult.ToString());
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("GetLinkAsync ERROR : PLC STRING LENGTH SHORT {0}", retval.recvString.Length), Thread.CurrentThread.ManagedThreadId);
                        //retval.execResult = -17;
                        return;
                    }

                    if (retval.recvString.Substring(4, 4) == PLCControlManager.SIGNAL_PLC2PC_ON)
                    {
                        bOK = true;
                        break;
                    }

                    await Task.Delay(100);
                }
                sw1.Stop();

                if (bOK == true)
                {
                    ShowLog((byte)LOGTYPE.LOG_SUCCESS, cmd, "");
                    //btnSetLinkOff.IsEnabled = false;
                    //btnSetLinkOn.IsEnabled = false;
                }
                else
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "SET LINK ERROR");
                //ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnVisionLinkPoint_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnVisionPoint_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;
            short sVisionX = 0;
            short sParkY = 0;
            short sParkZ = 0;
            PositionValue posvalue = new PositionValue();
            ScanValue scanval = new ScanValue();
            HeadValue headval = new HeadValue();
            string cmd = "GO TO LINK POSITION";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                ReadPatternPositionValue(ref posvalue);
                ReadPatternScanValue(ref scanval);
                ReadPatternHeadValue(ref headval);

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                sVisionX = (short)(headval.park3DPos.X * stepLength + 0.5);
                sParkY = (short)(headval.park3DPos.Y * stepLength + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * stepLength + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                //m_currCMD = (byte)'K';
                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(sVisionX, sParkY, sParkZ);
                //if (retval.execResult != 0)
                //{
                //    ShowLog("[GO PARKING TO POSITION] ERROR - (" + retval.execResult.ToString() + ")");
                //    return;
                //}

                if (scanval.stepLength_U <= 0)
                    scanval.stepLength_U = 100;

                sVisionX = (short)(scanval.linkPos * scanval.stepLength_U + 0.5);
                sParkY = (short)(headval.park3DPos.Y * scanval.stepLength_U + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * scanval.stepLength_U + 0.5);

                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[GO TO VISION POSITION] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }
                btnSetLinkOff.IsEnabled = true;
                btnSetLinkOn.IsEnabled = true;
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("[GO TO VISION POSITION] EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnVisionStartPoint_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnVisionStartPoint_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            //short stepLength = 0;
            short sVisionX = 0;
            short sParkY = 0;
            short sParkZ = 0;
            PositionValue posvalue = new PositionValue();
            ScanValue scanval = new ScanValue();
            HeadValue headval = new HeadValue();
            string status = "";
            string cmd = "GO TO VISION POSITION";

            try
            {
                //ShowLog("[GO TO VISION START POSITION] START");
                //ShowLog("[GET LINK STATUS] START");
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                if (retval.execResult != 0)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                    return;
                }

                //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);

                if (retval.recvString.Length < 8)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                    return;
                }

                status = retval.recvString.Substring(4, 4);
                if (status != PLCControlManager.SIGNAL_PLC2PC_ON)
                {
                    //ShowLog("START [SET LINK]");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[SET LINK] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET LINK STATUS ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    Thread.Sleep(500);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);

                    if (retval.recvString.Length < 8)
                    {
                        //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                        return;
                    }

                    status = retval.recvString.Substring(4, 4);
                    if (status != PLCControlManager.SIGNAL_PLC2PC_ON)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "LINK STATUS ERROR - LINK FAIL");
                        return;
                    }
                }

                ReadPatternPositionValue(ref posvalue);
                ReadPatternScanValue(ref scanval);
                ReadPatternHeadValue(ref headval);

                //short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                //if (stepLength <= 0)
                //    stepLength = 100;

                sParkY = (short)(headval.park3DPos.Y * scanval.stepLength_U + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * scanval.stepLength_U + 0.5);
                if (ckbReverseScan.IsChecked == false)
                    sVisionX = (short)(scanval.startU * scanval.stepLength_U + 0.5);
                else
                    sVisionX = (short)((scanval.startU + scanval.scanLen) * scanval.stepLength_U + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[GO TO VISION POSITION] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                //ShowLog("[GO TO VISION POSITION] SUCCESS");
            }
            catch (Exception ex)
            {
                //string log = "";
                //log = string.Format("[GO TO VISION POSITION] EXCEPTION {0:X}, {1}", ex.HResult, ex.Message);
                //ShowLog(log);
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnVisionStartScan_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnVisionStartScan_Click";// MethodBase.GetCurrentMethod().Name;

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;
            short sVisionX = 0;
            short sParkY = 0;
            short sParkZ = 0;
            PositionValue posvalue = new PositionValue();
            ScanValue scanval = new ScanValue();
            HeadValue headValue = new HeadValue();
            string status = "";
            string cmd = "START SCAN";

            try
            {
                //ShowLog("[MOVE SCAN] START");
                //ShowLog("[GET LINK STATUS] START");
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                ReadPatternPositionValue(ref posvalue);
                ReadPatternScanValue(ref scanval);
                ReadPatternHeadValue(ref headValue);

                sParkY = (short)(headValue.park3DPos.Y * scanval.stepLength_U + 0.5);
                sParkZ = (short)(headValue.park3DPos.Z * scanval.stepLength_U + 0.5);

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                if (retval.execResult != 0)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                    return;
                }

                //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);

                if (retval.recvString.Length < 8)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                    return;
                }

                status = retval.recvString.Substring(4, 4);
                if (status != PLCControlManager.SIGNAL_PLC2PC_ON)
                {
                    //Move TO LINK Position
                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        return;
                    }

                    sVisionX = (short)(scanval.linkPos * scanval.stepLength_U + 0.5);

                    m_currCMD = (byte)'M';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[MVOE SCAN] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    //ShowLog("[SET LINK]");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[SET LINK] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET LINK STATUS ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    Thread.Sleep(500);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);

                    if (retval.recvString.Length < 8)
                    {
                        //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                        return;
                    }

                    status = retval.recvString.Substring(4, 4);
                    if (status != PLCControlManager.SIGNAL_PLC2PC_ON)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "LINK STATUS ERROR - LINK FAIL");
                        return;
                    }
                }

                //ReadPatternPositionValue(ref posvalue);
                //ReadPatternScanValue(ref scanval);

                //short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                //if (stepLength <= 0)
                //    stepLength = 100;

                ////sVisionX = (short)((scanval.startU + scanval.scanLen) * scanval.stepLength_U + 0.5);
                //sParkY = (short)(posvalue.park3DPos.Y * scanval.stepLength_U + 0.5);
                //sParkZ = (short)(posvalue.park3DPos.Z * scanval.stepLength_U + 0.5);

                if (ckbReverseScan.IsChecked == true)
                    sVisionX = (short)(scanval.startU * scanval.stepLength_U + 0.5);
                else
                    sVisionX = (short)((scanval.startU + scanval.scanLen) * scanval.stepLength_U + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.ScanMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[MOVE SCAN] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }

                //ShowLog("[MVOE SCAN] -[GO TO VISION START POSITION] START");
                //sParkY = (short)(posvalue.park3DPos.Y * scanval.stepLength_U + 0.5);
                //sParkZ = (short)(posvalue.park3DPos.Z * scanval.stepLength_U + 0.5);
                if (ckbReverseScan.IsChecked == false)
                    sVisionX = (short)(scanval.startU * scanval.stepLength_U + 0.5);
                else
                    sVisionX = (short)((scanval.startU + scanval.scanLen) * scanval.stepLength_U + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[MVOE SCAN] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }
                //ShowLog("[MVOE SCAN] -[GO TO VISION START POSITION] END");
                //ShowLog("[MOVE SCAN] SUCCESS");
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void ShowRectangle(Rectangle rect, Brush brush)
        {
            if (rect.CheckAccess())
            {
                rect.Fill = brush;
            }
            else
            {
                rect.Dispatcher.Invoke(new Action(delegate
                {
                    rect.Fill = brush;
                }));
            }
        }

        private void btnMoveScanHome_Click(object sender, RoutedEventArgs e)
        {

        }

        private void btnMoveScanMinus_Click(object sender, RoutedEventArgs e)
        {

        }

        private void btnMoveScanPlus_Click(object sender, RoutedEventArgs e)
        {

        }

        private async void LaserErrorTxt_MouseDoubleClick(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            ITNTResponseArgs retval = new ITNTResponseArgs();

            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ResetErrors();
        }

        private void SetString4Textbox(string text, TextBox tbox, Brush foreColor, Brush backColor)
        {
            if (tbox.CheckAccess())
            {
                tbox.Text = text;
                if (foreColor != null)
                    tbox.Foreground = foreColor;
                if (backColor != null)
                    tbox.Background = backColor;
            }
            else
            {
                tbox.Dispatcher.Invoke(new Action(delegate
                {
                    tbox.Text = text;
                    if (foreColor != null)
                        tbox.Foreground = foreColor;
                    if (backColor != null)
                        tbox.Background = backColor;
                }));
            }
        }


        public async void OnLaserControllerStatusChangedEventReceivedFunc(object sender, LaserControllerStatusEvnetArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "OnLaserControllerStatusChangedEventReceivedFunc";
            System.Windows.Media.Brush brushesBorder = System.Windows.Media.Brushes.Black;
            LASERSTATUS Status = 0;
            UInt32 ists = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();

            try
            {
                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);

                if ((e.datatype == 0) & (e.recvdata1 != GetTextBoxData(LaserErrorTxt)))
                {
                    //UInt32.TryParse(e.recvdata1, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out ists);
                    UInt32.TryParse(e.recvdata1, out ists);
                    Status = (LASERSTATUS)ists;
                    ShowTextBoxData(LaserErrorTxt, ists.ToString("X8"));

                    if ((Status & LASERSTATUS.StatusNormalOn) != LASERSTATUS.StatusNormalOn)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("Status 1 Error(Must be 1) : {0:X}", Status), Thread.CurrentThread.ManagedThreadId);
                        //Debug.WriteLine(string.Format("Status 1 Error(Must be 1) : {0:X}", Status));
                        //if ((Status & LASERSTATUS.PulseModeCWMode) == 0) Debug.WriteLine("0 : " + LASERSTATUS.PulseModeCWMode.ToString());
                        //if ((Status & LASERSTATUS.GateModeEnableDisable) == 0) Debug.WriteLine("0 : " + LASERSTATUS.GateModeEnableDisable.ToString());
                        //if ((Status & LASERSTATUS.FrontPanelDisplayLockedUnlocked) == 0) Debug.WriteLine("0 : " + LASERSTATUS.FrontPanelDisplayLockedUnlocked.ToString());
                        //if ((Status & LASERSTATUS.KeyswitchIsRemOnPosition) == 0) Debug.WriteLine("0 : " + LASERSTATUS.KeyswitchIsRemOnPosition.ToString());
                        //if ((Status & LASERSTATUS.WaveformPulseModeOnOff) == 0)
                        //{
                        //    //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0 : " + LASERSTATUS.WaveformPulseModeOnOff.ToString() + " => Set 1", Thread.CurrentThread.ManagedThreadId);
                        //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.EnableWaveformPulseMode();
                        //}
                        brushesBorder = (brushesBorder != Brushes.Black) ? Brushes.Black : Brushes.OrangeRed;
                    }
                    if ((Status & LASERSTATUS.StatusNormalOff) != 0)
                    {
                        //Debug.WriteLine(string.Format("Status 0 Error(Must be 0): {0:X}", Status));
                        //if ((Status & LASERSTATUS.AnalogPowerControlEnableDisable) != 0) Debug.WriteLine("1 : " + LASERSTATUS.AnalogPowerControlEnableDisable.ToString());
                        //if ((Status & LASERSTATUS.PowerSupplyOnOff) != 0) Debug.WriteLine("1 : " + LASERSTATUS.PowerSupplyOnOff.ToString());
                        //if ((Status & LASERSTATUS.ModulationEnabledDisabled) != 0) Debug.WriteLine("1 : " + LASERSTATUS.ModulationEnabledDisabled.ToString());
                        //if ((Status & LASERSTATUS.HWEmissionCtrlEnabledDisabled) != 0) Debug.WriteLine("1 : " + LASERSTATUS.HWEmissionCtrlEnabledDisabled.ToString());
                        //if ((Status & LASERSTATUS.HWAimingBeamCtrlEnabledDisabled) != 0) Debug.WriteLine("1 : " + LASERSTATUS.HWAimingBeamCtrlEnabledDisabled.ToString());
                        //if ((Status & LASERSTATUS.FiberInterlockActiveOK) != 0) Debug.WriteLine("1 : " + LASERSTATUS.FiberInterlockActiveOK.ToString());
                        //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("Status 0 Error(Must be 0) : {0:X}", Status), Thread.CurrentThread.ManagedThreadId);
                        brushesBorder = (brushesBorder != Brushes.Black) ? Brushes.Black : Brushes.LightBlue;
                    }
                    if ((Status & LASERSTATUS.StatusError) != 0)
                    {
                        //ErrorLaserSource = true;
                        //ShowLabelData("ERROR", lblLaserStatus, Brushes.White, Brushes.Red);//, brushesBorder);
                        //ShowLabelData(Status.ToString("X"), lblLastErrorValue, Brushes.Red, null, brushesBorder);
                        //ShowTextBoxData(LaserErrorTxt, Status.ToString("X8"));
                        ShowTextBoxData(LaserErrorTxt, ists.ToString("X8"));
                    }
                    else
                    {
                        //ErrorLaserSource = false;
                        //ShowLabelData("NORMAL", lblLaserStatus, Brushes.Black, Brushes.Green);//, brushesBorder);
                        //ShowLabelData(Status.ToString("X"), lblLastErrorValue, Brushes.Black, null, brushesBorder);
                    }

                    //if ((ists & (uint)LASERSTATUS.StatusError) != 0)
                    //{
                    //    ShowLabelData("ERROR", lblLaserStatus, System.Windows.Media.Brushes.White, System.Windows.Media.Brushes.Red);
                    //}
                    //else
                    //{
                    //    ShowLabelData("NORMAL", lblLaserStatus, System.Windows.Media.Brushes.Black, System.Windows.Media.Brushes.Green);
                    //}

                    //brushesEmission = Brushes.Red;
                    //brushesEmission = Brushes.Black;
                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
                        ShowRectangle(EmissionLamp, Brushes.Red);
                    else
                        ShowRectangle(EmissionLamp, Brushes.Black);

                    //brushesAiming = Brushes.Red;
                    //brushesAiming = Brushes.Black;
                    if ((Status & LASERSTATUS.AimingBeamOnOff) != 0)
                        ShowRectangle(AimingLamp, Brushes.Red);
                    else
                        ShowRectangle(AimingLamp, Brushes.Black);

                    //ShowRectangle(brushesEmission, EmissionLamp);
                    //ShowRectangle(brushesAiming, AimingLamp);

                    //if ((Status & LASERSTATUS.StatusNormalOn) != LASERSTATUS.StatusNormalOn)
                    //{
                    //    brushesBorder = (brushesBorder != System.Windows.Media.Brushes.Black) ? System.Windows.Media.Brushes.Black : System.Windows.Media.Brushes.OrangeRed;
                    //}
                    //if ((Status & LASERSTATUS.StatusNormalOff) != 0)
                    //{
                    //    brushesBorder = (brushesBorder != System.Windows.Media.Brushes.Black) ? System.Windows.Media.Brushes.Black : System.Windows.Media.Brushes.LightBlue;
                    //}


                    //ControlWindow.EmissionLamp.Fill = brushesEmission;
                    //ControlWindow.AimingLamp.Fill = brushesAiming;


                    //brushesErrorForground = (ErrorLaserSource) ? Brushes.Red : Brushes.Black;
                    //ControlWindow.LaserErrorTxt.Text = Status.ToString("X");
                    //ControlWindow.LaserErrorTxt.BorderBrush = brushesBorder;
                }


                if (e.datatype == 1)
                {
                    //if (e.recvdata1 != GetTextBoxData(AvgPowerTxt))
                    //    ShowTextBoxData(AvgPowerTxt, e.recvdata1);

                    int itmp = 0;
                    int.TryParse(e.recvdata2, out itmp);
                    if ((byLaserStartFlag != 0) && (itmp > 0))
                    {
                        iLaserPowerList.Add(itmp);
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, "MARKING", "POWER = " + itmp.ToString());
                    }

                    if (e.recvdata2 != GetTextBoxData(PeakPowerTxt))
                    {
                        string tmpstr = e.recvdata2.ToUpper();
                        if (itmp > 0)
                        {
                            iLaserPeakPower = itmp;
                            //ShowLabelData(e.recvdata2, lblPeakPowerValue);
                            ShowTextBoxData(PeakPowerTxt, e.recvdata2);
                        }

                        //if ((tmpstr.Contains("OFF") == false) && (tmpstr.Contains("LOW") == false))
                        //{
                        //    double.TryParse(e.recvdata2, out PeakPower);
                        //}
                    }
                }

                if ((e.datatype == 2) & (e.recvdata1 != GetTextBoxData(TemperatureTxt)))
                    ShowTextBoxData(TemperatureTxt, e.recvdata1);
            }
            catch (Exception ex)
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION - CODE = {0}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                //return ex.HResult;
            }
        }


        private string GetLabelData(Label label)
        {
            string retval = "";
            if (label.CheckAccess())
            {
                retval = label.Content.ToString();
            }
            else
            {
                retval = label.Dispatcher.Invoke(new Func<string>(delegate
                {
                    string ret = "";
                    ret = label.Content.ToString();
                    return ret;
                }));
            }

            return retval;
        }

        private async void btnVision11_Click(object sender, RoutedEventArgs e)
        {
            string value = "";
            byte byUsePattern = 0;
            string patName = "";
            string patternName = "Pattern_RG";
            string vinstring = " KMTFE11DDRU041221 ";
            string seq = "4432";
            string rawtype = "R   ";
            int retval = 0;
            ITNTSendArgs args = new ITNTSendArgs(64);
            string sendmsg = "";
            string dist1 = "0000000000";
            string dist2 = "0000000000";
            byte sOrder = 1;

            try
            {
                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }

                patternName = cbxPatternList.SelectedItem.ToString();
                Util.GetPrivateProfileValue("PATTERNNAME", patternName, "R", ref value, Constants.PARAMS_INI_FILE);
                rawtype = value.PadRight(4, ' ');

                vinstring = txtVIN.Text.ToString();
                byUsePattern = Util.GetPrivateProfileValueByte("OPTION", "USEPATTERN", 0, Constants.PARAMS_INI_FILE);
                if (byUsePattern != 0)
                {
                    patName = patternName.PadRight(16, ' ');
                    sendmsg = "C3" + seq + vinstring + rawtype + "1" + dist1 + dist2 + patName + "01" + sOrder.ToString("D2");
                }
                else
                {
                    sendmsg = "C2" + seq + vinstring + rawtype + "1" + dist1 + dist2 + "01" + sOrder.ToString("D2");
                }


                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0002 SEND VISION DATA", Thread.CurrentThread.ManagedThreadId);
                args.sendBuffer = Encoding.UTF8.GetBytes(sendmsg);
                args.sendString = sendmsg;
                args.dataSize = sendmsg.Length;

                Util.GetPrivateProfileValue("VISION", "TCPTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                if ((value == "0") || (value == "2"))
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionServer.SendMessage(args);
                else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionClient.SendMessage(args);
                return;
            }
            catch (Exception ex)
            {

            }
        }

        private async void btnVision12_Click(object sender, RoutedEventArgs e)
        {
            string value = "";
            byte byUsePattern = 0;
            string patName = "";
            string patternName = "";
            string vinstring = " KMTFE11DDRU041221 ";
            string seq = "4432";
            string rawtype = "R   ";
            int retval = 0;
            ITNTSendArgs args = new ITNTSendArgs(64);
            string sendmsg = "";
            string dist1 = "0000000000";
            string dist2 = "0000000000";
            byte sOrder = 1;

            try
            {
                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }

                patternName = cbxPatternList.SelectedItem.ToString();
                Util.GetPrivateProfileValue("PATTERNNAME", patternName, "R", ref value, Constants.PARAMS_INI_FILE);
                rawtype = value.PadRight(4, ' ');

                vinstring = txtVIN.Text.ToString();
                byUsePattern = Util.GetPrivateProfileValueByte("OPTION", "USEPATTERN", 0, Constants.PARAMS_INI_FILE);
                if (byUsePattern != 0)
                {
                    patName = patternName.PadRight(16, ' ');
                    sendmsg = "C7" + seq + vinstring + rawtype + "1" + dist1 + dist2 + patName + "01" + sOrder.ToString("D2");
                }
                else
                {
                    sendmsg = "C6" + seq + vinstring + rawtype + "1" + dist1 + dist2 + "01" + sOrder.ToString("D2");
                }


                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0002 SEND VISION DATA", Thread.CurrentThread.ManagedThreadId);
                args.sendBuffer = Encoding.UTF8.GetBytes(sendmsg);
                args.sendString = sendmsg;
                args.dataSize = sendmsg.Length;

                Util.GetPrivateProfileValue("VISION", "TCPTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                if ((value == "0") || (value == "2"))
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionServer.SendMessage(args);
                else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionClient.SendMessage(args);
                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).vision.SendMessage(args);
                return;
            }
            catch (Exception ex)
            {

            }
        }

        private async void btnVision21_Click(object sender, RoutedEventArgs e)
        {
            string value = "";
            byte byUsePattern = 0;
            string patName = "";
            string patternName = "Pattern_RG";
            string vinstring = " KMTFE11DDRU041221 ";
            string seq = "4432";
            string rawtype = "R   ";
            int retval = 0;
            ITNTSendArgs args = new ITNTSendArgs(64);
            string sendmsg = "";
            string dist1 = "0000000000";
            string dist2 = "0000000000";
            byte sOrder = 2;

            try
            {
                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }

                patternName = cbxPatternList.SelectedItem.ToString();
                Util.GetPrivateProfileValue("PATTERNNAME", patternName, "R", ref value, Constants.PARAMS_INI_FILE);
                rawtype = value.PadRight(4, ' ');

                vinstring = txtVIN.Text.ToString();
                byUsePattern = Util.GetPrivateProfileValueByte("OPTION", "USEPATTERN", 0, Constants.PARAMS_INI_FILE);
                if (byUsePattern != 0)
                {
                    patName = patternName.PadRight(16, ' ');
                    sendmsg = "C3" + seq + vinstring + rawtype + "1" + dist1 + dist2 + patName + "01" + sOrder.ToString("D2");
                }
                else
                {
                    sendmsg = "C2" + seq + vinstring + rawtype + "1" + dist1 + dist2 + "01" + sOrder.ToString("D2");
                }


                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0002 SEND VISION DATA", Thread.CurrentThread.ManagedThreadId);
                args.sendBuffer = Encoding.UTF8.GetBytes(sendmsg);
                args.sendString = sendmsg;
                args.dataSize = sendmsg.Length;

                Util.GetPrivateProfileValue("VISION", "TCPTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                if ((value == "0") || (value == "2"))
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionServer.SendMessage(args);
                else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionClient.SendMessage(args);
                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).vision.SendMessage(args);
                return;
            }
            catch (Exception ex)
            {

            }
        }

        private async void btnVision22_Click(object sender, RoutedEventArgs e)
        {
            string value = "";
            byte byUsePattern = 0;
            string patName = "";
            string patternName = "";
            string vinstring = " KMTFE11DDRU041221 ";
            string seq = "4432";
            string rawtype = "R   ";
            int retval = 0;
            ITNTSendArgs args = new ITNTSendArgs(64);
            string sendmsg = "";
            string dist1 = "0000000000";
            string dist2 = "0000000000";
            byte sOrder = 2;

            try
            {
                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }

                patternName = cbxPatternList.SelectedItem.ToString();
                Util.GetPrivateProfileValue("PATTERNNAME", patternName, "R", ref value, Constants.PARAMS_INI_FILE);
                rawtype = value.PadRight(4, ' ');

                vinstring = txtVIN.Text.ToString();
                byUsePattern = Util.GetPrivateProfileValueByte("OPTION", "USEPATTERN", 0, Constants.PARAMS_INI_FILE);
                if (byUsePattern != 0)
                {
                    patName = patternName.PadRight(16, ' ');
                    sendmsg = "C7" + seq + vinstring + rawtype + "1" + dist1 + dist2 + patName + "01" + sOrder.ToString("D2");
                }
                else
                {
                    sendmsg = "C6" + seq + vinstring + rawtype + "1" + dist1 + dist2 + "01" + sOrder.ToString("D2");
                }


                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0002 SEND VISION DATA", Thread.CurrentThread.ManagedThreadId);
                args.sendBuffer = Encoding.UTF8.GetBytes(sendmsg);
                args.sendString = sendmsg;
                args.dataSize = sendmsg.Length;

                Util.GetPrivateProfileValue("VISION", "TCPTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                if ((value == "0") || (value == "2"))
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionServer.SendMessage(args);
                else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionClient.SendMessage(args);
                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).vision.SendMessage(args);
                return;
            }
            catch (Exception ex)
            {

            }
        }

        private async void btnAirOn_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnAirOn_Click";
            string log = "";
            byte link = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "SET AIR ON";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnAirOff_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnAirOff_Click";
            string log = "";
            byte link = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "SET AIR OFF";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnSetLinkOff_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnSetLinkStatus_Click";
            string log = "";
            //byte link = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            string cmd = "SET LINK OFF";
            Stopwatch sw1 = new Stopwatch();
            Stopwatch swLink = new Stopwatch();
            bool bOK = false;
            double headPos = 0.0;
            double linkPos = 0.0;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                if (txtCurrentPosX.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - UNKNOWN POSITION");
                    return;
                }

                double.TryParse(txtCurrentPosX.Text, out headPos);
                double.TryParse(txtVisionLinkPos.Text, out linkPos);
                if (headPos <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INVALID POSITION");
                    return;
                }

                if (headPos != linkPos)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INCORECT POSITION");
                    return;
                }

                //if (chbLink.IsChecked == true)
                //    link = ;
                //else
                //    link = PLCControlManager.SIGNAL_PC2PLC_OFF;

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }

                swLink.Start();
                while (swLink.ElapsedMilliseconds < 1000)
                {
                    await Task.Delay(50);
                }
                swLink.Stop();

                sw1.Start();
                while (sw1.Elapsed < TimeSpan.FromMilliseconds(1000))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                    if (retval.execResult != 0)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "PLC COMMUNICATION ERROR", retval.execResult.ToString());
                        //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("GetLinkAsync ERROR : {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    if (retval.recvString.Length < 8)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "PLC DATA INVALID", retval.execResult.ToString());
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("GetLinkAsync ERROR : PLC STRING LENGTH SHORT {0}", retval.recvString.Length), Thread.CurrentThread.ManagedThreadId);
                        //retval.execResult = -17;
                        return;
                    }

                    if (retval.recvString.Substring(4, 4) == PLCControlManager.SIGNAL_PLC2PC_OFF)
                    {
                        bOK = true;
                        break;
                    }

                    await Task.Delay(100);
                }
                sw1.Stop();

                if (bOK == true)
                {
                    ShowLog((byte)LOGTYPE.LOG_SUCCESS, cmd, "");
                    //btnSetLinkOff.IsEnabled = false;
                    //btnSetLinkOn.IsEnabled = false;
                }
                else
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "SET LINK ERROR");
                //ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnAimingOn_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnAimingOn_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string log = "";
            string cmd = "AIMING ON";
            try
            {
                //1. Aiming Beam OFF
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                }
                if (retval.execResult != 0)
                {
                    log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //await((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    return;
                }
                ShowRectangle(AimingLamp, Brushes.Black);

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON();
                }
                if (retval.execResult != 0)
                {
                    log = "AimingBeamON. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    return;
                }
                ShowRectangle(AimingLamp, Brushes.Red);
                ShowLog((byte)LOGTYPE.LOG_SUCCESS, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);

            }
        }

        private async void btnAimingOff_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnAimingOff_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string log = "";
            string cmd = "AIMING OFF";
            try
            {
                //1. Aiming Beam OFF
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                }
                if (retval.execResult != 0)
                {
                    log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //await((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    return;
                }
                ShowRectangle(AimingLamp, Brushes.Black);
                ShowLog((byte)LOGTYPE.LOG_SUCCESS, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);

            }
        }

        private async void btnMarkCorner_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnMarkCorner_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string log = "";
            string cmd = "MARK CORNER";
            CheckAreaData AreaData = new CheckAreaData();
            PatternValueEx pattern = new PatternValueEx();
            string value = "";
            //string pw = "";
            short posX = 0, posY = 0, posZ = 0;
            byte bHeadType = 0;
            int vinLength = 19;
            double totWidth = 0;
            Vector3D centerPoint = new Vector3D();
            Vector3D startPoint0 = new Vector3D();
            Vector3D startPoint1 = new Vector3D();
            string patName = "";
            //string vin = "";

            string cornerVIN = "[                 ]";

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                if (cbxPatternList.SelectedIndex < 0)
                {
                    log = "SELECT PATTERN";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    return;
                }


//                patName = cbxPatternList.Text;


//                ReadPatternValue(ref pattern);
//                retval.execResult = ReadFontData(cmd, patName);
//                if (retval.execResult != 0)
//                {
//                    log = "READ FONT ERROR. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                ShowCurrentMarkingInformation(cornerVIN, pattern, )
//                await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
//                GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);


//                if (bReadFontValue == false)
//                {
//                    bReadFontValue = true;
//                }

//                //1. Aiming Beam OFF
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
//                if (retval.execResult != 0)
//                {
//                    log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }
//                ShowRectangle(AimingLamp, Brushes.Black);

//                //2.read laser status
//                //ShowLog("MARKING - READ LASER STATUS");
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
//                if (retval.execResult != 0)
//                {
//                    log = "READ LASER STATUS. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                string[] st = retval.recvString.Split(':');
//                if (st.Length < 2)
//                {
//                    log = "READ LASER STATUS. (STATUS STRING)";
//                    ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }
//                //2-1. Check emission status
//                Status = (LASERSTATUS)UInt32.Parse(st[1]);
//                if ((Status & LASERSTATUS.EmissionOnOff) != 0)
//                {
//                    //ShowLog("MARKING - STOP EMISSION");
//                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
//                    if (retval.execResult != 0)
//                    {
//                        log = "STOP EMISSION. (RESULT = " + retval.execResult.ToString() + ")";
//                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }
//                    ShowRectangle(EmissionLamp, Brushes.Black);
//                    //EmissionLamp.Fill = Brushes.Black;
//                }

//                //3. load waveform profile number
//                // ShowLog("MARKING - SELECT PROFILE");
//#if LASER_YLR
//                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString());
//                    if (retval.execResult != 0)
//                    {
//                        log = "SELECT PROFILE. (" + retval.execResult.ToString() + ")";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }

//                    string[] prsel = retval.recvString.Split('[', ']');
//                    if (prsel.Length < 2)
//                    {
//                        log = "SELECT PROFILE. (PROFILE STRING)";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }

//                    if (prsel[0] != "PRSEL: ")
//                    {
//                        log = "SELECT PROFILE. (PROFILE SETTING RESPONSE ERROR)";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }

//                    string[] sel = prsel[1].Split(':');
//                    if (currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString() != sel[0])
//                    {
//                        log = "SELECT PROFILE. (PROFILE SETTING ERROR)";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }

//                    //4. get waveform mode
//                    //ShowLog("MARKING - CONFIG WAVEFORM MODE");
//                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
//                    if (retval.execResult != 0)
//                    {
//                        log = "CONFIG WAVEFORM MODE. (" + retval.execResult.ToString() + ")";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }

//                    string[] pcfg = retval.recvString.Split('[', ']');
//                    if (pcfg.Length < 2)
//                    {
//                        log = "CONFIG WAVEFORM MODE. (PROFILE STRING)";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }
//#else
//                //if ((bool)EmissionAuto.IsChecked)
//                //{
//                //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
//                //    EmissionLamp.Fill = Brushes.Red;

//                //    Mode_File.CheckPowerFlag = true;
//                //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent("30");
//                //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth("0.5");

//                //    var Jobtask1 = Task.Run(() => mark.TestSolFet("O", 5, true));   //  Firmware Version 3.01 :  5 -> one shot
//                //    await Jobtask1;
//                //    await Task.Delay(50);
//                //    var chkStr = (Mode_File.CheckPowerValue / 30.0).ToString("F4");
//                //    if (Mode_File.CheckPowerValue > 32 && Mode_File.CheckPowerValue < 28)
//                //    {
//                //        Debug.WriteLine("Power Error! EndPower/SupplyPower Ratio : " + chkStr); // Error
//                //        MessageBox.Show("L A S E R   P O W E R  E R R O R  : Push OK Tab to continue.....");
//                //    }
//                //    ControlWindow.txt_log.AppendText("EndPower/SupplyPower Ratio : " + chkStr + Environment.NewLine);
//                //}

//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
//                if (retval.execResult != 0)
//                {
//                    log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
//                    //ShowLog(log);
//                    retval.sErrorMessage = log;
//                    retval.sErrorCode = "";
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }

//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.markPower);
//                if (retval.execResult != 0)
//                {
//                    log = "MARKING ERROR - SELECT MARK POWER. (" + retval.execResult.ToString() + ")";
//                    //ShowLog(log);
//                    retval.sErrorMessage = log;
//                    retval.sErrorCode = "";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

//                    return;
//                }

//                //ShowLabelData(currMarkInfo.currMarkData.pattern.laserValue.markPower, lblLaserPower);

//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.markWidth);
//                if (retval.execResult != 0)
//                {
//                    log = "MARKING ERROR - SELECT MARK WIDTH. (" + retval.execResult.ToString() + ")";
//                    //ShowLog(log);
//                    retval.sErrorMessage = log;
//                    retval.sErrorCode = "";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

//                    return;
//                }
//#endif
//                //5. Clear Dispaly
//                //ClearMarkVINDisplay();

//                //6. Start Text
//                retval = await Start_TEXT2(cmd, currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern);
//                if (retval.execResult != 0)
//                {
//                    log = "Start_TEXT3. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                //posValue = (PositionValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
//                //headValue = (headValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
//                ReadPatternPositionValue(ref posValue);
//                ReadPatternHeadValue(ref headValue);

//                //5. Set Font Data Buffer Flush
//                //ShowLog("MARKING - FLUSH START");
//                m_currCMD = (byte)'B';
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.FontFlush();
//                if (retval.execResult != 0)
//                {
//                    log = "FONT FLUSH. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }
//                //ShowLog("MARKING - FONT FLUSH SUCCESS");

//                //if(pattern.laserValue.density == 1)
//                {
//                    //ShowLog("MARKING - SET PHASE COMPENSATION");
//                    Single pc = Convert.ToSingle(txtPhaseComp.Text);
//                    //pc = pattern.laserValue.phaseComp;
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CALL PHASECOMP", Thread.CurrentThread.ManagedThreadId);
//                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(currMarkInfo.currMarkData.pattern.laserValue.phaseComp);
//                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(pc);
//                    if (retval.execResult != 0)
//                    {
//                        log = "SET PHASE COMPENSATION. (RESULT = " + retval.execResult.ToString() + ")";
//                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                        return;
//                    }
//                }

//                //currMarkInfo.senddata.SendDataIndex = 0;
//                //markdata.EndOfSend = false;
//                currMarkInfo.senddata.CleanFireFlag = false;    // Fire sending
//                                                                //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataFire.Count;
//                string StPoint = currMarkInfo.senddata.sendDataFire.ElementAt(0);

//                short posX = 0;
//                short posY = 0;
//                short posZ = 0;
//                m_currCMD = (byte)'K';
//                value = StPoint.Substring(4, 4);
//                short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posX);

//                value = StPoint.Substring(8, 4);
//                short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posY);

//                value = StPoint.Substring(12, 4);
//                short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posZ);
//                posZ += 500;

//                //7. Go to parking point (Check Point)
//                //ShowLog("MARKING - LOAD SPEED");

//                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
//                if (retval.execResult != 0)
//                {
//                    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                //StPoint.Substring(4, 4 + 4);
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
//                if (retval.execResult != 0)
//                {
//                    log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }


//                //mark.Density("N", Density.ToString("X4"));
//                //ShowLog("MARKING - SET DENSITY");
//                m_currCMD = (byte)'N';
//                //Density232 = (short)currMarkInfo.currMarkData.pattern.laserValue.density;
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)currMarkInfo.currMarkData.pattern.laserValue.density);
//                if (retval.execResult != 0)
//                {
//                    log = "SET DENSITY. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.MarkMoving);
//                if (retval.execResult != 0)
//                {
//                    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                // Run Marking
//                //Stopwatch sw = Stopwatch.StartNew();

//                Thread.Sleep(200);

//                swLaser.Start();

//                if ((bool)EmissionAuto.IsChecked)
//                {
//                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
//                    ShowRectangle(EmissionLamp, Brushes.Red);
//                    //EmissionLamp.Fill = Brushes.Red;
//                }

//                //Marking Start
//                //ShowLog("MARKING - START MARKING");

//                m_currCMD = (byte)'d';
//                short dwelltime = 0;
//                if (rbtMarkingPos1.IsChecked == true)
//                    short.TryParse(txtMarkDelayTime1.Text, out dwelltime);
//                else
//                    short.TryParse(txtMarkDelayTime2.Text, out dwelltime);

//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(dwelltime);
//                if (retval.execResult != 0)
//                {
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("dwellTimeSet ERROR = {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }

//                m_currCMD = (byte)'@';
//                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, false);
//                if (retval.execResult != 0)
//                {
//                    log = "MARKING ERROR. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                bReadFontValue = false;
//                currMarkInfo.checkdata.bReady = false;
//                currMarkInfo.senddata.bReady = false;
//                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
//                if (retval.execResult != 0)
//                {
//                    log = "ReadDeviceStatus. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }
//                else
//                {
//                    swClean.Start();
//                    st = retval.recvString.Split(':');
//                    Status = (LASERSTATUS)UInt32.Parse(st[1]);

//                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
//                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
//                    {
//                        //ShowLog("MARKING - START CLEANING");

//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
//                        if (retval.execResult != 0)
//                        {
//                            log = "StopEmission. (RESULT = " + retval.execResult.ToString() + ")";
//                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                            return;
//                        }
//                        ShowRectangle(EmissionLamp, Brushes.Black);

//#if LASER_YLR
//                            //Util.GetPrivateProfileValue("VINDATA", "PROFILECLEAN", "0", ref value, "Parameter.ini");                 // load waveform profile number
//                            value = currMarkInfo.currMarkData.pattern.laserValue.waveformClean.ToString();
//                            ShowTextBoxData(txtCurrProfile, value);
//                            //txtCurrProfile.Text = value;
//                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value);
//                            prsel = retval.recvString.Split('[', ']');
//                            if (prsel[0] != "PRSEL: ")
//                            {
//                                log = "Profile setting Error2!. (PRSEL[0] = " + prsel[0] + ")";
//                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                                return;
//                            }
//                            sel = prsel[1].Split(':');
//                            if (value != sel[0])
//                            {
//                                log = "Profile setting Error!. (SEL[0] = " + sel[0] + ")";
//                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                                return;
//                            }
//#else
//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
//                        if (retval.execResult != 0)
//                        {
//                            log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
//                            //ShowLog(log);
//                            retval.sErrorMessage = log;
//                            retval.sErrorCode = "";
//                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                            return;
//                        }

//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
//                        if (retval.execResult != 0)
//                        {
//                            log = "MARKING ERROR - SELECT CLEAN POWER. (" + retval.execResult.ToString() + ")";
//                            //ShowLog(log);
//                            retval.sErrorMessage = log;
//                            retval.sErrorCode = "";
//                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

//                            return;
//                        }

//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
//                        if (retval.execResult != 0)
//                        {
//                            log = "MARKING ERROR - SELECT CLEAN WIDTH. (" + retval.execResult.ToString() + ")";
//                            //ShowLog(log);
//                            retval.sErrorMessage = log;
//                            retval.sErrorCode = "";
//                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

//                            return;
//                        }
//#endif

//                        m_currCMD = (byte)'L';
//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
//                        if (retval.execResult != 0)
//                        {
//                            log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
//                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

//                            //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
//                            //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
//                            //ITNTErrorCode();

//                            return;
//                        }

//                        if ((bool)EmissionAuto.IsChecked)
//                        {
//                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
//                            ShowRectangle(EmissionLamp, Brushes.Red);
//                            //EmissionLamp.Fill = Brushes.Red;
//                        }

//                        //currMarkInfo.senddata.SendDataIndex = 0;
//                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
//                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

//                        //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
//                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);

//                        //m_currCMD = (byte)'@';
//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true);
//                        if (retval.execResult != 0)
//                        {
//                            log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
//                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                            return;
//                        }

//                        swClean.Stop();
//                        log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
//                        swClean.Reset();
//                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
//                    }

//                    if ((Status & LASERSTATUS.EmissionOnOff) != 0)
//                    {
//                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
//                        ShowRectangle(EmissionLamp, Brushes.Black);
//                        //EmissionLamp.Fill = Brushes.Black;
//                    }
//                }

//                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
//                if (retval.execResult != 0)
//                {
//                    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                short stepLeng = currMarkInfo.currMarkData.pattern.headValue.stepLength;
//                if (stepLeng <= 0)
//                    stepLeng = 100;

//                posX = (short)(headValue.park3DPos.X * stepLeng); if (posX <= 0) posX = (short)(70 * stepLeng);
//                posY = (short)(headValue.park3DPos.Y * stepLeng); if (posY <= 0) posY = (short)(20 * stepLeng);
//                posZ = (short)(headValue.park3DPos.Z * stepLeng); if (posZ <= 0) posZ = (short)(110 * stepLeng);
//                m_currCMD = (byte)'K';
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
//                if (retval.execResult != 0)
//                {
//                    log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
//                    return;
//                }

//                //Debug.WriteLine("Running Time : " + sw.Elapsed);
//                //sw.Stop();
//                //log = "TOTAL MARKING TIME : " + sw.ElapsedMilliseconds.ToString();
//                //ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);

//                swMark.Stop();
//                swLaser.Stop();
//                log = "MARKING TIME : " + swMark.ElapsedMilliseconds.ToString();
//                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
//                log = "LASER TIME : " + swLaser.ElapsedMilliseconds.ToString();
//                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
//                swMark.Reset();
//                swLaser.Reset();

//                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");









//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
//                if(retval.execResult != 0)
//                {
//                    log = "MARK CORNER FAIL - ReadDeviceStatus ERROR : " + retval.execResult.ToString();
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ReadDeviceStatus ERROR - " + retval.execResult.ToString());
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }
//                string[] st = retval.recvString.Split(':'); LASERSTATUS Status = (LASERSTATUS)UInt32.Parse(st[1]);
//                if ((Status & LASERSTATUS.EmissionOnOff) != 0)
//                {
//                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
//                    EmissionLamp.Fill = Brushes.Black;
//                }

//                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
//                byte.TryParse(value, out bHeadType);

//                ReadPatternValue(ref pattern);

//                if (cbxPatternList.SelectedIndex < 0)
//                    patternName = "Pattern_DEFAULT";
//                else
//                    patternName = cbxPatternList.Text;

//                retval.execResult = ReadFontData(cmd, patternName);
//                if (retval.execResult != 0)
//                {
//                    return;
//                }
//                await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
//                GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.vin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);

//#if LASER_YLR
//                //string value = "";
//                //Util.GetPrivateProfileValue("PROFILE", "PROFILEAREA", "90", ref value, ITNTconstants.PARAMS_INI_FILE);                 // load waveform profile number
//                //ProfileTxt.Text = value;

//                //retval = await laserSource.SelectProfile(value); string[] prsel = retval.recvString.Split('[', ']');
//                //if (prsel[0] == "PRSEL: ")
//                //{
//                //    string[] sel = prsel[1].Split(':');
//                //    if (value != sel[0])
//                //        Debug.WriteLine("Profile setting Error!");      // Error
//                //}
//                //else
//                //{
//                //    Debug.WriteLine("Profile setting response Error!"); // Error
//                //}

//                //retval = await laserSource.ConfigWaveformMode(); string[] pcfg = retval.recvString.Split('[', ']');
//#else
//                //

//                //Util.GetPrivateProfileValue("PROFILE", "AREA_POWER", "10", ref value, ITNTconstants.PARAMS_INI_FILE);
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(pattern.laserValue.spotPower);
//                if (retval.execResult != 0)
//                {
//                    log = "MARK CORNER FAIL - SetDiodeCurrent ERROR : " + retval.execResult.ToString();
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SetDiodeCurrent ERROR - " + retval.execResult.ToString());
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }
//                //pw = value; pw += "% / ";

//                //value = "";
//                //Util.GetPrivateProfileValue("PROFILE", "AREA_WIDTH", "0.5", ref value, ITNTconstants.PARAMS_INI_FILE);
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(pattern.laserValue.spotWidth);
//                if (retval.execResult != 0)
//                {
//                    log = "MARK CORNER FAIL - SetPulseWidth ERROR : " + retval.execResult.ToString();
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SetPulseWidth ERROR - " + retval.execResult.ToString());
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }
//                //pw += value; pw += "ms";

//                //ProfileTxt.Text = pw;
//                log = "POWER = " + pattern.laserValue.spotPower + "%, WIDTH = " + pattern.laserValue.spotWidth + "ms";
//                //if (retval.execResult != 0)
//                //{
//                //    log = "MARK CORNER FAIL - ReadDeviceStatus ERROR : " + retval.execResult.ToString();
//                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "ReadDeviceStatus ERROR - " + retval.execResult.ToString());
//                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                //    return;
//                //}
//                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
//#endif  

//                //Set Font Data Buffer Flush
//                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.FontFlush();
//                if (retval.execResult != 0)
//                {
//                    log = "MARK CORNER FAIL - FontFlush ERROR : " + retval.execResult.ToString();
//                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "FontFlush ERROR - " + retval.execResult.ToString());
//                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
//                    return;
//                }
            }
            catch(Exception ex)
            {

            }
        }


        public async Task<CheckAreaData> Range_data(string cmd, string vin, PatternValueEx Pattern)    // Making Area Corner data by TM SHIN
        {
            CheckAreaData retval = new CheckAreaData();
            Vector3D startPoint = new Vector3D();
            Vector3D centerPoint = new Vector3D();
            //Vector3D PointLU = new Vector3D();
            //Vector3D PointLD = new Vector3D();
            //Vector3D PointRU = new Vector3D();
            //Vector3D PointRD = new Vector3D();
            //Vector3D PointCT = new Vector3D();
            //Vector3D PointCD = new Vector3D();

            //Vector3D vectorNormal = new Vector3D();
            //Vector3D vectorLURD = new Vector3D();
            //Vector3D vectorRURD = new Vector3D();
            //Vector3D vectorRot = new Vector3D();
            Vector3D[] cornerPoint = new Vector3D[4];
            PatternValueEx pattern = new PatternValueEx();
            //string value = "";
            //string cmd = "MARKING CORNER";
            //int vinLength = 0;
            ITNTResponseArgs recvArg = new ITNTResponseArgs();
            int vinLeng = 0;

            try
            {
                if (vin.Length <= 0)
                {
                    recvArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SolOnOffTime(pattern.speedValue.solOnTime, pattern.speedValue.solOffTime);
                    if(recvArg.execResult != 0)
                    {
                        retval.execResult = recvArg.execResult;
                        return retval;
                    }

                    recvArg = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(pattern.speedValue.dwellTime);// (pattern.speedValue.solOnTime, pattern.speedValue.solOffTime);
                    if (recvArg.execResult != 0)
                    {
                        retval.execResult = recvArg.execResult;
                        return retval;
                    }

                    vinLeng = vin.Length;

                    // ABS mm at Center Point
                    centerPoint = pattern.positionValue.center3DPos;
                    centerPoint.Z += pattern.headValue.distance0Position;
                    double areaZPos = 0;
                    areaZPos += centerPoint.Z;

                    startPoint.X = (pattern.fontValue.pitch * (vinLeng - 1) + pattern.fontValue.width) / 2.0;
                    startPoint.Y = pattern.fontValue.height / 2.0;

                    startPoint = centerPoint - startPoint;
                    startPoint.Z = 0;

                    retval = await Range_Test(cmd, vin, pattern, 1, 1);



                    //centerPoint.X = double.Parse(X_Position);
                    //centerPoint.Y = double.Parse(Y_Position);
                    //centerPoint.Z = double.Parse(Z_Position);
                    //centerPoint.Z += D0_PositionZ;                       // Absolute Nozzle position                     // && 8
                    //AZ += CP.Z;                                                                   // && 8

                    //// Relative half size mm
                    //SP.X = (Pt * (NoVin - 1) + Wd) / 2.0;
                    //SP.Y = Ht / 2.0;
                    //// Absolute mm at Start Point
                    //SP.X = CP.X - SP.X; SP.Y = CP.Y - SP.Y; SP.Z = 0.0;

                    //VectorNormal = Mode_File.NormalDir;
                    //// Get Normalized Rotation Vector by Cross product of VectorNormal with Z Axis (0, 0, 1)
                    //VectorRot.X = -VectorNormal.Y;
                    //VectorRot.Y = VectorNormal.X;
                    //VectorRot.Z = 0.0;
                    //double sqXY = Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y);
                    //VectorRot.X /= sqXY; VectorRot.Y /= sqXY;
                    //// Angle between VectorNormal to Z Axis ==> Rodrigues' Matrix
                    //bool skipRot = false;
                    //double cosValue = VectorNormal.Z / Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y + VectorNormal.Z * VectorNormal.Z);
                    //double sinValue = Math.Sqrt(1.0 - cosValue * cosValue);
                    //double R11, R12, R13, R21, R22, R23, R31, R32, R33;

                    //if (cosValue > 0.9999986111)
                    //{      // 0.1 mm difference between 60mm
                    //    skipRot = true;
                    //    R11 = R12 = R13 = R21 = R22 = R23 = R31 = R32 = R33 = 0.0;
                    //    R11 = R22 = R33 = 1.0;
                    //}
                    //else
                    //{
                    //    R11 = cosValue + VectorRot.X * VectorRot.X * (1.0 - cosValue);
                    //    R12 = VectorRot.X * VectorRot.Y * (1.0 - cosValue) - VectorRot.Z * sinValue;
                    //    R13 = VectorRot.X * VectorRot.Z * (1.0 - cosValue) + VectorRot.Y * sinValue;
                    //    R21 = VectorRot.Y * VectorRot.X * (1.0 - cosValue) + VectorRot.Z * sinValue;
                    //    R22 = cosValue + VectorRot.Y * VectorRot.Y * (1.0 - cosValue);
                    //    R23 = VectorRot.Y * VectorRot.Z * (1.0 - cosValue) - VectorRot.X * sinValue;
                    //    R31 = VectorRot.Z * VectorRot.X * (1.0 - cosValue) - VectorRot.Y * sinValue;
                    //    R32 = VectorRot.Z * VectorRot.Y * (1.0 - cosValue) + VectorRot.X * sinValue;
                    //    R33 = cosValue + VectorRot.Z * VectorRot.Z * (1.0 - cosValue);
                    //}
                    ///////
                    //MPOINT M1 = new MPOINT();                                   // for fire data mm
                    //MPOINT M = new MPOINT();                                    // for fire data mm

                    //Mode_File.SendArea.Clear();

                    //Corner_Point[0].X = Mode_File.dMinX; Corner_Point[0].Y = Mode_File.dMaxY; Corner_Point[0].Z = 0.0;  // LU
                    //Corner_Point[1].X = Mode_File.dMinX; Corner_Point[1].Y = Mode_File.dMinY; Corner_Point[1].Z = 0.0;  // LD
                    //Corner_Point[2].X = Mode_File.dMaxX; Corner_Point[2].Y = Mode_File.dMinY; Corner_Point[2].Z = 0.0;  // RD
                    //Corner_Point[3].X = Mode_File.dMaxX; Corner_Point[3].Y = Mode_File.dMaxY; Corner_Point[3].Z = 0.0;  // RU


                }
            }
            catch (Exception ex)
            {
                retval.execResult = ex.HResult;
            }

            return retval;
            //COMMAND_RESULT retval = new COMMAND_RESULT();

            //MPOINT SP = new MPOINT();
            //MPOINT CP = new MPOINT();
            //MPOINT PointLU = new MPOINT();
            //MPOINT PointLD = new MPOINT();
            //MPOINT PointRU = new MPOINT();
            //MPOINT PointRD = new MPOINT();
            //MPOINT PointCT = new MPOINT();
            //MPOINT PointCD = new MPOINT();
            //MPOINT VectorNormal = new MPOINT();
            //MPOINT VectorLuRd = new MPOINT();
            //MPOINT VectorRuRd = new MPOINT();
            //MPOINT VectorRot = new MPOINT();

            //MPOINT[] Corner_Point = new MPOINT[4];

            //string X_Position = "";
            //Util.GetPrivateProfileValue("VINDATA", "X", "0.0", ref X_Position, Pattern);

            //string Y_Position = "";
            //Util.GetPrivateProfileValue("VINDATA", "Y", "0.0", ref Y_Position, Pattern);

            //string Z_Position = "";
            //Util.GetPrivateProfileValue("VINDATA", "Z", "0.0", ref Z_Position, Pattern);

            //string Height = "";
            //Util.GetPrivateProfileValue("VINDATA", "HEIGHT", "0.0", ref Height, Pattern);
            //double Ht = double.Parse(Height);

            //string Width = "";
            //Util.GetPrivateProfileValue("VINDATA", "WIDTH", "0.0", ref Width, Pattern);
            //double Wd = double.Parse(Width);

            //string Pitch = "";
            //Util.GetPrivateProfileValue("VINDATA", "PITCH", "0.0", ref Pitch, Pattern);
            //double Pt = double.Parse(Pitch);

            //string Angle = "";
            //Util.GetPrivateProfileValue("VINDATA", "ANGLE", "0.0", ref Angle, Pattern);
            //double Ag = double.Parse(Angle);

            //string AreaPosition = "";
            //Util.GetPrivateProfileValue("PLATE", "AREAPOSITION", "50", ref AreaPosition, Pattern);
            //double AZ = double.Parse(AreaPosition);

            //short Sol_On = (short)Util.GetPrivateProfileValueInt("SOL", "SOL_ON", 0, Pattern);
            //short Sol_Off = (short)Util.GetPrivateProfileValueInt("SOL", "SOL_OFF", 0, Pattern);
            //short Dwell_Time = (short)Util.GetPrivateProfileValueInt("SOL", "DWELL", 0, Pattern);
            //short Density = (short)Util.GetPrivateProfileValueInt("VINDATA", "DENSITY", 10, Pattern);

            //var SetSol_OnOff = String.Concat(Sol_On.ToString("X4"), Sol_Off.ToString("X4"));
            //SolOnOffTime("S", SetSol_OnOff);            // send Sol OnOff time

            //var SetDwell_Time = String.Concat(Dwell_Time.ToString("X4"));
            //DwellTime("d", SetDwell_Time);              // send Dwell time 

            //int NoVin = DATA_.Length;

            //// ABS mm at Center Point
            //CP.X = double.Parse(X_Position);
            //CP.Y = double.Parse(Y_Position);
            ////CP.Z = double.Parse(Z_Position);
            //CP.Z = Mode_File.D_0_Gap_Z;                 // Absolute Nozzle position                     // && 8
            //AZ += Mode_File.D_0_Gap_Z;                                                                   // && 8
            //if (AZ < CP.Z) AZ = CP.Z;                   // Corner Z Position >= Marking Center Z Position

            //// Relative half size mm
            //SP.X = (Pt * (NoVin - 1) + Wd) / 2.0;
            //SP.Y = Ht / 2.0;
            //// Absolute mm at Start Point
            //SP.X = CP.X - SP.X; SP.Y = CP.Y - SP.Y; SP.Z = 0.0;

            //VectorNormal = Mode_File.NormalDir;
            //// Get Normalized Rotation Vector by Cross product of VectorNormal with Z Axis (0, 0, 1)
            //VectorRot.X = -VectorNormal.Y;
            //VectorRot.Y = VectorNormal.X;
            //VectorRot.Z = 0.0;
            //double sqXY = Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y);
            //VectorRot.X /= sqXY; VectorRot.Y /= sqXY;
            //// Angle between VectorNormal to Z Axis ==> Rodrigues' Matrix
            //bool skipRot = false;
            //double cosValue = VectorNormal.Z / Math.Sqrt(VectorNormal.X * VectorNormal.X + VectorNormal.Y * VectorNormal.Y + VectorNormal.Z * VectorNormal.Z);
            //double sinValue = Math.Sqrt(1.0 - cosValue * cosValue);
            //double R11, R12, R13, R21, R22, R23, R31, R32, R33;

            //if (cosValue > 0.9999986111)
            //{      // 0.1 mm difference between 60mm
            //    skipRot = true;
            //    R11 = R12 = R13 = R21 = R22 = R23 = R31 = R32 = R33 = 0.0;
            //    R11 = R22 = R33 = 1.0;
            //}
            //else
            //{
            //    R11 = cosValue + VectorRot.X * VectorRot.X * (1.0 - cosValue);
            //    R12 = VectorRot.X * VectorRot.Y * (1.0 - cosValue) - VectorRot.Z * sinValue;
            //    R13 = VectorRot.X * VectorRot.Z * (1.0 - cosValue) + VectorRot.Y * sinValue;
            //    R21 = VectorRot.Y * VectorRot.X * (1.0 - cosValue) + VectorRot.Z * sinValue;
            //    R22 = cosValue + VectorRot.Y * VectorRot.Y * (1.0 - cosValue);
            //    R23 = VectorRot.Y * VectorRot.Z * (1.0 - cosValue) - VectorRot.X * sinValue;
            //    R31 = VectorRot.Z * VectorRot.X * (1.0 - cosValue) - VectorRot.Y * sinValue;
            //    R32 = VectorRot.Z * VectorRot.Y * (1.0 - cosValue) + VectorRot.X * sinValue;
            //    R33 = cosValue + VectorRot.Z * VectorRot.Z * (1.0 - cosValue);
            //}
            ///////
            //MPOINT M1 = new MPOINT();                                   // for fire data mm
            //MPOINT M = new MPOINT();                                    // for fire data mm

            //Mode_File.SendArea.Clear();

            //Corner_Point[0].X = Mode_File.dMinX; Corner_Point[0].Y = Mode_File.dMaxY; Corner_Point[0].Z = 0.0;  // LU
            //Corner_Point[1].X = Mode_File.dMinX; Corner_Point[1].Y = Mode_File.dMinY; Corner_Point[1].Z = 0.0;  // LD
            //Corner_Point[2].X = Mode_File.dMaxX; Corner_Point[2].Y = Mode_File.dMinY; Corner_Point[2].Z = 0.0;  // RD
            //Corner_Point[3].X = Mode_File.dMaxX; Corner_Point[3].Y = Mode_File.dMaxY; Corner_Point[3].Z = 0.0;  // RU

            //for (int i = 0; i < 4; i++)
            //{
            //    // ABS mm
            //    M1.X = Corner_Point[i].X;
            //    // Font offset compensation
            //    M1.Y = Corner_Point[i].Y;
            //    M1.Z = SP.Z;

            //    // TM SHIN
            //    M1.X -= CP.X; M1.Y -= CP.Y;

            //    M = (skipRot == true) ? M1 : getRodrigueRotation(M1);

            //    M.X += CP.X; M.Y += CP.Y;
            //    double Mt = M.Z;
            //    M.Z = Mt + AZ + Mode_File.PlaneCenterZ;

            //    Debug.WriteLine(String.Format("{0:D3} =>{1,7:F3},{2,7:F3},{3,7:F3}", i, M.X, M.Y, M.Z));

            //    // Change to BLU(Unit 0.01mm)
            //    M.X *= (double)Mode_File.Step_Length; M.Y *= (double)Mode_File.Step_Length; M.Z *= (double)Mode_File.Step_Length;

            //    M_FONT FontData = new M_FONT();

            //    switch (i)
            //    {
            //        case 0: FontData.cN = (byte)0; FontData.fN = (byte)0; break;
            //        case 1: FontData.cN = (byte)0; FontData.fN = (byte)1; break;
            //        case 2:
            //            FontData.cN = (DATA_.Length == 17) ? (byte)16 : (byte)18; FontData.fN = (byte)0; break;
            //        case 3:
            //            FontData.cN = (DATA_.Length == 17) ? (byte)16 : (byte)18; FontData.fN = (byte)1; break;
            //    }
            //    FontData.mX = (UInt16)(M.X + 0.5); FontData.mY = (UInt16)(M.Y + 0.5); FontData.mZ = (UInt16)(M.Z + 0.5); FontData.mF = (byte)0;
            //    FontData.mC = 0;

            //    var m_font = FontData.cN.ToString("X2") + FontData.fN.ToString("X2") + FontData.mX.ToString("X4") + FontData.mY.ToString("X4") + FontData.mZ.ToString("X4") + FontData.mF.ToString("X4");
            //    Mode_File.SendArea.Add(m_font);
            //}


            ////Mark_Counter++;

            //Mode_File.Download_Data = true;

            //return;

            //MPOINT getRodrigueRotation(MPOINT XY0)
            //{
            //    MPOINT Tmp = new MPOINT();
            //    Tmp.X = XY0.X * R11 + XY0.Y * R12 + XY0.Z * R13;
            //    Tmp.Y = XY0.X * R21 + XY0.Y * R22 + XY0.Z * R23;
            //    Tmp.Z = XY0.X * R31 + XY0.Y * R32 + XY0.Z * R33;

            //    return Tmp;
            //}

        }

        private async void btnMarkPoint_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnMarkPoint_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string log = "";
            Stopwatch sw = new Stopwatch();
            //int repeatCount = 0;
            CheckAreaData chkdata = new CheckAreaData();
            string patName = "";
            string cmd = "GO TO MARK POINT";
            PatternValueEx pattern = new PatternValueEx();

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                if (cbxPatternList.SelectedIndex >= 0)
                    patName = cbxPatternList.SelectedItem.ToString();
                else
                {
                    log = "SELECT PATTERN";
                    retval.errorInfo.sErrorMessage = log;
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    return;
                }

                ReadPatternValue(ref pattern);
                if (txtVIN.Text.Length <= 0)
                    txtVIN.Text = "*ABCDEFGHKLMOPQRST*";
                //currMarkInfo.currMarkData.mesData.vin = txtVIN.Text;

                //chkdata = await Range_Test("GO MARKING POINT", txtVIN.Text, pattern, 0, 0);
                chkdata = await Range_Test("GO MARKING POINT", txtVIN.Text, pattern, 0, 0);
                if (chkdata.execResult != 0)
                {
                    log = "RANGE TEST ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    retval.execResult = chkdata.execResult;
                    retval.errorInfo.sErrorMessage = chkdata.errorInfo.sErrorMessage;
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    log = "MOTOR SPEED SETTING ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint((short)chkdata.centerPointBLU.X, (short)chkdata.centerPointBLU.Y, (short)chkdata.centerPointBLU.Z, 0);
                if (retval.execResult != 0)
                {
                    log = "GO POINT ERROR : (RESULT = " + chkdata.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                btnSaveTeachingZPos.IsEnabled = true;
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CHECK PLATE - SUCCESS", Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        //public int GetMarkPosition()
        //{
        //    double D0_PositionZ = 0;
        //    Vector3D CP = new Vector3D();
        //    string X_Position = "";
        //    string Y_Position = "";
        //    string Z_Position = "";
        //    double tmpPos = 0.0;
        //    bool ErrorDistanceSensor = false;
        //    double CenterX, CenterY, CenterZ;
        //    double stepLeng = 0.0;

        //    try
        //    {
        //        if(txtCenter_X.Text.Length <= 0)
        //        {
        //            return -1;
        //        }
        //        if (txtCenter_Y.Text.Length <= 0)
        //        {
        //            return -2;
        //        }
        //        if (txtCenter_Z.Text.Length <= 0)
        //        {
        //            return -3;
        //        }

        //        // Absolute mm of Center Point
        //        double.TryParse(txtCenter_X.Text, out tmpPos);
        //        CP.X = tmpPos;

        //        double.TryParse(txtCenter_Y.Text, out tmpPos);
        //        CP.Y = tmpPos;

        //        double.TryParse(txtCenter_Z.Text, out tmpPos);
        //        CP.Z = tmpPos;

        //        double.TryParse(txtDistance0Pos.Text, out tmpPos);
        //        D0_PositionZ = tmpPos;

        //        ErrorDistanceSensor = false;

        //        double.TryParse(lblStepLength.Content.ToString(), out tmpPos);
        //        stepLeng = tmpPos;


        //        // ABS mm
        //        double CX = CP.X;
        //        double CY = CP.Y;

        //        // ABS BLU
        //        short tCX = (short)(CX * stepLeng + 0.5);
        //        short tCY = (short)(CY * stepLeng + 0.5);
        //        CenterX = tCX;
        //        CenterY = tCY;
        //        CenterZ = (short)((CP.Z + D0_PositionZ) * stepLeng + 0.5); // Relative Gap + D0GapPositionZ

        //        double Parking_Z = 0;
        //        double.TryParse(txtPark_Z.Text, out tmpPos);
        //        Parking_Z = tmpPos * stepLeng;



        //        var Range_CenterXY = tCX.ToString("X4") + tCY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");


        //        string _Position = ""; Util.GetPrivateProfileValue("PARKING", "PARKING_Z", "110.0", ref _Position, ITNTconstants.PARAMS_INI_FILE);
        //        var Parking_Z = (short)(double.Parse(_Position) * Mode_File.Step_Length + 0.5);       // LOAD PARKING Z
        //        var Range_CenterXY = tCX.ToString("X4") + tCY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
        //        GoPoint("M", Range_CenterXY);  // CT, 0 with None offset

        //        Mode_File.ShiftCT = 0.0;
        //        Mode_File.SensorShift = null; while (Mode_File.SensorShift == null) ;
        //        Mode_File.SensorShift = null; while (Mode_File.SensorShift == null) ;
        //        Mode_File.HeightCT = (double)Mode_File.SensorOffset;
        //        Mode_File.ShiftCT = (double)Mode_File.SensorShift;

        //        // Sensor Shift compensation
        //        if (Math.Abs(Mode_File.HeightCT) > 40.0)      // Z Diff +- 40mm    // && 7
        //        {
        //            // Error : Z Range over (Z axis unit +-40mm )
        //            ControlWindow.Dispatcher.Invoke(new Action(delegate
        //            {
        //                ControlWindow.txt_log.Text = "OUT OF RANGE Z (No center position)";
        //                ControlWindow.lblDispCenXCenY.Foreground = Brushes.Red;
        //                ControlWindow.lblDispCenXCenY.Content = Mode_File.HeightCT.ToString("0.000");
        //                ControlWindow.lblDispMinXMaxY.Content = "";
        //                ControlWindow.lblDispMinXMinY.Content = "";
        //                ControlWindow.lblDispMaxXMaxY.Content = "";
        //                ControlWindow.lblDispMaxXMinY.Content = "";
        //                ControlWindow.lblDispCenXMaxY.Content = "";
        //                ControlWindow.lblDispCenXMinY.Content = "";
        //            }
        //            ));
        //            Mode_File.CenterZ = (short)((CP.Z + D0_PositionZ) * Mode_File.Step_Length + 0.5);

        //            return 1;
        //        }
        //        else
        //        {
        //            tCX += (short)(Mode_File.ShiftCT * Mode_File.Step_Length + 0.5);

        //            Range_CenterXY = tCX.ToString("X4") + tCY.ToString("X4") + Parking_Z.ToString("X4") + 0.ToString("X4");
        //            GoPoint("M", Range_CenterXY); // CT, 7 point

        //            Mode_File.HeightCT = 0.0;
        //            Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
        //            Mode_File.SensorOffset = null; while (Mode_File.SensorOffset == null) ;
        //            Mode_File.HeightCT = (double)Mode_File.SensorOffset;
        //            Mode_File.SensorDistance0 = Mode_File.SensorDistance;
        //            Mode_File.ShiftCT0 = Mode_File.ShiftCT;

        //            Mode_File.PlaneCenterZ = Mode_File.HeightCT;
        //            Mode_File.CenterZ += (short)(Mode_File.HeightCT * Mode_File.Step_Length + 0.5);

        //            ControlWindow.Dispatcher.Invoke(new Action(delegate
        //            {
        //                ControlWindow.lblDispCenXCenY.Foreground = Brushes.Black;
        //                ControlWindow.lblDispCenXMinY.Content = Mode_File.SensorDistance0.ToString("0.000");
        //                ControlWindow.lblDispCenXCenY.Content = Mode_File.HeightCT.ToString("0.000");
        //                ControlWindow.lblDispCenXMaxY.Content = Mode_File.ShiftCT0.ToString("0.000");
        //                ControlWindow.lblDispMinXMaxY.Content = "";
        //                ControlWindow.lblDispMinXMinY.Content = "";
        //                ControlWindow.lblDispMaxXMaxY.Content = "";
        //                ControlWindow.lblDispMaxXMinY.Content = "";
        //            }
        //            ));
        //            return 0;
        //        }
        //    }
        //    catch (Exception ERR)
        //    {
        //        MessageBox.Show(ERR.ToString());
        //        return 2;
        //    }

        //}

        public async Task<CheckAreaData> GetMarkPosition(string cmd, PatternValueEx pattern, byte errHeightFlag, byte errClineFlag)
        {
            string className = "SetControllerWindow3";
            string funcName = "GetMarkPosition";

            distanceSensorData sensorData = new distanceSensorData();
            CheckAreaData areaData = new CheckAreaData();

            Vector3D CP = new Vector3D();
            Vector3D vectorCP = new Vector3D();

            short tCX = 0;
            short tCY = 0;

            double ShiftCT = 0;
            double HeightCT = 0;
            string fName = "";
            string log = "";

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, className, funcName, "[CHECK MARK POSITION]");

                if (cbxPatternList.SelectedIndex >= 0)
                    fName = cbxPatternList.SelectedItem.ToString();
                else
                {
                    log = "SELECT PATTERN";
                    areaData.errorInfo.sErrorMessage = log;
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    areaData.execResult = -1;
                    return areaData;
                }

                areaData.NormalDir.X = areaData.NormalDir.Y = 0.0;
                areaData.NormalDir.Z = 1.0;

                areaData.ErrorDistanceSensor = false;
                // Absolute mm of Center Point
                CP = pattern.positionValue.center3DPos;

                tCX = (short)(CP.X * pattern.headValue.stepLength + 0.5);
                tCY = (short)(CP.Y * pattern.headValue.stepLength + 0.5);

                areaData.centerPoint.X = CP.X;
                areaData.centerPoint.Y = CP.Y;
                areaData.centerPoint.Z = CP.Z + pattern.headValue.distance0Position;

                areaData.centerPointBLU.X = tCX;
                areaData.centerPointBLU.Y = tCY;
                areaData.centerPointBLU.Z = (short)((CP.Z + pattern.headValue.distance0Position) * pattern.headValue.stepLength + 0.5);

                vectorCP.X = tCX;
                vectorCP.Y = tCY;
                vectorCP.Z = (short)(pattern.headValue.park3DPos.Z * pattern.headValue.stepLength + 0.5);

                sensorData = await GetMeasureLength(vectorCP, 0, 1);
                if (sensorData.execResult != 0)
                {
                    areaData.execResult = sensorData.execResult;

                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR 0 - " + sensorData.execResult.ToString());
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CT) : ERROR = " + sensorData.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);

                    ////retval.execResult = snsdata.execResult;
                    //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CENTER) : ERROR = " + sensorData.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);

                    //log = "SELECT PATTERN";
                    //areaData.sErrorMessage = log;
                    //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);

                    return areaData;
                }

                //ShowLabelData(sensorData.rawdistance.ToString("F4"), lblDispHeightValue);
                //ShowLabelData(sensorData.sensoroffset.ToString("F4"), lblDispHeightCosine);

                areaData.NormalDir.X = areaData.NormalDir.Y = 0;
                areaData.NormalDir.Z = 1;


                ShiftCT = sensorData.sensorshift;
                HeightCT = sensorData.sensoroffset;

                if (Math.Abs(HeightCT) > pattern.positionValue.checkDistanceHeight)      // Z Diff Max. 60mm
                {
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + HeightCT.ToString("0.0000"), Thread.CurrentThread.ManagedThreadId);
                    areaData.ErrorDistanceSensor = true;

                    ShowLabelData(HeightCT.ToString("0.000"), lblDispCenXCenY, System.Windows.Media.Brushes.Red, null, null);
                    ShowLabelData("", lblDispMinXMaxY);
                    ShowLabelData("", lblDispMinXMinY);
                    ShowLabelData("", lblDispMaxXMaxY);
                    ShowLabelData("", lblDispMaxXMinY);
                    ShowLabelData("", lblDispCenXMaxY);
                    ShowLabelData("", lblDispCenXMinY);

                    //double CenterZ = (short)((CP.Z + pattern.headValue.distance0Position) * pattern.headValue.stepLength + 0.5);
                    areaData.centerPoint.Z = CP.Z + pattern.headValue.distance0Position;
                    areaData.centerPointBLU.Z = (short)((CP.Z + pattern.headValue.distance0Position) * pattern.headValue.stepLength + 0.5);

                    areaData.PlaneCenterZ = CP.Z + pattern.headValue.distance0Position;

                    areaData.errorInfo.sErrorMessage = "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + HeightCT.ToString("0.0000");

                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CENTER Z Range is OUT OF RANGE : " + HeightCT.ToString("F3"));
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CENTER Z Range over (Z axis unit 0 ~ 60mm) : " + HeightCT.ToString("0.0000"), Thread.CurrentThread.ManagedThreadId);
                    if (errHeightFlag == 0)
                    {
                        areaData.execResult = -2;
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CENTER Z Range is OUT OF RANGE : " + HeightCT.ToString("F3") + " RETURN");
                        return areaData;
                    }
                }
                else
                {
                    tCX += (short)(ShiftCT * pattern.headValue.stepLength + 0.5);
                    vectorCP.X = tCX;

                    sensorData = await GetMeasureLength(vectorCP, 0, 1);
                    if (sensorData.execResult != 0)
                    {
                        areaData.execResult = sensorData.execResult;

                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET MEASURE ERROR 1 - " + sensorData.execResult.ToString());
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CT) : ERROR = " + sensorData.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);

                        ////retval.execResult = snsdata.execResult;
                        //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "GetMeasureLength(CENTER) : ERROR = " + sensorData.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);
                        //areaData.execResult = sensorData.execResult;

                        //ITNTErrorCode();
                        //ShowLog(className, funcName, 2, "[PLATE CHECK] ERROR - GetMeasureLength = " + sensorData.execResult.ToString(), "");
                        return areaData;
                    }

                    ShiftCT = sensorData.sensorshift;
                    HeightCT = sensorData.sensoroffset;

                    areaData.centerPoint.Z += HeightCT;// CP.Z + pattern.headValue.distance0Position;
                    areaData.centerPointBLU.Z += (short)(HeightCT * pattern.headValue.stepLength + 0.5);

                    areaData.PlaneCenterZ = HeightCT;

                    ShowLabelData(HeightCT.ToString("0.000;-0.000;0.000"), lblDispCenXCenY, Brushes.Black);
                    ShowLabelData(ShiftCT.ToString("+ 0.000;- 0.000;0.000"), lblDispCenXMaxY);//, (PdiffCU > 0 || chkdata.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue);
                    ShowLabelData(sensorData.rawdistance.ToString("+ 0.000;- 0.000;0.000"), lblDispCenXMinY);//, (PdiffCD > 0 || chkdata.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue);
                    ShowLabelData("", lblDispMinXMaxY);
                    ShowLabelData("", lblDispMinXMinY);
                    ShowLabelData("", lblDispMaxXMaxY);
                    ShowLabelData("", lblDispMaxXMinY);

                    //ShowLabelData(PdiffLU.ToString("+ 0.000;- 0.000;0.000"), lblDispMinXMaxY, (PdiffLU > 0 || chkdata.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue);
                    //ShowLabelData(PdiffLD.ToString("+ 0.000;- 0.000;0.000"), lblDispMinXMinY, (PdiffLD > 0 || chkdata.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue);
                    //ShowLabelData(PdiffRU.ToString("+ 0.000;- 0.000;0.000"), lblDispMaxXMaxY, (PdiffRU > 0 || chkdata.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue);
                    //ShowLabelData(PdiffRD.ToString("+ 0.000;- 0.000;0.000"), lblDispMaxXMinY, (PdiffRD > 0 || chkdata.ErrorDistanceSensor) ? Brushes.Red : Brushes.LightSkyBlue);
                    //ShowLabelData(HeightCT.ToString("0.000"), lblDispCenXCenY, System.Windows.Media.Brushes.Black, null, null);
                    //ShowLabelData("", lblDispCenXMaxY);
                    //ShowLabelData("", lblDispCenXMinY);
                }
                return areaData;
            }
            catch (Exception ex)
            {
                areaData.execResult = ex.HResult;
                log = "EXCEPTION. ERROR = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                areaData.errorInfo.sErrorMessage = log;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);

                ////MessageBox.Show(ERR.ToString());
                //areaData.execResult = ex.HResult;

                return areaData;
            }
        }

        private async void btnFirmware_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnFirmware_Click";

            string ver = "";
            string log = "";
            string cmd = "FIRMWARE VERSION";

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                //Brush brus = btnFirmware.Background;

                ver = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GetFWVersion();
                if (ver.Length > 0)
                {
                    //if (ver.CompareTo("101") >= 0)
                    //    ((MainWindow)System.Windows.Application.Current.MainWindow).fwVersionFlag = 1;
                    //else
                    //    ((MainWindow)System.Windows.Application.Current.MainWindow).fwVersionFlag = 0;
                    //lblfwVersion.Content = ver;
                    //((MainWindow)System.Windows.Application.Current.MainWindow).fwVersion = ver;

                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "FIRMWARE VERSION = " + ver, "");
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "Read Failure");
                    //((MainWindow)System.Windows.Application.Current.MainWindow).fwVersionFlag = 0;
                }
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void btnSaveLaserValue_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnSaveHeaderValue_Click";

            HeadValue headvalue = new HeadValue();
            byte byHeadType = 0;
            string value = "";
            string cmd = "FIRMWARE VERSION";
            string log = "";
            int retval = 0;

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out byHeadType);
                retval = ImageProcessManager.SetPatternHeadValue(byHeadType, headvalue, 1);
                if (retval != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "Save Failure");
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                }
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void btnSaveHeaderValue_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnSaveHeaderValue_Click";

            HeadValue headvalue = new HeadValue();
            byte byHeadType = 0;
            string value = "";
            string cmd = "FIRMWARE VERSION";
            string log = "";
            int retval = 0;

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                Util.GetPrivateProfileValue("MARK", "HEADTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                byte.TryParse(value, out byHeadType);

                ReadPatternHeadValue(ref headvalue);

                retval = ImageProcessManager.SetPatternHeadValue(byHeadType, headvalue, 1);
                if (retval != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "Save Failure");
                }
                else
                {
                    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                }
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnLenzCalibration_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnLenzCalibration_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string value = "";
            const int calibCount = 20;      // Number of samples
            double slope = 0;
            double intercept = 0;
            string log = "";
            string cmd = "CALIBRATION";

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd);
#if LASER_YLR
                //Util.GetPrivateProfileValue("PROFILE", "PROFILEFIRE", "0", ref value, Constants.PARAMS_INI_FILE);
                //ProfileTxt.Text = value;

                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value); string[] prsel = retval.recvString.Split('[', ']');
                //if (prsel[0] == "PRSEL: ")
                //{
                //    string[] sel = prsel[1].Split(':');
                //    if (value != sel[0])
                //        Debug.WriteLine("Profile setting Error!");      // Error
                //}
                //else
                //{
                //    Debug.WriteLine("Profile setting response Error!"); // Error
                //}

                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(); string[] pcfg = retval.recvString.Split('[', ']');
#else
                //
                if (!(bool)EmissionAuto.IsChecked)
                {
                    //ControlWindow.txt_log.AppendText("ERROR of Emission Disabled!!");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, "CALIBRATION", "LASER ERROR", "ERROR of Emission Disabled!!");
                    return;
                }

                Util.GetPrivateProfileValue("PROFILE", "LASER_RATE", "1", ref value, Constants.PARAMS_INI_FILE);
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate(value);
                if (retval.execResult != 0)
                {
                    log = "CALIBRATION ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent("30");
                if (retval.execResult != 0)
                {
                    log = "CALIBRATION ERROR - SET DIODE CURRENT. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth("0.5");
                if (retval.execResult != 0)
                {
                    log = "CALIBRATION ERROR - SET PULSE WIDTH. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
#endif
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                //retval = await EmissionON();
                if (retval.execResult != 0)
                {
                    log = "CALIBRATION ERROR - START EMISSION. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                EmissionLamp.Fill = Brushes.Red;

                LenzCalibFlag = true;
                // 1 shot repeat

                //Task Jobtask1;
                for (int i = 0; i < calibCount; i++)
                {
                    //Jobtask1 = Task.Run(() => ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true));   //  Firmware Version 3.01 :  5 -> one shot
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true);
                    if (retval.execResult != 0)
                    {
                        log = "CALIBRATION ERROR - TESTSOLFET(30). (" + retval.execResult.ToString() + ")" + i.ToString();
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                    //await Jobtask1;
                    await Task.Delay(10);
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent("60");
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth("0.5");
                for (int i = 0; i < calibCount; i++)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true);
                    if (retval.execResult != 0)
                    {
                        log = "CALIBRATION ERROR - TESTSOLFET(60). (" + retval.execResult.ToString() + ")" + i.ToString();
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                    //Jobtask1 = Task.Run(() => ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true));   //  Firmware Version 3.01 :  5 -> one shot
                    //await Jobtask1;
                    await Task.Delay(10);
                }
                await Task.Delay(100);
                LenzCalibFlag = false;

                if (LenzCalib.Count == calibCount * 2)
                {   // calculate calibration curve parameters
                    int c = 0; double sum30 = 0.0; double sum60 = 0.0;
                    foreach (var cal in LenzCalib)
                    {
                        if (c < calibCount) sum30 += cal;
                        else sum60 += cal;
                        c++;
                    }
                    sum30 /= calibCount; sum60 /= calibCount;
                    slope = 30.0 / (sum60 - sum30);
                    intercept = 30.0 - sum30 * slope;

                    var CalStr = "Calibration of Lenz : slope/intercept = " + slope.ToString("F4") + "/" + intercept.ToString("F4");

                    ShowLog((byte)LOGTYPE.LOG_NORMAL, "CALIBRATION", CalStr);
                    //Debug.WriteLine(CalStr);
                    //ControlWindow.txt_log.AppendText(CalStr + Environment.NewLine);

                    // confirm current power setting
                    value = "";
                    Util.GetPrivateProfileValue("PROFILE", "MARK_POWER", "10", ref value, Constants.PARAMS_INI_FILE);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(value);
                    value = "";
                    Util.GetPrivateProfileValue("PROFILE", "MARK_WIDTH", "0.5", ref value, Constants.PARAMS_INI_FILE);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(value);

                    if ((bool)EmissionAuto.IsChecked)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                        //retval = await EmissionON();
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        EmissionLamp.Fill = Brushes.Red;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true);
                }
                LenzCalib.Clear();
            }
            finally
            {
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                //retval = await EmissionOFF();
                if (retval.execResult != 0)
                {
                    log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                }
                EmissionLamp.Fill = Brushes.Black;

                ShowLog((byte)LOGTYPE.LOG_END, "CALIBRATION");
                //Btn_Calib.IsEnabled = true;
            }
        }

        private void btnGoCenerPoint_Click(object sender, RoutedEventArgs e)
        {

        }

        private async void btnEmissionOff_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnEmissionOff_Click";

            //HeadValue headvalue = new HeadValue();
            //byte byHeadType = 0;
            //string value = "";
            string cmd = "STOP EMISSION";
            string log = "";
            //int retval = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                }
                //retval = await EmissionOFF();
                if (retval.execResult != 0)
                {
                    log = "StopEmission. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                else
                {
                    ShowRectangle(EmissionLamp, Brushes.Black);
                    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                }
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnCheckLPMComm_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnCheckLPMComm_Click";

            string cmd = "CHECK LPM COMM";
            string log = "";
            //int retval = 0;
            ITNTResponseArgs retval = new ITNTResponseArgs();

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.SendMessage();
                //if (retval.execResult != 0)
                //{
                //    log = "StopEmission. (RESULT = " + retval.execResult.ToString() + ")";
                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //    await((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                //    return;
                //}
                //else
                //{
                //    ShowRectangle(EmissionLamp, Brushes.Black);
                //    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                //}
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void btnSaveTeachingZPos_Click(object sender, RoutedEventArgs e)
        {
            string patname = "";
            string patternfile = "";

            try
            {
                //if(txtCurrentPosZ.te)
                if (txtCurrentPosZ.Text.Length <= 0)
                    return;

                if (cbxPatternList.SelectedIndex < 0)
                {
                    return;
                }

                patname = cbxPatternList.SelectedItem.ToString();
                if (patname.Length <= 0)
                    return;

                patternfile = Constants.PATTERN_PATH + patname + ".ini";
                FileInfo fi = new FileInfo(patternfile);
                if (fi.Exists == false)
                {
                    return;
                }

                txtTeachingZPos.Text = txtCurrentPosZ.Text;

                Util.WritePrivateProfileValue("POSITION", "TEACHING_Z_AXIS", txtCurrentPosZ.Text, patternfile);
                btnSaveTeachingZPos.IsEnabled = false;
            }
            catch (Exception ex)
            {
                 
            }
        }

        private string GetTextBoxData(TextBox textBox)
        {
            string retval = "";
            if (textBox.CheckAccess())
            {
                retval = textBox.Text.ToString();
            }
            else
            {
                retval = textBox.Dispatcher.Invoke(new Func<string>(delegate
                {
                    string ret = "";
                    ret = textBox.Text.ToString();
                    return ret;
                }));
            }

            return retval;
        }

        //private async Task<ITNTResponseArgs> EmissionON()
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "EmissionON";

        //    ITNTResponseArgs retval = new ITNTResponseArgs();
        //    string value = "";
        //    Stopwatch sw = new Stopwatch();
        //    string log = "";
        //    LASERSTATUS Status = 0;
        //    bool bEmissionOn = false;

        //    try
        //    {
        //        //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
        //        Util.GetPrivateProfileValue("LASER", "HWCONTROL", "0", ref value, Constants.PARAMS_INI_FILE);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "HWCONTROL = " + value, Thread.CurrentThread.ManagedThreadId);
        //        if (value != "0")
        //            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetEmissionOnOff(1);
        //        else
        //            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();

        //        if (retval.execResult != 0)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "SETTING EMISSION ON ERROR : " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);

        //            return retval;
        //        }

        //        sw.Start();
        //        while (sw.Elapsed < TimeSpan.FromMilliseconds(1000))
        //        {
        //            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
        //            if (retval.execResult != 0)
        //            {
        //                log = "READ LASER STATUS. (RESULT = " + retval.execResult.ToString() + ")";
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //                return retval;
        //            }

        //            string[] st = retval.recvString.Split(':');
        //            if (st.Length < 2)
        //            {
        //                log = "READ LASER STATUS. (STATUS STRING)";
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //                retval.execResult = -1;
        //                return retval;
        //            }
        //            //2-1. Check emission status
        //            Status = (LASERSTATUS)UInt32.Parse(st[1]);
        //            if ((Status & LASERSTATUS.EmissionOnOff) != 0)
        //            {
        //                bEmissionOn = true;
        //                break;
        //                //ShowRectangle(EmissionLamp, Brushes.Red);
        //                //EmissionLamp.Fill = Brushes.Black;
        //            }
        //            await Task.Delay(200);
        //        }

        //        if (bEmissionOn)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "EMISSION ON OK", Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = 0;
        //            return retval;
        //        }
        //        else
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "EMISSION ON FAIL", Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = -2;
        //            return retval;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
        //        retval.execResult = ex.HResult;
        //    }
        //    return retval;
        //}

        private async void btnVisionReady_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnVisionReady_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;
            short sVisionX = 0;
            short sParkY = 0;
            short sParkZ = 0;
            PositionValue posvalue = new PositionValue();
            ScanValue scanval = new ScanValue();
            HeadValue headval = new HeadValue();
            string cmd = "VISON READY";
            string status = "";
            string patternName = "";
            string value = "";
            string rawtype = "";
            byte byUsePattern = 0;

            string patName = "";
            string vinstring = " KMTFE11DDRU041221 ";
            string seq = "4432";
            ITNTSendArgs args = new ITNTSendArgs(64);
            string sendmsg = "";
            string dist1 = "0000000000";
            string dist2 = "0000000000";
            byte sOrder = 1;
            double headPos = 0.0;
            double linkPos = 0.0;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                ReadPatternPositionValue(ref posvalue);
                ReadPatternScanValue(ref scanval);
                ReadPatternHeadValue(ref headval);

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                //1. go to link position
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "GO TO LINK POSITION");
                sVisionX = (short)(headval.park3DPos.X * stepLength + 0.5);
                sParkY = (short)(headval.park3DPos.Y * stepLength + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * stepLength + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    //ShowLog();
                    return;
                }

                if (scanval.stepLength_U <= 0)
                    scanval.stepLength_U = 100;

                sVisionX = (short)(scanval.linkPos * scanval.stepLength_U + 0.5);
                sParkY = (short)(headval.park3DPos.Y * scanval.stepLength_U + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * scanval.stepLength_U + 0.5);

                m_currCMD = (byte)'M';
                retval = await((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[GO TO VISION POSITION] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }

                await Task.Delay(250);
                await Task.Delay(250);
                await Task.Delay(250);
                await Task.Delay(250);

                //2. link
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "LINK ON");

                if (txtCurrentPosX.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - UNKNOWN POSITION");
                    return;
                }

                double.TryParse(txtCurrentPosX.Text, out headPos);
                double.TryParse(txtVisionLinkPos.Text, out linkPos);
                if (headPos <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INVALID POSITION");
                    return;
                }

                if (headPos != linkPos)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INCORECT POSITION");
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }

                if (scanval.reverseScan == 1)
                    ckbReverseScan.IsChecked = true;
                else
                    ckbReverseScan.IsChecked = false;

                //3. go to start position
                Thread.Sleep(500);
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "GO TO START POSITION");

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                if (retval.execResult != 0)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                    return;
                }

                //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);

                if (retval.recvString.Length < 8)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                    return;
                }

                status = retval.recvString.Substring(4, 4);
                if (status != PLCControlManager.SIGNAL_PLC2PC_ON)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[SET LINK] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "SET LINK STATUS ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    Thread.Sleep(500);
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                    if (retval.execResult != 0)
                    {
                        //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                        return;
                    }

                    //ShowLog("[GET LINK STATUS] STATUS :" + retval.recvString);

                    if (retval.recvString.Length < 8)
                    {
                        //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                        return;
                    }

                    status = retval.recvString.Substring(4, 4);
                    if (status != PLCControlManager.SIGNAL_PLC2PC_ON)
                    {
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "LINK STATUS ERROR - LINK FAIL");
                        return;
                    }
                }

                sParkY = (short)(headval.park3DPos.Y * scanval.stepLength_U + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * scanval.stepLength_U + 0.5);
                if (ckbReverseScan.IsChecked == false)
                    sVisionX = (short)(scanval.startU * scanval.stepLength_U + 0.5);
                else
                    sVisionX = (short)((scanval.startU + scanval.scanLen) * scanval.stepLength_U + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    return;
                }

                m_currCMD = (byte)'M';
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[GO TO VISION POSITION] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");

                //4. send ready command to vision
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "SEND DATA TO VISION");
                if (cbxPatternList.SelectedIndex < 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "SELECT PATTERN", "");
                    return;
                }

                patternName = cbxPatternList.SelectedItem.ToString();
                Util.GetPrivateProfileValue("PATTERNNAME", patternName, "R", ref value, Constants.PARAMS_INI_FILE);
                rawtype = value.PadRight(4, ' ');

                vinstring = txtVIN.Text.ToString();
                byUsePattern = Util.GetPrivateProfileValueByte("OPTION", "USEPATTERN", 0, Constants.PARAMS_INI_FILE);
                if (byUsePattern != 0)
                {
                    patName = patternName.PadRight(16, ' ');
                    sendmsg = "C3" + seq + vinstring + rawtype + "1" + dist1 + dist2 + patName + "01" + sOrder.ToString("D2");
                }
                else
                {
                    sendmsg = "C2" + seq + vinstring + rawtype + "1" + dist1 + dist2 + "01" + sOrder.ToString("D2");
                }


                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0002 SEND VISION DATA", Thread.CurrentThread.ManagedThreadId);
                args.sendBuffer = Encoding.UTF8.GetBytes(sendmsg);
                args.sendString = sendmsg;
                args.dataSize = sendmsg.Length;
                Util.GetPrivateProfileValue("VISION", "TCPTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                if ((value == "0") || (value == "2"))
                    retval.execResult = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionServer.SendMessage(args);
                else
                    retval.execResult = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionClient.SendMessage(args);
                //retval.execResult = await ((MainWindow)System.Windows.Application.Current.MainWindow).vision.SendMessage(args);
                if(retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "SEND DATA TO VISION", "ERROR : " + retval.execResult.ToString());
                    return;
                }

                //5. send execute command to vision
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "SEND EXECUTION TO VISION");

                if (byUsePattern != 0)
                {
                    patName = patternName.PadRight(16, ' ');
                    sendmsg = "C7" + seq + vinstring + rawtype + "1" + dist1 + dist2 + patName + "01" + sOrder.ToString("D2");
                }
                else
                {
                    sendmsg = "C6" + seq + vinstring + rawtype + "1" + dist1 + dist2 + "01" + sOrder.ToString("D2");
                }


                //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "0002 SEND VISION DATA", Thread.CurrentThread.ManagedThreadId);
                args.sendBuffer = Encoding.UTF8.GetBytes(sendmsg);
                args.sendString = sendmsg;
                args.dataSize = sendmsg.Length;

                Util.GetPrivateProfileValue("VISION", "TCPTYPE", "0", ref value, Constants.PARAMS_INI_FILE);
                if ((value == "0") || (value == "2"))
                    retval.execResult = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionServer.SendMessage(args);
                else
                    retval.execResult = await ((MainWindow)System.Windows.Application.Current.MainWindow).visionClient.SendMessage(args);
                //retval.execResult = await ((MainWindow)System.Windows.Application.Current.MainWindow).vision.SendMessage(args);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "SEND COMMAND TO VISION", "ERROR : " + retval.execResult.ToString());
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");

            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnVisionFinish_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnVisionFinish_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            short stepLength = 0;
            short sVisionX = 0;
            short sParkY = 0;
            short sParkZ = 0;
            PositionValue posvalue = new PositionValue();
            ScanValue scanval = new ScanValue();
            HeadValue headval = new HeadValue();
            string cmd = "VISON READY";
            string status = "";
            string patternName = "";
            string value = "";
            string rawtype = "";
            byte byUsePattern = 0;
            double headPos = 0.0;
            double linkPos = 0.0;

            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                ReadPatternPositionValue(ref posvalue);
                ReadPatternScanValue(ref scanval);
                ReadPatternHeadValue(ref headval);

                short.TryParse(lblStepLength.Content.ToString(), out stepLength);
                if (stepLength <= 0)
                    stepLength = 100;

                //1. go to link position
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "GO TO LINK POSITION");
                sVisionX = (short)(headval.park3DPos.X * stepLength + 0.5);
                sParkY = (short)(headval.park3DPos.Y * stepLength + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * stepLength + 0.5);

                retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                if (retval.execResult != 0)
                {
                    //ShowLog();
                    return;
                }

                if (scanval.stepLength_U <= 0)
                    scanval.stepLength_U = 100;

                sVisionX = (short)(scanval.linkPos * scanval.stepLength_U + 0.5);
                sParkY = (short)(headval.park3DPos.Y * scanval.stepLength_U + 0.5);
                sParkZ = (short)(headval.park3DPos.Z * scanval.stepLength_U + 0.5);

                m_currCMD = (byte)'M';
                retval = await((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoPoint(sVisionX, sParkY, sParkZ, 0);
                if (retval.execResult != 0)
                {
                    //ShowLog("[GO TO VISION POSITION] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GO POINT ERROR - " + retval.execResult.ToString());
                    return;
                }

                await Task.Delay(250);
                await Task.Delay(250);
                await Task.Delay(250);
                await Task.Delay(250);

                //2. link off
                ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "LINK OFF");

                if (txtCurrentPosX.Text.Length <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - UNKNOWN POSITION");
                    return;
                }

                double.TryParse(txtCurrentPosX.Text, out headPos);
                double.TryParse(txtVisionLinkPos.Text, out linkPos);
                if (headPos <= 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INVALID POSITION");
                    return;
                }

                if (headPos != linkPos)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "CURRENT POSITION IS NOT LINK POSITION - INCORECT POSITION");
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetLinkAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                if (retval.execResult != 0)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", retval.execResult.ToString());
                    return;
                }

                Thread.Sleep(500);
                Thread.Sleep(500);
                Thread.Sleep(500);
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadLinkStatusAsync();
                if (retval.execResult != 0)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - (" + retval.execResult.ToString() + ")");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - " + retval.execResult.ToString());
                    return;
                }

                if (retval.recvString.Length < 8)
                {
                    //ShowLog("[GET LINK STATUS] ERROR - PLC VALUE ERROR");
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - VALUE ERROR (" + retval.recvString + ")");
                    return;
                }

                status = retval.recvString.Substring(4, 4);
                if (status != PLCControlManager.SIGNAL_PLC2PC_OFF)
                {
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "GET LINK STATUS ERROR - LINK ON STATUS");
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnLASERCOMMTEST_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnLASERCOMMTEST_Click";

            ITNTResponseArgs retval = new ITNTResponseArgs();
            string log = "";
            //PositionValue posvalue = new PositionValue();
            //ScanValue scanval = new ScanValue();
            //HeadValue headval = new HeadValue();
            string cmd = "LASER COMM TEST";
            //string status = "";
            //string patternName = "";
            //string value = "";
            //string rawtype = "";
            //byte byUsePattern = 0;
            bool bCheck = false;


            try
            {
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                while (bCheck == false)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON(2);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN ABO 1", Thread.CurrentThread.ManagedThreadId);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON(2);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN ABO 2", Thread.CurrentThread.ManagedThreadId);
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamON(2);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "AimingBeamON. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    //2.read laser status
                    //ShowLog("MARKING - READ LASER STATUS");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus(2);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN STA 11", Thread.CurrentThread.ManagedThreadId);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus(2);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN STA 12!!!!!!!!!!", Thread.CurrentThread.ManagedThreadId);
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus(2);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "READ LASER STATUS. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadPeakPower(2);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN RPP 11", Thread.CurrentThread.ManagedThreadId);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadPeakPower(2);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN RPP 12!!!!!!!!!!!!", Thread.CurrentThread.ManagedThreadId);
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadPeakPower(2);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "READ LASER PEAK POWER. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadBoardTemperature(2);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN RBT 11", Thread.CurrentThread.ManagedThreadId);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadBoardTemperature(2);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN RBT 12!!!!!!!!!!", Thread.CurrentThread.ManagedThreadId);
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadBoardTemperature(2);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "READ BOARD TEMPERATURE. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_START, cmd, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00", 2);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN SPB 11", Thread.CurrentThread.ManagedThreadId);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00", 2);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN SPB 12!!!!!!!!!!!!", Thread.CurrentThread.ManagedThreadId);
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00", 2);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF(2);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN ABF 11", Thread.CurrentThread.ManagedThreadId);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF(2);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "AGAIN ABF 12!!!!!!!!!!", Thread.CurrentThread.ManagedThreadId);
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF(2);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                    if (AgingStop.IsChecked == true)
                        break;

                    await Task.Delay(100);
                }
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("EXCEPTION ERROR = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void btnLPMTest_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnLPMTest_Click";

            string cmd = "LPM TEST";
            ITNTResponseArgs retval = new ITNTResponseArgs();
            Stopwatch sw = new Stopwatch();

            string value = "";
            string patternName = "";
            byte bHeadType = 0;
            //PatternValueEx pattern = new PatternValueEx();
            LaserValue laserValue = new LaserValue();
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();
            bool ret = false;
            string log = "";

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                var message = System.Text.Encoding.UTF8.GetBytes("Z");
                ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.SendMessage(message);

                sw.Start();
                while (sw.Elapsed < TimeSpan.FromSeconds(1))
                {
                    await Task.Delay(50);
                }
                sw.Stop();


                if (EmissionAuto.IsChecked == true)
                {
                    msg2.Message = "LASER EMISSION IS TURNED ON.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }
                else
                {
                    msg2.Message = "LASER EMISSION IS TURNED OFF.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }

                msg3.Message = "DO YOU WANT TO START MARKING?";
                msg3.Fontsize = 20;
                msg3.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg3.VerticalContentAlignment = VerticalAlignment.Center;
                msg3.Foreground = Brushes.Red;
                msg3.Background = Brushes.White;

                WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                ret = warning.ShowDialog().Value;

                if (ret == false)
                {
                    log = "USER CANCEL";
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log, log);
                    return;
                }

                if (cbxPatternList.SelectedIndex >= 0)
                    patternName = cbxPatternList.SelectedItem.ToString();
                else
                    patternName = "Pattern_DEFAULT";

                ReadPatternLaserValue(ref laserValue);

#if LASER_YLR_PULSEMODE
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(pattern.laserValue.waveformNum.ToString());
                if (retval.execResult != 0)
                {
                    log = "SELECT PROFILE ERROR (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                string[] prsel = retval.recvString.Split('[', ']');
                if (prsel.Length < 2)
                {
                    log = "SELECT PROFILE STRING ERROR (LENGTH = " + prsel.Length.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                if (prsel[0] != "PRSEL: ")
                {
                    log = "SELECT PROFILE SETTING ERROR (PRSEL[0] = " + prsel[0] + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                string[] sel = prsel[1].Split(':');
                if (pattern.laserValue.waveformNum.ToString() != sel[0])
                {
                    log = "SELECT PROFILE NOT MATCH ERROR (SEL[0] = " + sel[0] + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                //4. get waveform mode
                //ShowLog("MARKING - CONFIG WAVEFORM MODE");
                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
                if (retval.execResult != 0)
                {
                    log = "CONFIG WAVEFORM ERROR (" + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                string[] pcfg = retval.recvString.Split('[', ']');
                if (pcfg.Length < 2)
                {
                    log = "CONFIG WAVEFORM PROFILE ERROR (LENGTH = " + pcfg.Length.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
#else

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                }
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(laserValue.spotPower);
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(laserValue.spotPower);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(laserValue.spotPower);
                }
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SELECT SPOT POWER. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    return;
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(laserValue.spotWidth);
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(laserValue.spotWidth);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(laserValue.spotWidth);
                }
                if (retval.execResult != 0)
                {
                    log = "MARKING ERROR - SELECT SPOT WIDTH. (" + retval.execResult.ToString() + ")";
                    //ShowLog(log);
                    retval.errorInfo.sErrorMessage = log;
                    retval.errorInfo.sErrorCode = "";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    return;
                }
#endif
                if ((bool)EmissionAuto.IsChecked)
                {
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "LASER EMISSION ON");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    }
                    //retval = await EmissionON();
                    if (retval.execResult != 0)
                    {
                        log = "LASER EMISSION ON ERROR (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                    //ShowLog("LASER EMISSION ON SUCCESS");
                    ShowRectangle(EmissionLamp, Brushes.Red);
                }

                for(int i = 0; i < 6; i ++)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.TestSolFet(5, true);    //  Firmware Version 2.55 :  5 -> On-Delay-Off
                    if (retval.execResult != 0)
                    {
                        log = "TEST SOL FET ERROR (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        }
                        ShowRectangle(EmissionLamp, Brushes.Black);

                        return;
                    }

                    await Task.Delay(50);
                }

                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                }
                ShowRectangle(EmissionLamp, Brushes.Black);
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void cbxPlateMode_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {

        }

        private async void btnLPMConnect_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnEmissionOff_Click";

            string cmd = "CONNECT TO LPM";
            string log = "";
            ITNTResponseArgs retval = new ITNTResponseArgs();
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();
            bool ret = false;
            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                msg3.Message = "DO YOU WANT TO CONNECT TO LPM AGAIN?";
                msg3.Fontsize = 20;
                msg3.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg3.VerticalContentAlignment = VerticalAlignment.Center;
                msg3.Foreground = Brushes.Red;
                msg3.Background = Brushes.White;

                WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                ret = warning.ShowDialog().Value;

                if (ret == false)
                {
                    log = "USER CANCEL";
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log, log);
                    return;
                }

                ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.CloseDevice();
                Task.Delay(500);
                retval.execResult = ((MainWindow)System.Windows.Application.Current.MainWindow).lpmControll.OpenDevice();
                if (retval.execResult != 0)
                {
                    log = cmd + " ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                ShowLog((byte)LOGTYPE.LOG_SUCCESS, cmd, "", "");
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
            }
            catch (Exception ex)
            {
                log = cmd + " ERROR. EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private void tabControl_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            string value = "";
            string tabstring = "";
            int index = 0;
            TabItem tabItem;

            try
            {
                if (e.Source is TabControl tabControl)
                {
                    tabItem = tabControl.SelectedItem as TabItem;
                    if(tabItem != null )
                    {
                        tabstring = tabItem.Header.ToString();
                        switch (tabstring)
                        {
                            case "TEST":
                            case "PATTERN DATA":
                                stpSavePatternInfo.Visibility = Visibility.Visible;
                                stpSaveMarkingHeadInfo.Visibility = Visibility.Hidden;
                                break;
                            default:
                                break;
                            case "MARKING HEAD":
                                stpSavePatternInfo.Visibility = Visibility.Hidden;
                                stpSaveMarkingHeadInfo.Visibility = Visibility.Visible;
                                break;
                        }
                    }
                }
            }
            catch(Exception ex)
            {

            }
        }

        private async void btnEmissionOn_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";
            string funcName = "btnEmissionOn_Click";

            string cmd = "START EMISSION";
            string log = "";
            ITNTResponseArgs retval = new ITNTResponseArgs();

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                retval = await((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                }
                //retval = await EmissionON();
                if (retval.execResult != 0)
                {
                    log = "Start Emission. (RESULT = " + retval.execResult.ToString() + ")";
                    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    return;
                }
                else
                {
                    ShowRectangle(EmissionLamp, Brushes.Black);
                    ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                }
            }
            catch (Exception ex)
            {
                log = "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message;
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", log);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
            }
        }

        private async void BlinkIfError(LogEntry entry)
        {
            // Error 레벨이 아닌 경우 깜박이지 않음
            if (entry.Level != LogLevel.Error) return;

            // UI 쓰레드에서 동작
            await Dispatcher.InvokeAsync(async () =>
            {
                lsbResult.UpdateLayout();
                lsbResult.ScrollIntoView(entry);

                // 해당 아이템의 ListBoxItem 컨테이너 가져오기
                var listBoxItem = (ListBoxItem)lsbResult.ItemContainerGenerator.ContainerFromItem(entry);
                if (listBoxItem == null) return;

                // ItemTemplate 내부의 Border 찾기
                var border = FindChild<Border>(listBoxItem, "ItemBorder");
                if (border == null) return;

                // 기존 Brush 저장
                var originalBrush = border.Background;

                // 깜박임 색상
                var blinkBrush = new SolidColorBrush(Colors.Yellow);

                int blinkCount = 2;
                for (int i = 0; i < blinkCount; i++)
                {
                    border.Background = blinkBrush;
                    await Task.Delay(120);
                    border.Background = originalBrush;
                    await Task.Delay(120);
                }
            });
        }

        private async void btnCleaning_Click(object sender, RoutedEventArgs e)
        {
            string className = "SetControllerWindow3";// MethodBase.GetCurrentMethod().DeclaringType.Name;
            string funcName = "btnCleaning_Click";// MethodBase.GetCurrentMethod().Name;
            ITNTResponseArgs retval = new ITNTResponseArgs();
            LASERSTATUS Status = 0;
            string value = "";
            string log = "";
            PositionValue posValue = new PositionValue();
            HeadValue headValue = new HeadValue();
            int repeatCount = 0;
            int stop = 0;
            string patName = "";
            string cmd = "CLEANING";
            bool ret = false;
            ConfirmWindowString msg1 = new ConfirmWindowString();
            ConfirmWindowString msg2 = new ConfirmWindowString();
            ConfirmWindowString msg3 = new ConfirmWindowString();
            ConfirmWindowString msg4 = new ConfirmWindowString();
            ConfirmWindowString msg5 = new ConfirmWindowString();

            //Stopwatch swMark = new Stopwatch();
            Stopwatch swLaser = new Stopwatch();
            Stopwatch swClean = new Stopwatch();

            PatternValueEx pattern = new PatternValueEx();
            int markcount = 0;

            try
            {
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "START", Thread.CurrentThread.ManagedThreadId);
                if (EmissionAuto.IsChecked == true)
                {
                    msg2.Message = "LASER EMISSION IS TURNED ON.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }
                else
                {
                    msg2.Message = "LASER EMISSION IS TURNED OFF.";
                    msg2.Fontsize = 20;
                    msg2.HorizontalContentAlignment = HorizontalAlignment.Center;
                    msg2.VerticalContentAlignment = VerticalAlignment.Center;
                    msg2.Foreground = Brushes.Red;
                    msg2.Background = Brushes.White;
                }

                msg3.Message = "(THIS IS ONLY FOR CLEANING)";
                msg3.Fontsize = 20;
                msg3.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg3.VerticalContentAlignment = VerticalAlignment.Center;
                msg3.Foreground = Brushes.Red;
                msg3.Background = Brushes.White;

                msg4.Message = "DO YOU WANT TO START MARKING?";
                msg4.Fontsize = 20;
                msg4.HorizontalContentAlignment = HorizontalAlignment.Center;
                msg4.VerticalContentAlignment = VerticalAlignment.Center;
                msg4.Foreground = Brushes.Red;
                msg4.Background = Brushes.White;

                WarningWindow warning = new WarningWindow("", msg1, msg2, msg3, msg4, msg5, "OK", "NO", this, 1);
                warning.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                ret = warning.ShowDialog().Value;

                if (ret == false)
                {
                    return;
                }

                ShowLog((byte)LOGTYPE.LOG_START, cmd, "");

                Util.GetPrivateProfileValue("OPTION", "ISDUALHEAD", "0", ref value, Constants.MARKING_INI_FILE);
                if ((value != "0") && (value != ""))
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.ReadUseLaserNum();
                    if (retval.execResult != 0)
                    {
                        log = "ReadUseLaserNum ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }

                    if (retval.recvString.Length < 8)
                    {
                        log = "PLC DATA LENGTH INVALID (ReadUseLaserNum) : " + retval.recvString.Length + " - " + retval.recvString;
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        return;
                    }

                    byte byLaserNumber = 0;
                    byte byReadNumber = 0;
                    string tmpNumber = retval.recvString.Substring(4, 4);
                    byte.TryParse(tmpNumber, out byLaserNumber);

                    Util.GetPrivateProfileValue("MARK", "USEHEADNO", "1", ref value, Constants.PARAMS_INI_FILE);
                    byte.TryParse(value, out byReadNumber);

                    if ((byReadNumber != byLaserNumber) || (byLaserNumber == 0))
                    {
                        log = "MARKING ERROR - MARK HEADER NUMBER IS INVALID. (SETTING = " + byReadNumber.ToString() + ", REAL = " + byLaserNumber.ToString() + ")";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        return;
                    }
                }

                int.TryParse(tbxRunRepeatCount.Text, out repeatCount);
                if (repeatCount <= 0)
                    repeatCount = 1;

                if (AirOnOff.IsChecked == true)
                {
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_ON);
                    if (retval.execResult != 0)
                    {
                        log = "SendAirAsync ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        return;
                    }
                }

                //ckbStopMark.IsChecked = false;
                if (repeatCount > 1)
                    ckbStopMark.Visibility = Visibility.Visible;
                else
                    ckbStopMark.Visibility = Visibility.Collapsed;

                while (repeatCount > 0)
                {
                    int.TryParse(tbxRunRepeatCount.Text, out stop);
                    if (stop <= 0)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        break;
                    }

                    if (ckbStopMark.IsChecked == true)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        break;
                    }
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "START CLEANING");
                    //swMark.Start();

                    if (cbxPatternList.SelectedIndex < 0)
                        patName = "Pattern_DEFAULT";
                    else
                        patName = cbxPatternList.Text;

                    if (bReadFontValue == false)
                    {
                        ReadPatternValue(ref pattern);
                        retval.execResult = ReadFontData(cmd, patName);
                        if (retval.execResult != 0)
                        {
                            log = "READ FONT ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        bReadFontValue = true;
                    }
                    await ShowCurrentMarkingInformation(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, 2);
                    GetVinCharacterFontDot(currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.fontData, currMarkInfo.currMarkData.fontSizeX, currMarkInfo.currMarkData.fontSizeY, currMarkInfo.currMarkData.shiftValue, currMarkInfo.currMarkData.pattern.fontValue.fontName);

#if LASER_OFF
#else
                    //1. Aiming Beam OFF
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.AimingBeamOFF();
                    }
                    if (retval.execResult != 0)
                    {
                        log = "AimingBeamOFF. (RESULT = " + retval.execResult.ToString() + ")";
                        //ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        //return;
                    }
                    else
                        ShowRectangle(AimingLamp, Brushes.Black);

                    //2.read laser status
#endif
                    //3. load waveform profile number
                    // ShowLog("MARKING - SELECT PROFILE");
#if LASER_OFF
#else

#if LASER_YLR_PULSEMODE
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString());
                    if (retval.execResult != 0)
                    {
                        log = "SELECT PROFILE. (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] prsel = retval.recvString.Split('[', ']');
                    if (prsel.Length < 2)
                    {
                        log = "SELECT PROFILE. (PROFILE STRING)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    if (prsel[0] != "PRSEL: ")
                    {
                        log = "SELECT PROFILE. (PROFILE SETTING RESPONSE ERROR)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] sel = prsel[1].Split(':');
                    if (currMarkInfo.currMarkData.pattern.laserValue.waveformNum.ToString() != sel[0])
                    {
                        log = "SELECT PROFILE. (PROFILE SETTING ERROR)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //4. get waveform mode
                    //ShowLog("MARKING - CONFIG WAVEFORM MODE");
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ConfigWaveformMode(0);
                    if (retval.execResult != 0)
                    {
                        log = "CONFIG WAVEFORM MODE. (" + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    string[] pcfg = retval.recvString.Split('[', ']');
                    if (pcfg.Length < 2)
                    {
                        log = "CONFIG WAVEFORM MODE. (PROFILE STRING)";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
#else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseRepetitionRate("1.00");
                    }
                    if (retval.execResult != 0)
                    {
                        log = cmd + " ERROR - SET PULSE RATE. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
#endif
#endif
                    //5. Clear Dispaly
                    //ClearMarkVINDisplay();

                    //6. Start Text
                    retval = await Start_TEXT2(cmd, currMarkInfo.currMarkData.mesData.markvin, currMarkInfo.currMarkData.pattern);
                    if (retval.execResult != 0)
                    {
                        log = "Start_TEXT3. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //posValue = (PositionValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
                    //headValue = (headValue)currMarkInfo.currMarkData.pattern.positionValue.Clone();
                    ReadPatternPositionValue(ref posValue);
                    ReadPatternHeadValue(ref headValue);

                    //5. Set Font Data Buffer Flush
                    //ShowLog("MARKING - FLUSH START");
                    m_currCMD = (byte)'B';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.FontFlush();
                    if (retval.execResult != 0)
                    {
                        log = "FONT FLUSH. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }
                    //ShowLog("MARKING - FONT FLUSH SUCCESS");

                    //if(pattern.laserValue.density == 1)
                    {
                        //ShowLog("MARKING - SET PHASE COMPENSATION");
                        Single pc = Convert.ToSingle(txtPhaseComp.Text);
                        //pc = pattern.laserValue.phaseComp;
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "CALL PHASECOMP", Thread.CurrentThread.ManagedThreadId);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(currMarkInfo.currMarkData.pattern.laserValue.phaseComp);
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetPhaseComp(pc);
                        if (retval.execResult != 0)
                        {
                            log = "SET PHASE COMPENSATION. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                    }

                    m_currCMD = (byte)'d';
                    short dwelltime = 0;
                    if (rbtMarkingPos2.IsChecked == true)
                        short.TryParse(txtMarkDelayTime2.Text, out dwelltime);
                    else
                        short.TryParse(txtMarkDelayTime1.Text, out dwelltime);

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.dwellTimeSet(dwelltime);
                    if (retval.execResult != 0)
                    {
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("dwellTimeSet ERROR = {0}", retval.execResult), Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    ////currMarkInfo.senddata.SendDataIndex = 0;
                    ////markdata.EndOfSend = false;
                    //currMarkInfo.senddata.CleanFireFlag = false;    // Fire sending
                    ////currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataFire.Count;
                    //string StPoint = currMarkInfo.senddata.sendDataFire.ElementAt(0);

                    //short posX = 0;
                    //short posY = 0;
                    //short posZ = 0;
                    //value = StPoint.Substring(4, 4);
                    //short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posX);

                    //value = StPoint.Substring(8, 4);
                    //short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posY);

                    //value = StPoint.Substring(12, 4);
                    //short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posZ);
                    //posZ += 500;

                    ////7. Go to parking point (Check Point)
                    ////ShowLog("MARKING - LOAD SPEED");

                    //retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    //if (retval.execResult != 0)
                    //{
                    //    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                    //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    //    return;
                    //}

                    ////StPoint.Substring(4, 4 + 4);
                    //m_currCMD = (byte)'K';
                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    //if (retval.execResult != 0)
                    //{
                    //    log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                    //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    //    return;
                    //}


                    //mark.Density("N", Density.ToString("X4"));
                    //ShowLog("MARKING - SET DENSITY");
                    m_currCMD = (byte)'N';
                    //Density232 = (short)currMarkInfo.currMarkData.pattern.laserValue.density;
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.SetDensity((short)currMarkInfo.currMarkData.pattern.laserValue.density);
                    if (retval.execResult != 0)
                    {
                        log = "SET DENSITY. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.MarkMoving);
                    //if (retval.execResult != 0)
                    //{
                    //    log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                    //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    //    return;
                    //}

                    // Run Marking
                    //Stopwatch sw = Stopwatch.StartNew();

                    //Thread.Sleep(200);

                    //////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if LASER_OFF
                    swClean.Start();
                    //if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor)
                    if ((bool)CleaningBox.IsChecked && !currMarkInfo.checkdata.ErrorDistanceSensor && (currMarkInfo.currMarkData.pattern.laserValue.combineFireClean == 0))
                    {
                        m_currCMD = (byte)'L';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
                        if (retval.execResult != 0)
                        {
                            log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                            //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
                            //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
                            //ITNTErrorCode();
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                            return;
                        }

                        if ((bool)EmissionAuto.IsChecked)
                        {
                            //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            //{
                            //    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            //        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            //}
                            ////retval = await EmissionON();
                            //if (retval.execResult != 0)
                            //{
                            //    log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            //    return;
                            //}
                            //ShowRectangle(EmissionLamp, Brushes.Red);
                            ////EmissionLamp.Fill = Brushes.Red;
                        }

                        //currMarkInfo.senddata.SendDataIndex = 0;
                        currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                       //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

                        //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
                        //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);

                        m_currCMD = (byte)'@';
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true);
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }

                        swClean.Stop();
                        log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
                        swClean.Reset();
                        ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    }
#else

                    swClean.Start();
#if LASER_YLR_PULSEMODE
                            //Util.GetPrivateProfileValue("VINDATA", "PROFILECLEAN", "0", ref value, "Parameter.ini");                 // load waveform profile number
                            value = currMarkInfo.currMarkData.pattern.laserValue.waveformClean.ToString();
                            ShowTextBoxData(txtCurrProfile, value);
                            //txtCurrProfile.Text = value;
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SelectProfile(value);
                            prsel = retval.recvString.Split('[', ']');
                            if (prsel[0] != "PRSEL: ")
                            {
                                log = "Profile setting Error2!. (PRSEL[0] = " + prsel[0] + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
                            sel = prsel[1].Split(':');
                            if (value != sel[0])
                            {
                                log = "Profile setting Error!. (SEL[0] = " + sel[0] + ")";
                                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                                return;
                            }
#else
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetDiodeCurrent(currMarkInfo.currMarkData.pattern.laserValue.cleanPower);
                        }
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SELECT CLEAN POWER. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }

                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                    if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.SetPulseWidth(currMarkInfo.currMarkData.pattern.laserValue.cleanWidth);
                    }
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - SELECT CLEAN WIDTH. (" + retval.execResult.ToString() + ")";
                        //ShowLog(log);
                        retval.errorInfo.sErrorMessage = log;
                        retval.errorInfo.sErrorCode = "";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }
#endif
                    m_currCMD = (byte)'L';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.LoadSpeed(m_currCMD, currMarkInfo.currMarkData.pattern.speedValue.initSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.targetSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.accelSpeed4Clean, currMarkInfo.currMarkData.pattern.speedValue.decelSpeed4Clean);
                    if (retval.execResult != 0)
                    {
                        log = "MARKING ERROR - LOAD SPEED. (" + retval.execResult.ToString() + ")";
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);

                        //retval.sErrorMessage = orderstring + " MARKING ERROR - LoadSpeed : " + retval.execResult.ToString();
                        //ShowLog(className, funcName, 2, orderstring + " MARKING ERROR - LoadSpeed", retval.execResult.ToString());
                        //ITNTErrorCode();
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                        return;
                    }

                    swLaser.Start();
                    if ((bool)EmissionAuto.IsChecked)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StartEmission();
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        //retval = await EmissionON();
                        ShowRectangle(EmissionLamp, Brushes.Red);
                        //EmissionLamp.Fill = Brushes.Red;
                    }

                    //currMarkInfo.senddata.SendDataIndex = 0;
                    currMarkInfo.senddata.CleanFireFlag = true;    // Clean sending
                                                                   //currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataClean.Count;

                    //StPoint = currMarkInfo.senddata.sendDataClean.ElementAt(currMarkInfo.senddata.SendDataIndex++);
                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(StPoint);
                    Util.GetPrivateProfileValue("OPTION", "MARKINGLOGLEVEL", "0", ref value, Constants.PARAMS_INI_FILE);
                    byte logLevel = 0;
                    byte.TryParse(value, out logLevel);

                    m_currCMD = (byte)'@';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.RunStart_S(currMarkInfo, true, logLevel);
                    if (retval.execResult != 0)
                    {
                        log = "RUN CLEANING. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    if ((bool)EmissionAuto.IsChecked)
                    {
                        retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                        if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                        {
                            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            if ((retval.execResult == (int)COMMUNICATIONERROR.ERR_COMMAND_BUSY) || (retval.execResult == (int)COMMUNICATIONERROR.ERR_CMD_MISSMATCH))
                            {
                                retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
                            }
                        }
                        if (retval.execResult != 0)
                        {
                            log = "RUN CLEANING. EMISSION OFF ERROR (" + retval.execResult.ToString() + ")";
                            ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                            await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                            return;
                        }
                        ShowRectangle(EmissionLamp, Brushes.Black);
                    }
#endif
                    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);

                    swLaser.Stop();
                    log = "LASER TIME : " + swLaser.ElapsedMilliseconds.ToString();
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    swLaser.Reset();

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    short stepLeng = currMarkInfo.currMarkData.pattern.headValue.stepLength;
                    if (stepLeng <= 0)
                        stepLeng = 100;



                    ////currMarkInfo.senddata.SendDataIndex = 0;
                    ////markdata.EndOfSend = false;
                    //currMarkInfo.senddata.CleanFireFlag = false;    // Fire sending
                    ////currMarkInfo.senddata.SendDataCount = (short)currMarkInfo.senddata.sendDataFire.Count;
                    //string StPoint = currMarkInfo.senddata.sendDataFire.ElementAt(0);

                    short posX = 0;
                    short posY = 0;
                    short posZ = 0;
                    //value = StPoint.Substring(4, 4);
                    //short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posX);

                    //value = StPoint.Substring(8, 4);
                    //short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posY);

                    //value = StPoint.Substring(12, 4);
                    //short.TryParse(value, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture, out posZ);
                    //posZ += 500;

                    ////7. Go to parking point (Check Point)
                    ////ShowLog("MARKING - LOAD SPEED");

                    retval = await SendMotorSpeed(cmd, (byte)motorSpeedType.FastMoving);
                    if (retval.execResult != 0)
                    {
                        log = "LOAD SPEED. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    ////StPoint.Substring(4, 4 + 4);
                    //m_currCMD = (byte)'K';
                    //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    //if (retval.execResult != 0)
                    //{
                    //    log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                    //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                    //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                    //    await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                    //    return;
                    //}

                    posX = (short)(headValue.park3DPos.X * stepLeng); if (posX <= 0) posX = (short)(70 * stepLeng);
                    posY = (short)(headValue.park3DPos.Y * stepLeng); if (posY <= 0) posY = (short)(20 * stepLeng);
                    posZ = (short)(headValue.park3DPos.Z * stepLeng); if (posZ <= 0) posZ = (short)(110 * stepLeng);
                    m_currCMD = (byte)'K';
                    retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).MarkControll.GoParking(posX, posY, posZ);
                    if (retval.execResult != 0)
                    {
                        log = "GO PARK. (RESULT = " + retval.execResult.ToString() + ")";
                        ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                        //await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                        return;
                    }

                    //Debug.WriteLine("Running Time : " + sw.Elapsed);
                    //sw.Stop();
                    //log = "TOTAL MARKING TIME : " + sw.ElapsedMilliseconds.ToString();
                    //ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    swClean.Stop();
                    log = "CLEAN TIME : " + swClean.ElapsedMilliseconds.ToString();
                    swClean.Reset();
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);

                    //swMark.Stop();
                    //log = "MARKING TIME : " + swMark.ElapsedMilliseconds.ToString();
                    //ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, log);
                    //swMark.Reset();


                    markcount++;
                    ShowLog((byte)LOGTYPE.LOG_NORMAL, cmd, "MARK COUNT : " + markcount.ToString());
                    //ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "Running Time : " + sw.Elapsed.ToString(), Thread.CurrentThread.ManagedThreadId);

                    repeatCount--;
                }

                //retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
                //if (retval.execResult != 0)
                //{
                //    log = "SendAirAsync ERROR. (RESULT = " + retval.execResult.ToString() + ")";
                //    ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, log, log);
                //    ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
                //    return;
                //}
                currMarkInfo.Initialize();
                ShowLog((byte)LOGTYPE.LOG_END, cmd, "");
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "END", Thread.CurrentThread.ManagedThreadId);
            }
            catch (Exception ex)
            {
                ShowLog((byte)LOGTYPE.LOG_FAILURE, cmd, "", "EXCEPTION CODE = " + ex.HResult.ToString() + ", MSG = " + ex.Message);
                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, string.Format("Btn_Start_Click = {0:X}, MSG = {1}", ex.HResult, ex.Message), Thread.CurrentThread.ManagedThreadId);
                await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SendAirAsync(PLCControlManager.SIGNAL_PC2PLC_OFF);
            }
        }


        public static T FindChild<T>(DependencyObject parent, string childName) where T : DependencyObject
        {
            if (parent == null) return null;

            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);

                if (child is T tChild && ((FrameworkElement)child).Name == childName)
                {
                    return tChild;
                }

                var foundChild = FindChild<T>(child, childName);
                if (foundChild != null)
                    return foundChild;
            }
            return null;
        }
        //private async Task<ITNTResponseArgs> EmissionOFF()
        //{
        //    string className = "SetControllerWindow3";
        //    string funcName = "EmissionON";

        //    ITNTResponseArgs retval = new ITNTResponseArgs();
        //    string value = "";
        //    Stopwatch sw = new Stopwatch();
        //    string log = "";
        //    LASERSTATUS Status = 0;
        //    bool bEmissionOff = false;

        //    try
        //    {
        //        Util.GetPrivateProfileValue("LASER", "HWCONTROL", "0", ref value, Constants.PARAMS_INI_FILE);
        //        ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "HWCONTROL = " + value, Thread.CurrentThread.ManagedThreadId);
        //        if (value != "0")
        //            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).plcComm.SetEmissionOnOff(0);
        //        else
        //            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.StopEmission();
        //        if (retval.execResult != 0)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "SETTING EMISSION OFF ERROR : " + retval.execResult.ToString(), Thread.CurrentThread.ManagedThreadId);

        //            return retval;
        //        }


        //        sw.Start();
        //        while (sw.Elapsed < TimeSpan.FromMilliseconds(1000))
        //        {

        //            retval = await ((MainWindow)System.Windows.Application.Current.MainWindow).laserSource.ReadDeviceStatus();
        //            if (retval.execResult != 0)
        //            {
        //                log = "READ LASER STATUS. (RESULT = " + retval.execResult.ToString() + ")";
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //                return retval;
        //            }

        //            string[] st = retval.recvString.Split(':');
        //            if (st.Length < 2)
        //            {
        //                log = "READ LASER STATUS. (STATUS STRING)";
        //                ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, log, Thread.CurrentThread.ManagedThreadId);
        //                retval.execResult = -1;
        //                return retval;
        //            }
        //            //2-1. Check emission status
        //            Status = (LASERSTATUS)UInt32.Parse(st[1]);
        //            if ((Status & LASERSTATUS.EmissionOnOff) == 0)
        //            {
        //                bEmissionOff = true;
        //                break;
        //                //ShowRectangle(EmissionLamp, Brushes.Red);
        //                //EmissionLamp.Fill = Brushes.Black;
        //            }
        //            await Task.Delay(200);
        //        }

        //        if (bEmissionOff)
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "EMISSION OFF OK", Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = 0;
        //            return retval;
        //        }
        //        else
        //        {
        //            ITNTTraceLog.Instance.Trace(0, "{0}:{3:D4}:{1}()  {2}", className, funcName, "EMISSION OFF FAIL", Thread.CurrentThread.ManagedThreadId);
        //            retval.execResult = -2;
        //            return retval;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        retval.execResult = ex.HResult;
        //    }
        //    return retval;
        //}


    }

    //public partial class SetControllerWindow3 : Window
    //{
    //    public SetControllerWindow3()
    //    {
    //        InitializeComponent();
    //    }
    //}
}
